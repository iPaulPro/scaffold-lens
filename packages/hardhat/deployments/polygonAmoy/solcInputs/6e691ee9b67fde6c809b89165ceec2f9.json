{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.6) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/FollowNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/FollowNFT.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/LensHub.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/LensHub.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/ActionLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/ActionLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/constants/Events.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/constants/Events.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/constants/Types.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/constants/Types.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/FollowLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/FollowLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/GovernanceLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/GovernanceLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/LegacyCollectLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/LegacyCollectLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/MetaTxLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/MetaTxLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/ProfileLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/ProfileLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/PublicationLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/PublicationLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/StorageLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/StorageLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/svgs/Follow/FollowSVG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/svgs/Follow/FollowSVG.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/svgs/Handle/GintoNordFontSVG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/svgs/Handle/GintoNordFontSVG.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/svgs/Handle/HandleSVG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/svgs/Handle/HandleSVG.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/svgs/Profile/SimpleProfileSVG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/svgs/Profile/SimpleProfileSVG.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/libraries/ValidationLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/libraries/ValidationLib.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/access/LitAccessControl.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/access/LitAccessControl.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/LegacyCollectNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/LegacyCollectNFT.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/LensHubInitializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/LensHubInitializable.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/ModuleRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/ModuleRegistry.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/PermissionlessCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/PermissionlessCreator.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/ProfileCreationProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/ProfileCreationProxy.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/PublicActProxy_MetaTx.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/PublicActProxy_MetaTx.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/PublicActProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/PublicActProxy.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/token-uris/FollowTokenURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/token-uris/FollowTokenURI.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/token-uris/HandleTokenURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/token-uris/HandleTokenURI.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/misc/token-uris/SimpleProfileTokenURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/misc/token-uris/SimpleProfileTokenURI.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/act/collect/CollectNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/act/collect/CollectNFT.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/act/collect/CollectPublicationAction.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/act/collect/CollectPublicationAction.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/act/collect/MultirecipientFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/act/collect/MultirecipientFeeCollectModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/act/collect/SimpleFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/act/collect/SimpleFeeCollectModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/follow/FeeFollowModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/follow/FeeFollowModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/follow/RevertFollowModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/follow/RevertFollowModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/reference/DegreesOfSeparationReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/reference/DegreesOfSeparationReferenceModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/modules/reference/FollowerOnlyReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/modules/reference/FollowerOnlyReferenceModule.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/namespaces/LensHandles.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/namespaces/LensHandles.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/lens-modules/contracts/namespaces/TokenHandleRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'lens-modules/contracts/namespaces/TokenHandleRegistry.sol';\n"
    },
    "contracts/helpers/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor() ERC20(\"TestToken\", \"TEST\") {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/TokenGatedCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ICollectModule} from \"lens-modules/contracts/modules/interfaces/ICollectModule.sol\";\nimport {LensModuleMetadata} from \"lens-modules/contracts/modules/LensModuleMetadata.sol\";\nimport {IModuleRegistry} from \"lens-modules/contracts/interfaces/IModuleRegistry.sol\";\nimport {BaseFeeCollectModule} from \"lens-modules/contracts/modules/act/collect/base/BaseFeeCollectModule.sol\";\nimport {BaseFeeCollectModuleInitData, BaseProfilePublicationData} from \"lens-modules/contracts/modules/interfaces/IBaseFeeCollectModule.sol\";\nimport {ModuleTypes} from \"lens-modules/contracts/modules/libraries/constants/ModuleTypes.sol\";\nimport {LensModule} from \"lens-modules/contracts/modules/LensModule.sol\";\nimport {Errors} from \"lens-modules/contracts/modules/constants/Errors.sol\";\n\ninterface IToken {\n    /**\n     * @dev Returns the amount of ERC20/ERC721 tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @notice A struct containing the recipient address and the fraction of the fee they should receive.\n *\n * @param recipient The address of the recipient.\n * @param split The fraction of the fee they should receive, as a fraction of BPS_MAX (10 000).\n */\nstruct RecipientData {\n    address recipient;\n    uint16 split; // fraction of BPS_MAX (10 000)\n}\n\n/**\n * @notice A struct containing the necessary data to execute TokenGated references.\n *\n * @param tokenAddress The address of ERC20/ERC721 token used for gating the collect.\n * @param minThreshold The minimum balance threshold of the gated token required to execute a collect.\n */\nstruct GateParams {\n    address tokenAddress;\n    uint256 minThreshold;\n}\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication. Cannot be 0.\n * @param collectLimit The maximum number of collects for this publication. 0 for no limit.\n * @param currency The currency associated with this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly True if only followers of publisher may collect the post.\n * @param endTimestamp The end timestamp after which collecting is impossible. 0 for no expiry.\n * @param recipients Array of RecipientData items to split collect fees across multiple recipients.\n * @param gateParams The GateParams struct containing the gating token address and minimum balance threshold.\n */\nstruct TokenGatedCollectPublicationData {\n    uint160 amount;\n    uint96 collectLimit;\n    address currency;\n    uint96 currentCollects;\n    uint16 referralFee;\n    bool followerOnly;\n    uint72 endTimestamp;\n    RecipientData[] recipients;\n    GateParams gateParams;\n}\n\nerror GateParamsInvalid();\nerror InvalidRecipientSplits();\nerror RecipientSplitCannotBeZero();\nerror NotEnoughBalance();\n\ncontract TokenGatedCollectModule is BaseFeeCollectModule, LensModuleMetadata {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant UINT256_BYTES = 32;\n\n    event TokenGatedCollectCreated(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        address tokenAddress,\n        uint256 minThreshold\n    );\n\n    event ModuleRegistered();\n\n    mapping(uint256 profileId => mapping(uint256 pubId => GateParams gateParams))\n        internal _gateParams;\n\n    mapping(uint256 profileId => mapping(uint256 pubId => RecipientData[]))\n        internal _recipients;\n\n    constructor(\n        address hub,\n        address actionModule,\n        address moduleRegistry,\n        address moduleOwner\n    )\n        Ownable()\n        BaseFeeCollectModule(hub, actionModule, moduleRegistry)\n        LensModuleMetadata()\n    {\n        _transferOwnership(moduleOwner);\n    }\n\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address /* transactionExecutor */,\n        bytes calldata data\n    ) external override onlyActionModule returns (bytes memory) {\n        (\n            uint160 amount,\n            uint96 collectLimit,\n            address currency,\n            uint16 referralFee,\n            bool followerOnly,\n            uint72 endTimestamp,\n            RecipientData[] memory recipients,\n            GateParams memory gateParams\n        ) = abi.decode(\n                data,\n                (\n                    uint160,\n                    uint96,\n                    address,\n                    uint16,\n                    bool,\n                    uint72,\n                    RecipientData[],\n                    GateParams\n                )\n            );\n\n        _validateGateParams(gateParams);\n        _gateParams[profileId][pubId] = gateParams;\n\n        BaseFeeCollectModuleInitData\n            memory baseInitData = BaseFeeCollectModuleInitData({\n                amount: amount,\n                collectLimit: collectLimit,\n                currency: currency,\n                referralFee: referralFee,\n                followerOnly: followerOnly,\n                endTimestamp: endTimestamp,\n                recipient: address(0)\n            });\n\n        // Zero amount for collect doesn't make sense if there are recipients\n        if (\n            recipients.length > 0 &&\n            (baseInitData.amount == 0 || currency == address(0))\n        ) {\n            revert Errors.InitParamsInvalid();\n        }\n\n        _validateBaseInitData(baseInitData);\n        _validateAndStoreRecipients(recipients, profileId, pubId);\n        _storeBasePublicationCollectParameters(profileId, pubId, baseInitData);\n\n        emit TokenGatedCollectCreated(\n            profileId,\n            pubId,\n            gateParams.tokenAddress,\n            gateParams.minThreshold\n        );\n\n        return data;\n    }\n\n    /**\n     * @inheritdoc ICollectModule\n     * @notice Processes a collect by:\n     *  1. Validating that collect action meets all needed criteria\n     *  2. Processing the collect action either with or without referral\n     *\n     * @param processCollectParams Collect action parameters (see ModuleTypes.ProcessCollectParams struct)\n     */\n    function processCollect(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) external override onlyActionModule returns (bytes memory) {\n        _validateTokenBalance(\n            processCollectParams.collectorProfileId,\n            processCollectParams.publicationCollectedProfileId,\n            processCollectParams.publicationCollectedId\n        );\n        _validateAndStoreCollect(processCollectParams);\n\n        if (processCollectParams.referrerProfileIds.length == 0) {\n            _processCollect(processCollectParams);\n        } else {\n            _processCollectWithReferral(processCollectParams);\n        }\n\n        return \"\";\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public pure override(BaseFeeCollectModule, LensModule) returns (bool) {\n        return\n            BaseFeeCollectModule.supportsInterface(interfaceID) ||\n            LensModule.supportsInterface(interfaceID);\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The TokenGatedCollectPublicationData struct mapped to that publication.\n     */\n    function getPublicationData(\n        uint256 profileId,\n        uint256 pubId\n    ) external view virtual returns (TokenGatedCollectPublicationData memory) {\n        BaseProfilePublicationData memory baseData = getBasePublicationData(\n            profileId,\n            pubId\n        );\n        return\n            TokenGatedCollectPublicationData({\n                amount: baseData.amount,\n                collectLimit: baseData.collectLimit,\n                currency: baseData.currency,\n                currentCollects: baseData.currentCollects,\n                referralFee: baseData.referralFee,\n                followerOnly: baseData.followerOnly,\n                endTimestamp: baseData.endTimestamp,\n                gateParams: _gateParams[profileId][pubId],\n                recipients: _recipients[profileId][pubId]\n            });\n    }\n\n    /**\n     * @dev Checks if the module is registered in the module registry\n     * @return True if the module is registered, false otherwise\n     */\n    function isRegistered() public view returns (bool) {\n        return MODULE_REGISTRY.isModuleRegistered(address(this));\n    }\n\n    /**\n     * @dev Registers the open action in the module registry\n     * @return True if the module was registered, false otherwise\n     */\n    function registerModule() external onlyOwner returns (bool) {\n        if (isRegistered()) {\n            return true;\n        }\n        bool registered = MODULE_REGISTRY.registerModule(\n            address(this),\n            uint256(IModuleRegistry.ModuleType.PUBLICATION_ACTION_MODULE)\n        );\n        if (registered) {\n            emit ModuleRegistered();\n        }\n        return registered;\n    }\n\n    /**\n     * @dev Validates the gate parameters passed during initialization.\n     *\n     * @param gateParams The GateParams struct containing the gating token address and minimum balance threshold.\n     */\n    function _validateGateParams(GateParams memory gateParams) internal view {\n        // Checking if the tokenAddress resembles ERC20/ERC721 token (by calling balanceOf() function).\n        (bool success, bytes memory result) = gateParams\n            .tokenAddress\n            .staticcall(\n                abi.encodeWithSelector(IToken.balanceOf.selector, address(this))\n            );\n        // We don't check if the contract exists because we expect the return data anyway.\n        if (\n            gateParams.minThreshold == 0 ||\n            !success ||\n            result.length != UINT256_BYTES\n        ) {\n            revert GateParamsInvalid();\n        }\n    }\n\n    /**\n     * @dev Validates the profile's owner balance of gating token. It can work with both ERC20 and ERC721 as both\n     * interfaces shares `balanceOf` function prototype.\n     *\n     * @param collectorProfileId The ID of the profile trying to collect.\n     * @param publicationCollectedProfileId The ID of the publication's author.\n     * @param publicationCollectedId The ID of the publication.\n     *\n     * @return uint256 The gate token balance of the profile trying to collect.\n     */\n    function _validateTokenBalance(\n        uint256 collectorProfileId,\n        uint256 publicationCollectedProfileId,\n        uint256 publicationCollectedId\n    ) internal view returns (uint256) {\n        GateParams memory gateParams = _gateParams[\n            publicationCollectedProfileId\n        ][publicationCollectedId];\n        uint256 balance = IToken(gateParams.tokenAddress).balanceOf(\n            IERC721(HUB).ownerOf(collectorProfileId)\n        );\n        if (\n            collectorProfileId != publicationCollectedProfileId &&\n            balance < gateParams.minThreshold\n        ) {\n            revert NotEnoughBalance();\n        }\n        return balance;\n    }\n\n    /**\n     * @dev Validates the recipients array and stores them to (a separate from Base) storage.\n     *\n     * @param recipients An array of recipients\n     * @param profileId The profile ID who is publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     */\n    function _validateAndStoreRecipients(\n        RecipientData[] memory recipients,\n        uint256 profileId,\n        uint256 pubId\n    ) internal {\n        uint256 len = recipients.length;\n\n        if (len == 0) {\n            return;\n        }\n\n        // Check recipient splits sum to 10 000 BPS (100%)\n        uint256 totalSplits;\n        uint256 i;\n        while (i < len) {\n            if (recipients[i].split == 0) revert RecipientSplitCannotBeZero();\n            totalSplits += recipients[i].split;\n\n            // Store each recipient while looping - avoids extra gas costs in successful cases\n            _recipients[profileId][pubId].push(recipients[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (totalSplits != BPS_MAX) {\n            revert InvalidRecipientSplits();\n        }\n    }\n\n    /**\n     * @dev Transfers the fee to multiple recipients.\n     *\n     * @inheritdoc BaseFeeCollectModule\n     */\n    function _transferToRecipients(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams,\n        address currency,\n        uint256 amount\n    ) internal override {\n        RecipientData[] memory recipients = _recipients[\n            processCollectParams.publicationCollectedProfileId\n        ][processCollectParams.publicationCollectedId];\n        uint256 len = recipients.length;\n\n        uint256 i;\n        while (i < len) {\n            uint256 amountForRecipient = (amount * recipients[i].split) /\n                BPS_MAX;\n            if (amountForRecipient != 0)\n                IERC20(currency).safeTransferFrom(\n                    processCollectParams.transactionExecutor,\n                    recipients[i].recipient,\n                    amountForRecipient\n                );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal processing of a collect:\n     *  1. Calculation of fees\n     *  2. Validation that fees are what collector expected\n     *  3. Transfer of fees to recipient(-s) and treasury\n     *\n     * @param processCollectParams Parameters of the collect\n     */\n    function _processCollect(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) internal virtual override {\n        uint256 amount = calculateFee(processCollectParams);\n        if (amount == 0) {\n            return;\n        }\n\n        address currency = _dataByPublicationByProfile[\n            processCollectParams.publicationCollectedProfileId\n        ][processCollectParams.publicationCollectedId].currency;\n        _validateDataIsExpected(processCollectParams.data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n\n        if (treasuryAmount > 0) {\n            IERC20(currency).safeTransferFrom(\n                processCollectParams.transactionExecutor,\n                treasury,\n                treasuryAmount\n            );\n        }\n\n        // Send amount after treasury cut, to all recipients\n        _transferToRecipients(\n            processCollectParams,\n            currency,\n            amount - treasuryAmount\n        );\n    }\n\n    /**\n     * @dev Internal processing of a collect with a referrals (if any).\n     *\n     * Same as _processCollect, but also includes transfer to referrals (if any):\n     *  1. Calculation of fees\n     *  2. Validation that fees are what collector expected\n     *  3. Transfer of fees to treasury, referrals (if any) and recipients\n     *\n     * @param processCollectParams Parameters of the collect\n     */\n    function _processCollectWithReferral(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) internal virtual override {\n        uint256 amount = calculateFee(processCollectParams);\n        if (amount == 0) {\n            return;\n        }\n\n        address currency = _dataByPublicationByProfile[\n            processCollectParams.publicationCollectedProfileId\n        ][processCollectParams.publicationCollectedId].currency;\n\n        _validateDataIsExpected(processCollectParams.data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n\n        if (treasuryAmount > 0) {\n            IERC20(currency).safeTransferFrom(\n                processCollectParams.transactionExecutor,\n                treasury,\n                treasuryAmount\n            );\n        }\n\n        uint256 amountAfterReferrals = _transferToReferrals(\n            processCollectParams,\n            currency,\n            amount - treasuryAmount\n        );\n\n        _transferToRecipients(\n            processCollectParams,\n            currency,\n            amountAfterReferrals\n        );\n    }\n}\n"
    },
    "lens-modules/contracts/base/ERC2981CollectionRoyalties.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {IERC2981} from '@openzeppelin/contracts/interfaces/IERC2981.sol';\n\nabstract contract ERC2981CollectionRoyalties is IERC2981 {\n    uint16 internal constant BASIS_POINTS = 10000;\n    // bytes4(keccak256('royaltyInfo(uint256,uint256)')) == 0x2a55205a\n    bytes4 internal constant INTERFACE_ID_ERC2981 = 0x2a55205a;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == INTERFACE_ID_ERC2981 || interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @notice Changes the royalty percentage for secondary sales.\n     *\n     * @param royaltiesInBasisPoints The royalty percentage (measured in basis points).\n     */\n    function setRoyalty(uint256 royaltiesInBasisPoints) external {\n        _beforeRoyaltiesSet(royaltiesInBasisPoints);\n        _setRoyalty(royaltiesInBasisPoints);\n    }\n\n    /**\n     * @notice Called with the sale price to determine how much royalty is owed and to whom.\n     *\n     * @param tokenId The ID of the token queried for royalty information.\n     * @param salePrice The sale price of the token specified.\n     * @return A tuple with the address that should receive the royalties and the royalty\n     * payment amount for the given sale price.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {\n        return (_getReceiver(tokenId), _getRoyaltyAmount(tokenId, salePrice));\n    }\n\n    function _setRoyalty(uint256 royaltiesInBasisPoints) internal virtual {\n        if (royaltiesInBasisPoints > BASIS_POINTS) {\n            revert Errors.InvalidParameter();\n        }\n        _storeRoyaltiesInBasisPoints(royaltiesInBasisPoints);\n    }\n\n    function _getRoyaltyAmount(uint256 /* tokenId */, uint256 salePrice) internal view virtual returns (uint256) {\n        return (salePrice * _loadRoyaltiesInBasisPoints()) / BASIS_POINTS;\n    }\n\n    function _storeRoyaltiesInBasisPoints(uint256 royaltiesInBasisPoints) internal virtual {\n        uint256 royaltiesInBasisPointsSlot = _getRoyaltiesInBasisPointsSlot();\n        assembly {\n            sstore(royaltiesInBasisPointsSlot, royaltiesInBasisPoints)\n        }\n    }\n\n    function _loadRoyaltiesInBasisPoints() internal view virtual returns (uint256) {\n        uint256 royaltiesInBasisPointsSlot = _getRoyaltiesInBasisPointsSlot();\n        uint256 royaltyAmount;\n        assembly {\n            royaltyAmount := sload(royaltiesInBasisPointsSlot)\n        }\n        return royaltyAmount;\n    }\n\n    function _beforeRoyaltiesSet(uint256 royaltiesInBasisPoints) internal view virtual;\n\n    function _getRoyaltiesInBasisPointsSlot() internal view virtual returns (uint256);\n\n    function _getReceiver(uint256 tokenId) internal view virtual returns (address);\n}\n"
    },
    "lens-modules/contracts/base/HubRestricted.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Errors} from '../libraries/constants/Errors.sol';\n\n/**\n * @title HubRestricted\n * @author Lens Protocol\n *\n * @notice This abstract contract adds a public `HUB` immutable field, as well as an `onlyHub` modifier,\n * to inherit from contracts that have functions restricted to be only called by the Lens hub.\n */\nabstract contract HubRestricted {\n    address public immutable HUB;\n\n    modifier onlyHub() {\n        if (msg.sender != HUB) {\n            revert Errors.NotHub();\n        }\n        _;\n    }\n\n    constructor(address hub) {\n        HUB = hub;\n    }\n}\n"
    },
    "lens-modules/contracts/base/LensBaseERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {MetaTxLib} from '../libraries/MetaTxLib.sol';\nimport {ILensERC721} from '../interfaces/ILensERC721.sol';\nimport {IERC721Timestamped} from '../interfaces/IERC721Timestamped.sol';\nimport {IERC721Burnable} from '../interfaces/IERC721Burnable.sol';\nimport {IERC721MetaTx} from '../interfaces/IERC721MetaTx.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {ERC165} from '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\n * Modifications:\n * 1. Refactored _operatorApprovals setter into an internal function to allow meta-transactions.\n * 2. Constructor replaced with an initializer.\n * 3. Mint timestamp is now stored in a TokenData struct alongside the owner address.\n */\nabstract contract LensBaseERC721 is ERC165, ILensERC721 {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to token Data (owner address and mint timestamp uint96), this\n    // replaces the original mapping(uint256 => address) private _owners;\n    mapping(uint256 => Types.TokenData) private _tokenData;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Deprecated in V2 after removing ERC712Enumerable logic.\n    mapping(address => mapping(uint256 => uint256)) private __DEPRECATED__ownedTokens;\n    mapping(uint256 => uint256) private __DEPRECATED__ownedTokensIndex;\n\n    // Dirty hack on a deprecated slot:\n    uint256 private _totalSupply; // uint256[] private __DEPRECATED__allTokens;\n\n    // Deprecated in V2 after removing ERC712Enumerable logic.\n    mapping(uint256 => uint256) private __DEPRECATED__allTokensIndex;\n\n    mapping(address => uint256) private _nonces;\n\n    /**\n     * @dev Initializes the ERC721 name and symbol.\n     *\n     * @param name_ The name to set.\n     * @param symbol_ The symbol to set.\n     */\n    function _initialize(string calldata name_, string calldata symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view virtual returns (string memory);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Timestamped).interfaceId ||\n            interfaceId == type(IERC721Burnable).interfaceId ||\n            interfaceId == type(IERC721MetaTx).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function nonces(address signer) public view override returns (uint256) {\n        return _nonces[signer];\n    }\n\n    /// @inheritdoc IERC721MetaTx\n    function getDomainSeparator() external view virtual override returns (bytes32) {\n        return MetaTxLib.calculateDomainSeparator();\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _tokenData[tokenId].owner;\n        if (owner == address(0)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Timestamped-mintTimestampOf}\n     */\n    function mintTimestampOf(uint256 tokenId) public view virtual override returns (uint256) {\n        uint96 mintTimestamp = _tokenData[tokenId].mintTimestamp;\n        if (mintTimestamp == 0) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return mintTimestamp;\n    }\n\n    /**\n     * @dev See {IERC721Timestamped-tokenDataOf}\n     */\n    function tokenDataOf(uint256 tokenId) public view virtual override returns (Types.TokenData memory) {\n        if (!_exists(tokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return _tokenData[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Timestamped-exists}\n     */\n    function exists(uint256 tokenId) public view virtual override returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        if (to == owner) {\n            revert Errors.InvalidParameter();\n        }\n\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n            revert Errors.NotOwnerOrApproved();\n        }\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == msg.sender) {\n            revert Errors.InvalidParameter();\n        }\n\n        _setOperatorApproval(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n            revert Errors.NotOwnerOrApproved();\n        }\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n            revert Errors.NotOwnerOrApproved();\n        }\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Burns `tokenId`.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual override {\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n            revert Errors.NotOwnerOrApproved();\n        }\n        _burn(tokenId);\n    }\n\n    /**\n     * @notice Returns the owner of the `tokenId` token.\n     *\n     * @dev It is prefixed as `unsafe` as it does not revert when the token does not exist.\n     *\n     * @param tokenId The token whose owner is being queried.\n     *\n     * @return address The address owning the given token, zero address if the token does not exist.\n     */\n    function _unsafeOwnerOf(uint256 tokenId) internal view returns (address) {\n        return _tokenData[tokenId].owner;\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform a token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\n            revert Errors.NonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenData[tokenId].owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ownerOf(tokenId);\n        // We don't check owner for != address(0) cause it's done inside ownerOf()\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0) || _exists(tokenId)) {\n            revert Errors.InvalidParameter();\n        }\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        unchecked {\n            ++_balances[to];\n            ++_totalSupply;\n        }\n        _tokenData[tokenId].owner = to;\n        _tokenData[tokenId].mintTimestamp = uint96(block.timestamp);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        unchecked {\n            --_balances[owner];\n            --_totalSupply;\n        }\n        delete _tokenData[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        if (ownerOf(tokenId) != from) {\n            revert Errors.InvalidOwner();\n        }\n        if (to == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        unchecked {\n            --_balances[from];\n            ++_balances[to];\n        }\n        _tokenData[tokenId].owner = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Refactored from the original OZ ERC721 implementation: approve or revoke approval from\n     * `operator` to operate on all tokens owned by `owner`.\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setOperatorApproval(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert Errors.NonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "lens-modules/contracts/base/LensGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensGovernable} from '../interfaces/ILensGovernable.sol';\nimport {GovernanceLib} from '../libraries/GovernanceLib.sol';\nimport {ValidationLib} from '../libraries/ValidationLib.sol';\nimport {StorageLib} from '../libraries/StorageLib.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {Events} from '../libraries/constants/Events.sol';\n\nabstract contract LensGovernable is ILensGovernable {\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        ValidationLib.validateCallerIsGovernance();\n        _;\n    }\n\n    /////////////////////////////////\n    ///        GOV FUNCTIONS      ///\n    /////////////////////////////////\n\n    /// @inheritdoc ILensGovernable\n    function setGovernance(address newGovernance) external override onlyGov {\n        GovernanceLib.setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensGovernable\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        GovernanceLib.setEmergencyAdmin(newEmergencyAdmin);\n    }\n\n    /// @inheritdoc ILensGovernable\n    function setState(Types.ProtocolState newState) external override {\n        // Access control is handled inside the library because we need to check for both EmergencyAdmin and Governance.\n        GovernanceLib.setState(newState);\n    }\n\n    /// @inheritdoc ILensGovernable\n    function setTreasury(address newTreasury) external override onlyGov {\n        GovernanceLib.setTreasury(newTreasury);\n    }\n\n    /// @inheritdoc ILensGovernable\n    function setTreasuryFee(uint16 newTreasuryFee) external override onlyGov {\n        GovernanceLib.setTreasuryFee(newTreasuryFee);\n    }\n\n    ///@inheritdoc ILensGovernable\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external override onlyGov {\n        GovernanceLib.whitelistProfileCreator(profileCreator, whitelist);\n    }\n\n    function setProfileTokenURIContract(address profileTokenURIContract) external override onlyGov {\n        GovernanceLib.setProfileTokenURIContract(profileTokenURIContract);\n        emit Events.BatchMetadataUpdate({fromTokenId: 0, toTokenId: type(uint256).max});\n    }\n\n    function setFollowTokenURIContract(address followTokenURIContract) external override onlyGov {\n        GovernanceLib.setFollowTokenURIContract(followTokenURIContract);\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensGovernable\n    function getGovernance() external view override returns (address) {\n        return StorageLib.getGovernance();\n    }\n\n    function getProfileTokenURIContract() external view override returns (address) {\n        return StorageLib.getProfileTokenURIContract();\n    }\n\n    function getFollowTokenURIContract() external view override returns (address) {\n        return StorageLib.getFollowTokenURIContract();\n    }\n\n    /**\n     * @notice Returns the current protocol state.\n     *\n     * @return ProtocolState The Protocol state, an enum, where:\n     *      0: Unpaused\n     *      1: PublishingPaused\n     *      2: Paused\n     */\n    function getState() external view override returns (Types.ProtocolState) {\n        return StorageLib.getState();\n    }\n\n    /// @inheritdoc ILensGovernable\n    function isProfileCreatorWhitelisted(address profileCreator) external view override returns (bool) {\n        return StorageLib.profileCreatorWhitelisted()[profileCreator];\n    }\n\n    /// @inheritdoc ILensGovernable\n    function getTreasury() external view override returns (address) {\n        return StorageLib.getTreasuryData().treasury;\n    }\n\n    /// @inheritdoc ILensGovernable\n    function getTreasuryFee() external view override returns (uint16) {\n        return StorageLib.getTreasuryData().treasuryFeeBPS;\n    }\n\n    /// @inheritdoc ILensGovernable\n    function getTreasuryData() external view override returns (address, uint16) {\n        Types.TreasuryData storage treasuryData = StorageLib.getTreasuryData();\n        return (treasuryData.treasury, treasuryData.treasuryFeeBPS);\n    }\n}\n"
    },
    "lens-modules/contracts/base/LensHubEventHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensHubEventHooks} from '../interfaces/ILensHubEventHooks.sol';\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {StorageLib} from '../libraries/StorageLib.sol';\nimport {Events} from '../libraries/constants/Events.sol';\n\nabstract contract LensHubEventHooks is ILensHubEventHooks {\n    /// @inheritdoc ILensHubEventHooks\n    function emitUnfollowedEvent(\n        uint256 unfollowerProfileId,\n        uint256 idOfProfileUnfollowed,\n        address transactionExecutor\n    ) external override {\n        address expectedFollowNFT = StorageLib.getProfile(idOfProfileUnfollowed).followNFT;\n        if (msg.sender != expectedFollowNFT) {\n            revert Errors.CallerNotFollowNFT();\n        }\n        emit Events.Unfollowed(unfollowerProfileId, idOfProfileUnfollowed, transactionExecutor, block.timestamp);\n    }\n\n    //////////////////////////////////////\n    ///       DEPRECATED FUNCTIONS     ///\n    //////////////////////////////////////\n\n    // Deprecated in V2. Kept here just for backwards compatibility with Lens V1 Collect NFTs.\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external {\n        address expectedCollectNFT = StorageLib.getPublication(profileId, pubId).__DEPRECATED__collectNFT;\n        if (msg.sender != expectedCollectNFT) {\n            revert Errors.CallerNotCollectNFT();\n        }\n        emit Events.CollectNFTTransferred(profileId, pubId, collectNFTId, from, to, block.timestamp);\n    }\n}\n"
    },
    "lens-modules/contracts/base/LensHubStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title LensHubStorage\n * @author Lens Protocol\n *\n * @notice This is an abstract contract that ONLY contains storage for the LensHub contract. This MUST be inherited last\n * to preserve the LensHub storage layout. Adding storage variables should be done ONLY at the bottom of this contract.\n */\nabstract contract LensHubStorage {\n    // For upgradeability purposes, used at `VersionedInitializable` file, which needs to be included if the LensHub\n    // has an initializer function.\n    uint256 private _lastInitializedRevision; // Slot 11.\n\n    Types.ProtocolState internal _state; // Slot 12\n\n    mapping(address profileCreator => bool isWhitelisted) internal _profileCreatorWhitelisted; // Slot 13\n\n    mapping(address => bool isWhitelisted) internal __DEPRECATED__followModuleWhitelisted; // Slot 14\n\n    mapping(address collectModule => bool isWhitelisted) internal __DEPRECATED__collectModuleWhitelisted; // Slot 15\n\n    mapping(address referenceModule => bool isWhitelisted) internal __DEPRECATED__referenceModuleWhitelisted; // Slot 16\n\n    mapping(uint256 profileId => address dispatcher) internal __DEPRECATED__dispatcherByProfile; // Slot 17\n\n    mapping(bytes32 handleHash => uint256 profileId) internal __DEPRECATED__profileIdByHandleHash; // Slot 18\n\n    mapping(uint256 profileId => Types.Profile profile) internal _profiles; // Slot 19\n\n    mapping(uint256 profileId => mapping(uint256 pubId => Types.Publication publication)) internal _publications; // Slot 20\n\n    mapping(address userAddress => uint256 profileId) internal __DEPRECATED__defaultProfiles; // Slot 21\n\n    uint256 internal _profileCounter; // Slot 22 - different from totalSupply, as this is not decreased when burning profiles\n\n    address internal _governance; // Slot 23\n\n    address internal _emergencyAdmin; // Slot 24\n\n    ////////////////////////////////////////////\n    // Slots introduced by Lens V1.3 upgrade. //\n    ////////////////////////////////////////////\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp; // Slot 25\n\n    ////////////////////////////////////////////\n    //  Slots introduced by Lens V2 upgrade.  //\n    ////////////////////////////////////////////\n\n    mapping(uint256 profileId => Types.DelegatedExecutorsConfig config) internal _delegatedExecutorsConfigs; // Slot 26\n\n    mapping(uint256 blockerProfileId => mapping(uint256 blockedProfileId => bool isBlocked)) internal _blockedStatus; // Slot 27\n\n    uint256 internal _profileRoyaltiesBps; // Slot 28\n\n    mapping(address migrationAdmin => bool allowed) internal _migrationAdminWhitelisted; // Slot 29\n\n    Types.TreasuryData internal _treasuryData; // Slot 30\n\n    address internal _profileTokenURIContract; // Slot 31\n\n    address internal _followTokenURIContract; // Slot 32\n\n    mapping(address => uint256) internal _legacyCollectFollowValidationHelper; // Slot 33\n}\n"
    },
    "lens-modules/contracts/base/LensImplGetters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensImplGetters} from '../interfaces/ILensImplGetters.sol';\n\ncontract LensImplGetters is ILensImplGetters {\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable __LEGACY__COLLECT_NFT_IMPL;\n    address internal immutable MODULE_REGISTRY;\n\n    constructor(address followNFTImpl, address collectNFTImpl, address moduleRegistry) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        __LEGACY__COLLECT_NFT_IMPL = collectNFTImpl;\n        MODULE_REGISTRY = moduleRegistry;\n    }\n\n    /// @inheritdoc ILensImplGetters\n    function getFollowNFTImpl() external view override returns (address) {\n        return FOLLOW_NFT_IMPL;\n    }\n\n    /// @inheritdoc ILensImplGetters\n    function getLegacyCollectNFTImpl() external view override returns (address) {\n        return __LEGACY__COLLECT_NFT_IMPL; // LEGACY support: Used only for compatibility with V1 collectible posts.\n    }\n\n    /// @inheritdoc ILensImplGetters\n    function getModuleRegistry() external view override returns (address) {\n        return MODULE_REGISTRY;\n    }\n}\n"
    },
    "lens-modules/contracts/base/LensProfiles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {ILensProfiles} from '../interfaces/ILensProfiles.sol';\nimport {IERC721Burnable} from '../interfaces/IERC721Burnable.sol';\n\nimport {LensBaseERC721} from './LensBaseERC721.sol';\nimport {ProfileLib} from '../libraries/ProfileLib.sol';\nimport {StorageLib} from '../libraries/StorageLib.sol';\nimport {ValidationLib} from '../libraries/ValidationLib.sol';\nimport {IProfileTokenURI} from '../interfaces/IProfileTokenURI.sol';\n\nimport {ERC2981CollectionRoyalties} from './ERC2981CollectionRoyalties.sol';\n\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {Events} from '../libraries/constants/Events.sol';\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\nabstract contract LensProfiles is LensBaseERC721, ERC2981CollectionRoyalties, ILensProfiles {\n    using Address for address;\n\n    uint256 public immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    constructor(uint256 tokenGuardianCooldown) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    modifier whenNotPaused() {\n        if (StorageLib.getState() == Types.ProtocolState.Paused) {\n            revert Errors.Paused();\n        }\n        _;\n    }\n\n    modifier onlyProfileOwner(address expectedOwner, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwner(expectedOwner, profileId);\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert Errors.NotEOA();\n        }\n        _;\n    }\n\n    /// @inheritdoc ILensProfiles\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return StorageLib.tokenGuardianDisablingTimestamp()[wallet];\n    }\n\n    /// @inheritdoc ILensProfiles\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] != 0) {\n            revert Errors.DisablingAlreadyTriggered();\n        }\n        StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit Events.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    /// @inheritdoc ILensProfiles\n    function enableTokenGuardian() external onlyEOA {\n        if (StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] == 0) {\n            revert Errors.AlreadyEnabled();\n        }\n        StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] = 0;\n        emit Events.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct.\n     */\n    function burn(\n        uint256 tokenId\n    ) public override(LensBaseERC721, IERC721Burnable) whenNotPaused onlyProfileOwner(msg.sender, tokenId) {\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override(LensBaseERC721, IERC721Metadata) returns (string memory) {\n        if (!_exists(tokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        uint256 mintTimestamp = StorageLib.getTokenData(tokenId).mintTimestamp;\n        return IProfileTokenURI(StorageLib.getProfileTokenURIContract()).getTokenURI(tokenId, mintTimestamp);\n    }\n\n    function approve(address to, uint256 tokenId) public override(LensBaseERC721, IERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(ownerOf(tokenId))) {\n            revert Errors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(LensBaseERC721, IERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert Errors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(LensBaseERC721, ERC2981CollectionRoyalties, IERC165) returns (bool) {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function transferFromKeepingDelegates(address from, address to, uint256 tokenId) external {\n        //solhint-disable-next-line max-line-length\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n            revert Errors.NotOwnerOrApproved();\n        }\n\n        if (!StorageLib.profileCreatorWhitelisted()[msg.sender]) {\n            // Delegates can be maintained on transfers only when executed by whitelisted profile creators, which are\n            // trusted entities, for the sake of a better onboarding UX.\n            revert Errors.NotAllowed();\n        }\n\n        if (ownerOf(tokenId) != from) {\n            revert Errors.InvalidOwner();\n        }\n\n        if (to == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n\n        _beforeTokenTransferWithoutClearingDelegates(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        unchecked {\n            --StorageLib.balances()[from];\n            ++StorageLib.balances()[to];\n        }\n\n        StorageLib.getTokenData(tokenId).owner = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n        (StorageLib.tokenGuardianDisablingTimestamp()[wallet] == 0 ||\n            block.timestamp < StorageLib.tokenGuardianDisablingTimestamp()[wallet]);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        return StorageLib.PROFILE_ROYALTIES_BPS_SLOT;\n    }\n\n    function _getReceiver(uint256 /* tokenId */) internal view override returns (address) {\n        return StorageLib.getTreasuryData().treasury;\n    }\n\n    function _beforeRoyaltiesSet(uint256 /* royaltiesInBasisPoints */) internal view override {\n        ValidationLib.validateCallerIsGovernance();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override whenNotPaused {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer profile if the guardian is enabled, except at minting time.\n            revert Errors.GuardianEnabled();\n        }\n        // Switches to new fresh delegated executors configuration (except on minting, as it already has a fresh setup).\n        if (from != address(0)) {\n            ProfileLib.switchToNewFreshDelegatedExecutorsConfig(tokenId);\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _beforeTokenTransferWithoutClearingDelegates(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal whenNotPaused {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer profile if the guardian is enabled, except at minting time.\n            revert Errors.GuardianEnabled();\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}"
    },
    "lens-modules/contracts/base/upgradeability/FollowNFTProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensHub} from '../../interfaces/ILensHub.sol';\nimport {Proxy} from '@openzeppelin/contracts/proxy/Proxy.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\ncontract FollowNFTProxy is Proxy {\n    using Address for address;\n    address immutable HUB;\n\n    constructor(bytes memory data) {\n        HUB = msg.sender;\n        ILensHub(msg.sender).getFollowNFTImpl().functionDelegateCall(data);\n    }\n\n    function _implementation() internal view override returns (address) {\n        return ILensHub(HUB).getFollowNFTImpl();\n    }\n}\n"
    },
    "lens-modules/contracts/base/upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from '../../libraries/constants/Errors.sol';\nimport {StorageLib} from '../../libraries/StorageLib.sol';\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * This is slightly modified from [Aave's version.](https://github.com/aave/protocol-v2/blob/6a503eb0a897124d8b9d126c915ffdf3e88343a9/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol)\n *\n * @author Lens Protocol, inspired by Aave's implementation, which is in turn inspired by OpenZeppelin's\n * Initializable contract\n */\nabstract contract VersionedInitializable {\n    address private immutable originalImpl;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        if (address(this) == originalImpl) {\n            revert Errors.CannotInitImplementation();\n        }\n        if (getRevision() <= StorageLib.getLastInitializedRevision()) {\n            revert Errors.Initialized();\n        }\n        StorageLib.setLastInitializedRevision(getRevision());\n        _;\n    }\n\n    constructor() {\n        originalImpl = address(this);\n    }\n\n    /**\n     * @dev returns the revision number of the contract\n     * Needs to be defined in the inherited class as a constant.\n     **/\n    function getRevision() internal pure virtual returns (uint256);\n}\n"
    },
    "lens-modules/contracts/FollowNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from './libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from './base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from './libraries/constants/Errors.sol';\nimport {HubRestricted} from './base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from './interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from './interfaces/IFollowNFT.sol';\nimport {ILensHub} from './interfaces/ILensHub.sol';\nimport {LensBaseERC721} from './base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from './libraries/StorageLib.sol';\nimport {Types} from './libraries/constants/Types.sol';\nimport {IFollowTokenURI} from './interfaces/IFollowTokenURI.sol';\n\n/**\n * @custom:upgradeable Beacon proxy. The beacon, responsible for returning the implementation address, is the LensHub.\n */\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    modifier whenNotPaused() {\n        if (ILensHub(HUB).getState() == Types.ProtocolState.Paused) {\n            revert Errors.Paused();\n        }\n        _;\n    }\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId,\n                    transactionExecutor: transactionExecutor\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        // LensHub already validated that this action can only be performed by the unfollower profile's owner or one of\n        // his approved delegated executors.\n        _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        if (followTokenOwner == address(0)) {\n            // Follow token was unwrapped, allowing recovery.\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override whenNotPaused {\n        if (_isApprovedOrOwner(msg.sender, followTokenId)) {\n            _unfollowIfHasFollower(followTokenId, msg.sender);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        // `followTokenId` allowed to be zero as a way to clear the approval.\n        if (followTokenId != 0 && _unsafeOwnerOf(followTokenId) == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (_isApprovedOrOwner(msg.sender, followTokenId)) {\n            _approveFollow(followerProfileId, followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override whenNotPaused {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override whenNotPaused {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override whenNotPaused {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override whenNotPaused {\n        _unfollowIfHasFollower(followTokenId, msg.sender);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(LensBaseERC721, ERC2981CollectionRoyalties) returns (bool) {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\n        if (!_exists(followTokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return\n            IFollowTokenURI(ILensHub(HUB).getFollowTokenURIContract()).getTokenURI(\n                followTokenId,\n                _followedProfileId,\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\n            );\n    }\n\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\n        uint256 followTokenIdAssigned;\n        unchecked {\n            followTokenIdAssigned = ++_lastFollowTokenId;\n            _followerCount++;\n        }\n        _baseFollow({\n            followerProfileId: followerProfileId,\n            followTokenId: followTokenIdAssigned,\n            isOriginalFollow: true\n        });\n        return followTokenIdAssigned;\n    }\n\n    function _followWithWrappedToken(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) internal returns (uint256) {\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (\n            !isFollowApproved &&\n            !_isApprovedOrOwner(followerProfileOwner, followTokenId) &&\n            !_isApprovedOrOwner(transactionExecutor, followTokenId)\n        ) {\n            revert DoesNotHavePermissions();\n        }\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\n        if (isFollowApproved) {\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\n            _approveFollow(0, followTokenId);\n        }\n        _replaceFollower({\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId,\n            transactionExecutor: transactionExecutor\n        });\n        return followTokenId;\n    }\n\n    function _followWithUnwrappedTokenFromBurnedProfile(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        uint256 currentFollowerProfileId,\n        address transactionExecutor\n    ) internal returns (uint256) {\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\n            revert DoesNotHavePermissions();\n        }\n        _replaceFollower({\n            currentFollowerProfileId: currentFollowerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId,\n            transactionExecutor: transactionExecutor\n        });\n        return followTokenId;\n    }\n\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\n            revert FollowTokenDoesNotExist();\n        }\n        unchecked {\n            _followerCount++;\n        }\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n        return followTokenId;\n    }\n\n    function _replaceFollower(\n        uint256 currentFollowerProfileId,\n        uint256 newFollowerProfileId,\n        uint256 followTokenId,\n        address transactionExecutor\n    ) internal {\n        if (currentFollowerProfileId != 0) {\n            // As it has a follower, unfollow first, removing the current follower.\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId, transactionExecutor);\n        } else {\n            unchecked {\n                _followerCount++;\n            }\n        }\n        // Perform the follow, setting a new follower.\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n    }\n\n    function _baseFollow(uint256 followerProfileId, uint256 followTokenId, bool isOriginalFollow) internal {\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        if (isOriginalFollow) {\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\n        } else {\n            // Migration code.\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\n            // In that case, we need to fetch the mint timestamp from the token data.\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n            }\n        }\n    }\n\n    function _unfollowIfHasFollower(uint256 followTokenId, address transactionExecutor) internal {\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId != 0) {\n            _unfollow(followerProfileId, followTokenId);\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId, transactionExecutor);\n        }\n    }\n\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\n        unchecked {\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\n            _followerCount--;\n        }\n        delete _followTokenIdByFollowerProfileId[unfollower];\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\n        emit FollowApproval(approvedProfileId, followTokenId);\n    }\n\n    /**\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 followTokenId) internal override whenNotPaused {\n        if (from != address(0)) {\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\n            // As a consequence, there is no need to clear it on wrappings.\n            _approveFollow(0, followTokenId);\n        }\n        super._beforeTokenTransfer(from, to, followTokenId);\n    }\n\n    function _getReceiver(uint256 /* followTokenId */) internal view override returns (address) {\n        if (!ILensHub(HUB).exists(_followedProfileId)) {\n            return address(0);\n        }\n        return IERC721(HUB).ownerOf(_followedProfileId);\n    }\n\n    function _beforeRoyaltiesSet(uint256 /* royaltiesInBasisPoints */) internal view override {\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\n        return _exists(followTokenId);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n\n    //////////////////\n    /// Migrations ///\n    //////////////////\n\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\n    function tryMigrate(\n        uint256 followerProfileId,\n        address followerProfileOwner,\n        uint256 followTokenId\n    ) external onlyHub returns (uint48) {\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n            return 0; // Already migrated\n        }\n\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            return 0; // Already following\n        }\n\n        Types.TokenData memory tokenData = StorageLib.getTokenData(followTokenId);\n\n        address followTokenOwner = tokenData.owner;\n\n        if (followTokenOwner == address(0)) {\n            return 0; // Doesn't exist\n        }\n\n        // ProfileNFT and FollowNFT should be in the same account\n        if (followerProfileOwner != followTokenOwner) {\n            return 0; // Not holding both Profile & Follow NFTs together\n        }\n\n        unchecked {\n            ++_followerCount;\n        }\n\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(tokenData.mintTimestamp);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(tokenData.mintTimestamp);\n\n        super._burn(followTokenId);\n        return uint48(tokenData.mintTimestamp);\n    }\n}\n"
    },
    "lens-modules/contracts/interfaces/ICollectNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ICollectNFT\n * @author Lens Protocol\n *\n * @notice This is the interface for the CollectNFT contract. Which is cloned upon the first collect for any given\n * publication.\n */\ninterface ICollectNFT {\n    /**\n     * @notice Initializes the collect NFT, setting the feed as the privileged minter, storing the collected publication pointer\n     * and initializing the name and symbol in the LensNFTBase contract.\n     * @custom:permissions CollectPublicationAction.\n     *\n     * @param profileId The token ID of the profile in the hub that this Collect NFT points to.\n     * @param pubId The profile publication ID in the hub that this Collect NFT points to.\n     */\n    function initialize(uint256 profileId, uint256 pubId) external;\n\n    /**\n     * @notice Mints a collect NFT to the specified address. This can only be called by the hub and is called\n     * upon collection.\n     * @custom:permissions CollectPublicationAction.\n     *\n     * @param to The address to mint the NFT to.\n     *\n     * @return uint256 An integer representing the minted token ID.\n     */\n    function mint(address to) external returns (uint256);\n\n    /**\n     * @notice Returns the source publication of this collect NFT.\n     *\n     * @return tuple First is the profile ID, and second is the publication ID.\n     */\n    function getSourcePublicationPointer() external view returns (uint256, uint256);\n}\n"
    },
    "lens-modules/contracts/interfaces/IERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title IERC721Burnable\n * @author Lens Protocol\n *\n * @notice Extension of ERC-721 including a function that allows the token to be burned.\n */\ninterface IERC721Burnable {\n    /**\n     * @notice Burns an NFT, removing it from circulation and essentially destroying it.\n     * @custom:permission Owner of the NFT.\n     *\n     * @param tokenId The token ID of the token to burn.\n     */\n    function burn(uint256 tokenId) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/IERC721MetaTx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title IERC721MetaTx\n * @author Lens Protocol\n *\n * @notice Extension of ERC-721 including meta-tx signatures related functions.\n */\ninterface IERC721MetaTx {\n    /**\n     * @notice Returns the current signature nonce of the given signer.\n     *\n     * @param signer The address for which to query the nonce.\n     *\n     * @return uint256 The current nonce of the given signer.\n     */\n    function nonces(address signer) external view returns (uint256);\n\n    /**\n     * @notice Returns the EIP-712 domain separator for this contract.\n     *\n     * @return bytes32 The domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n}\n"
    },
    "lens-modules/contracts/interfaces/IERC721Timestamped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title IERC721Timestamped\n * @author Lens Protocol\n *\n * @notice Extension of ERC-721 including a struct for token data, which contains the owner and the mint timestamp, as\n * well as their associated getters.\n */\ninterface IERC721Timestamped {\n    /**\n     * @notice Returns the mint timestamp associated with a given NFT.\n     *\n     * @param tokenId The token ID of the NFT to query the mint timestamp for.\n     *\n     * @return uint256 Mint timestamp, this is stored as a uint96 but returned as a uint256 to reduce unnecessary\n     * padding.\n     */\n    function mintTimestampOf(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the token data associated with a given NFT. This allows fetching the token owner and\n     * mint timestamp in a single call.\n     *\n     * @param tokenId The token ID of the NFT to query the token data for.\n     *\n     * @return TokenData A struct containing both the owner address and the mint timestamp.\n     */\n    function tokenDataOf(uint256 tokenId) external view returns (Types.TokenData memory);\n\n    /**\n     * @notice Returns whether a token with the given token ID exists.\n     *\n     * @param tokenId The token ID of the NFT to check existence for.\n     *\n     * @return bool True if the token exists.\n     */\n    function exists(uint256 tokenId) external view returns (bool);\n\n    /**\n     * @notice Returns the amount of tokens in circulation.\n     *\n     * @return uint256 The current total supply of tokens.\n     */\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "lens-modules/contracts/interfaces/IFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title IFollowModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible Follow Modules.\n * These are responsible for processing the follow actions and can be used to implement any kind of follow logic.\n * For example:\n *  - Token-gated follows (e.g. a user must hold a certain amount of a token to follow a profile).\n *  - Paid follows (e.g. a user must pay a certain amount of a token to follow a profile).\n *  - Rewarding users for following a profile.\n *  - Etc.\n */\ninterface IFollowModule {\n    /**\n     * @notice Initializes a follow module for a given Lens profile.\n     * @custom:permissions LensHub.\n     *\n     * @param profileId The Profile ID to initialize this follow module for.\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\n     * @param data Arbitrary data passed from the user to be decoded by the Follow Module during initialization.\n     *\n     * @return bytes The encoded data to be emitted from the hub.\n     */\n    function initializeFollowModule(\n        uint256 profileId,\n        address transactionExecutor,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a given follow.\n     * @custom:permissions LensHub.\n     *\n     * @param followerProfileId The Profile ID of the follower's profile.\n     * @param followTokenId The Follow Token ID that is being used to follow. Zero if we are processing a new fresh\n     * follow, in this case, the follow ID assigned can be queried from the Follow NFT collection if needed.\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\n     * @param targetProfileId The token ID of the profile being followed.\n     * @param data Arbitrary data passed by the follower.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processFollow(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        address transactionExecutor,\n        uint256 targetProfileId,\n        bytes calldata data\n    ) external returns (bytes memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/IFollowNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title IFollowNFT\n * @author Lens Protocol\n *\n * @notice This is the interface for the FollowNFT contract, which is cloned upon the first follow for any profile.\n * By default the Follow tokens are tied to the follower profile, which means that they will be automatically\n * transferred with it.\n * This is achieved by them not being ERC-721 initially. However, the Follow NFT collections support converting them to\n * ERC-721 tokens (i.e. wrapping) natively, enabling composability with existing ERC-721-based protocols.\n */\ninterface IFollowNFT {\n    error AlreadyFollowing();\n    error NotFollowing();\n    error FollowTokenDoesNotExist();\n    error AlreadyWrapped();\n    error OnlyWrappedFollowTokens();\n    error DoesNotHavePermissions();\n\n    /**\n     * @notice Initializes the follow NFT.\n     * @custom:permissions LensHub.\n     *\n     * @dev Sets the targeted profile, and the token royalties.\n     *\n     * @param profileId The ID of the profile targeted by the follow tokens minted by this collection.\n     */\n    function initialize(uint256 profileId) external;\n\n    /**\n     * @notice Makes the passed profile follow the profile targeted in this contract.\n     * @custom:permissions LensHub.\n     *\n     * @param followerProfileId The ID of the profile acting as the follower.\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\n     * @param followTokenId The ID of the follow token to be used for this follow operation. Zero if a new follow token\n     * should be minted.\n     *\n     * @return uint256 The ID of the token used to follow.\n     */\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Makes the passed profile unfollow the profile targeted in this contract.\n     * @custom:permissions LensHub.\n     *\n     * @param unfollowerProfileId The ID of the profile that is performing the unfollow operation.\n     */\n    function unfollow(uint256 unfollowerProfileId) external;\n\n    /**\n     * @notice Removes the follower from the given follow NFT.\n     * @custom:permissions Follow token owner or approved-for-all.\n\n     * @dev Only on wrapped token.\n     *\n     * @param followTokenId The ID of the follow token to remove the follower from.\n     */\n    function removeFollower(uint256 followTokenId) external;\n\n    /**\n     * @notice Approves the given profile to follow with the given wrapped token.\n     * @custom:permissions Follow token owner or approved-for-all.\n     *\n     * @dev Only on wrapped tokens.\n     * It approves setting a follower on the given wrapped follow token, which lets the follow token owner to allow\n     * a profile to follow with his token without losing its ownership. This approval is cleared on transfers, as well\n     * as when unwrapping.\n     *\n     * @param approvedProfileId The ID of the profile approved to follow with the given token.\n     * @param followTokenId The ID of the follow token to be approved for the given profile.\n     */\n    function approveFollow(uint256 approvedProfileId, uint256 followTokenId) external;\n\n    /**\n     * @notice Unties the follow token from the follower's profile one, and wraps it into the ERC-721 untied follow\n     * tokens collection. Untied follow tokens will NOT be automatically transferred with their follower profile.\n     * @custom:permissions Follower profile owner.\n     *\n     * @dev Only on unwrapped follow tokens.\n     *\n     * @param followTokenId The ID of the follow token to untie and wrap.\n     */\n    function wrap(uint256 followTokenId) external;\n\n    /**\n     * @notice Unties the follow token from the follower's profile one, and wraps it into the ERC-721 untied follow\n     * tokens collection. Untied follow tokens will NOT be automatically transferred with their follower profile.\n     * @custom:permissions Follower profile owner.\n     *\n     * @dev Only on unwrapped follow tokens.\n     *\n     * @param followTokenId The ID of the follow token to untie and wrap.\n     * @param wrappedTokenReceiver The address where the follow token is minted to when being wrapped as ERC-721.\n     */\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external;\n\n    /**\n     * @notice Unwraps the follow token from the ERC-721 untied follow tokens collection, and ties it to the follower's\n     * profile token. Tokens that are tied to the follower profile will be automatically transferred with it.\n     *\n     * @param followTokenId The ID of the follow token to unwrap and tie to its follower.\n     */\n    function unwrap(uint256 followTokenId) external;\n\n    /**\n     * @notice Processes logic when the given profile is being blocked. If it was following the targeted profile,\n     * this will make it unfollow.\n     * @custom:permissions LensHub.\n     *\n     * @param followerProfileId The ID of the follow token to unwrap and tie.\n     *\n     * @return bool True if the given profile was following and now has unfollowed, false otherwise.\n     */\n    function processBlock(uint256 followerProfileId) external returns (bool);\n\n    ///////////////////////////\n    ///       GETTERS       ///\n    ///////////////////////////\n\n    /**\n     * @notice Gets the ID of the profile following with the given follow token.\n     *\n     * @param followTokenId The ID of the follow token whose follower should be queried.\n     *\n     * @return uint256 The ID of the profile following with the given token, zero if it is not being used to follow.\n     */\n    function getFollowerProfileId(uint256 followTokenId) external view returns (uint256);\n\n    /**\n     * @notice Gets the original follow timestamp of the given follow token.\n     *\n     * @param followTokenId The ID of the follow token whose original follow timestamp should be queried.\n     *\n     * @return uint256 The timestamp of the first follow performed with the token, zero if was not used to follow yet.\n     */\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view returns (uint256);\n\n    /**\n     * @notice Gets the current follow timestamp of the given follow token.\n     *\n     * @param followTokenId The ID of the follow token whose follow timestamp should be queried.\n     *\n     * @return uint256 The timestamp of the current follow of the token, zero if it is not being used to follow.\n     */\n    function getFollowTimestamp(uint256 followTokenId) external view returns (uint256);\n\n    /**\n     * @notice Gets the ID of the profile allowed to recover the given follow token.\n     *\n     * @param followTokenId The ID of the follow token whose allowed profile to recover should be queried.\n     *\n     * @return uint256 The ID of the profile allowed to recover the given follow token, zero if none of them is allowed.\n     */\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view returns (uint256);\n\n    /**\n     * @notice Gets the follow data of the given follow token.\n     *\n     * @param followTokenId The ID of the follow token whose follow data should be queried.\n     *\n     * @return FollowData The token data associated with the given follow token.\n     */\n    function getFollowData(uint256 followTokenId) external view returns (Types.FollowData memory);\n\n    /**\n     * @notice Tells if the given profile is following the profile targeted in this contract.\n     *\n     * @param followerProfileId The ID of the profile whose following state should be queried.\n     *\n     * @return uint256 The ID of the profile set as a follower in the given token, zero if it is not being used to follow.\n     */\n    function isFollowing(uint256 followerProfileId) external view returns (bool);\n\n    /**\n     * @notice Gets the ID of the token being used to follow by the given follower.\n     *\n     * @param followerProfileId The ID of the profile whose follow ID should be queried.\n     *\n     * @return uint256 The ID of the token being used to follow by the given follower, zero if he is not following.\n     */\n    function getFollowTokenId(uint256 followerProfileId) external view returns (uint256);\n\n    /**\n     * @notice Gets the ID of the profile approved to follow with the given token.\n     *\n     * @param followTokenId The ID of the token whose approved to follow should be queried.\n     *\n     * @return uint256 The ID of the profile approved to follow with the given token, zero if none of them is approved.\n     */\n    function getFollowApproved(uint256 followTokenId) external view returns (uint256);\n\n    /**\n     * @notice Gets the count of the followers of the profile targeted in this contract.\n     * @notice This number might be out of sync if one of the followers burns their profile.\n     *\n     * @return uint256 The count of the followers of the profile targeted in this contract.\n     */\n    function getFollowerCount() external view returns (uint256);\n}\n"
    },
    "lens-modules/contracts/interfaces/IFollowTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IFollowTokenURI {\n    function getTokenURI(\n        uint256 followTokenId,\n        uint256 followedProfileId,\n        uint256 originalFollowTimestamp\n    ) external pure returns (string memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/IHandleTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IHandleTokenURI {\n    function getTokenURI(\n        uint256 tokenId,\n        string memory localName,\n        string memory namespace\n    ) external view returns (string memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/ILegacyCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ICollectModule\n * @author Lens Protocol\n * @custom:pending-deprecation\n *\n * @notice This is the deprecated interface for previously Lens-compatible CollectModules.\n */\ninterface ILegacyCollectModule {\n    /**\n     * @notice Initializes data for a given publication being published. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param data Arbitrary data __passed from the user!__ to be decoded.\n     *\n     * @return bytes An ABI-encoded encapsulating the execution's state changes. This will be emitted by the\n     * hub alongside the collect module's address and should be consumed by front ends.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a collect action for a given publication, this can only be called by the hub.\n     *\n     * @param referrerProfileId The LensHub profile token ID of the referrer's profile (only different in case of mirrors).\n     * @param collector The collector address.\n     * @param profileId The token ID of the profile associated with the publication being collected.\n     * @param pubId The LensHub publication ID associated with the publication being collected.\n     * @param data Arbitrary data __passed from the collector!__ to be decoded.\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/ILegacyReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title IReferenceModule\n * @author Lens Protocol\n * @custom:pending-deprecation\n *\n * @notice This is the deprecated interface for previously Lens-compatible ReferenceModules.\n */\ninterface ILegacyReferenceModule {\n    /**\n     * @notice Initializes data for a given publication being published. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param data Arbitrary data passed from the user to be decoded.\n     *\n     * @return bytes An ABI-encoded data encapsulating the execution's state changes. This will be emitted by the\n     * hub alongside the collect module's address and should be consumed by front ends.\n     */\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a comment action referencing a given publication. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile associated with the publication being published.\n     * @param pointedProfileId The profile ID of the profile associated with the publication being referenced.\n     * @param pointedPubId The publication ID of the publication being referenced.\n     * @param data Arbitrary data __passed from the commenter!__ to be decoded.\n     */\n    function processComment(\n        uint256 profileId,\n        uint256 pointedProfileId,\n        uint256 pointedPubId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Processes a mirror action referencing a given publication. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile associated with the publication being published.\n     * @param pointedProfileId The profile ID of the profile associated with the publication being referenced.\n     * @param pointedPubId The publication ID of the publication being referenced.\n     * @param data Arbitrary data __passed from the mirrorer!__ to be decoded.\n     */\n    function processMirror(\n        uint256 profileId,\n        uint256 pointedProfileId,\n        uint256 pointedPubId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from '../interfaces/IERC721Timestamped.sol';\nimport {IERC721Burnable} from '../interfaces/IERC721Burnable.sol';\nimport {IERC721MetaTx} from '../interfaces/IERC721MetaTx.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\ninterface ILensERC721 is IERC721, IERC721Timestamped, IERC721Burnable, IERC721MetaTx, IERC721Metadata {}\n"
    },
    "lens-modules/contracts/interfaces/ILensGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title ILensGovernable\n * @author Lens Protocol\n *\n * @notice This is the interface for the Lens Protocol main governance functions.\n */\ninterface ILensGovernable {\n    /**\n     * @notice Sets the privileged governance role.\n     * @custom:permissions Governance.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external;\n\n    /**\n     * @notice Sets the emergency admin, which is a permissioned role able to set the protocol state.\n     * @custom:permissions Governance.\n     *\n     * @param newEmergencyAdmin The new emergency admin address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external;\n\n    /**\n     * @notice Sets the protocol state to either a global pause, a publishing pause or an unpaused state.\n     * @custom:permissions Governance or Emergency Admin. Emergency Admin can only restrict more.\n     *\n     * @param newState The state to set. It can be one of the following:\n     *  - Unpaused: The protocol is fully operational.\n     *  - PublishingPaused: The protocol is paused for publishing, but it is still operational for others operations.\n     *  - Paused: The protocol is paused for all operations.\n     */\n    function setState(Types.ProtocolState newState) external;\n\n    /**\n     * @notice Adds or removes a profile creator from the whitelist.\n     * @custom:permissions Governance.\n     *\n     * @param profileCreator The profile creator address to add or remove from the whitelist.\n     * @param whitelist Whether or not the profile creator should be whitelisted.\n     */\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external;\n\n    /**\n     * @notice Sets the profile token URI contract.\n     * @custom:permissions Governance.\n     *\n     * @param profileTokenURIContract The profile token URI contract to set.\n     */\n    function setProfileTokenURIContract(address profileTokenURIContract) external;\n\n    /**\n     * @notice Sets the follow token URI contract.\n     * @custom:permissions Governance.\n     *\n     * @param followTokenURIContract The follow token URI contract to set.\n     */\n    function setFollowTokenURIContract(address followTokenURIContract) external;\n\n    /**\n     * @notice Sets the treasury address.\n     * @custom:permissions Governance\n     *\n     * @param newTreasury The new treasury address to set.\n     */\n    function setTreasury(address newTreasury) external;\n\n    /**\n     * @notice Sets the treasury fee.\n     * @custom:permissions Governance\n     *\n     * @param newTreasuryFee The new treasury fee to set.\n     */\n    function setTreasuryFee(uint16 newTreasuryFee) external;\n\n    /**\n     * @notice Returns the currently configured governance address.\n     *\n     * @return address The address of the currently configured governance.\n     */\n    function getGovernance() external view returns (address);\n\n    /**\n     * @notice Gets the state currently set in the protocol. It could be a global pause, a publishing pause or an\n     * unpaused state.\n     * @custom:permissions Anyone.\n     *\n     * @return Types.ProtocolState The state currently set in the protocol.\n     */\n    function getState() external view returns (Types.ProtocolState);\n\n    /**\n     * @notice Returns whether or not a profile creator is whitelisted.\n     *\n     * @param profileCreator The address of the profile creator to check.\n     *\n     * @return bool True if the profile creator is whitelisted, false otherwise.\n     */\n    function isProfileCreatorWhitelisted(address profileCreator) external view returns (bool);\n\n    /**\n     * @notice Returns the treasury address.\n     *\n     * @return address The treasury address.\n     */\n    function getTreasury() external view returns (address);\n\n    /**\n     * @notice Returns the treasury fee.\n     *\n     * @return uint16 The treasury fee.\n     */\n    function getTreasuryFee() external view returns (uint16);\n\n    /**\n     * @notice Returns the treasury address and treasury fee in a single call.\n     *\n     * @return tuple First, the treasury address, second, the treasury fee.\n     */\n    function getTreasuryData() external view returns (address, uint16);\n\n    /**\n     * @notice Gets the profile token URI contract.\n     *\n     * @return address The profile token URI contract.\n     */\n    function getProfileTokenURIContract() external view returns (address);\n\n    /**\n     * @notice Gets the follow token URI contract.\n     *\n     * @return address The follow token URI contract.\n     */\n    function getFollowTokenURIContract() external view returns (address);\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensHandles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ILensHandles\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHandles contract that is responsible for minting and burning handle NFTs.\n * A handle is composed of a local name and a namespace, separated by a dot.\n * Example: `satoshi.lens` is a handle composed of the local name `satoshi` and the namespace `lens`.\n */\ninterface ILensHandles is IERC721 {\n    /**\n     * @notice Mints a handle NFT in the given namespace.\n     * @custom:permissions Only LensHandles contract's owner or LensHub.\n     *\n     * @param to The address to mint the handle to.\n     * @param localName The local name of the handle (the part before \".lens\").\n     *\n     * @return uint256 The ID of the handle NFT minted.\n     */\n    function mintHandle(address to, string calldata localName) external returns (uint256);\n\n    /**\n     * @notice Burns a handle NFT.\n     * @custom:permissions Owner of Handle NFT.\n     *\n     * @param tokenId The ID of the handle NFT to burn.\n     */\n    function burn(uint256 tokenId) external;\n\n    /**\n     * @notice Gets the namespace of the contract. It's 'lens' for the LensHandles contract.\n     *\n     * @return string The namespace of the contract.\n     */\n    function getNamespace() external pure returns (string memory);\n\n    /**\n     * @notice Gets the hash of the namespace of the contract. It's keccak256('lens') for the LensHandles contract.\n     *\n     * @return bytes32 The hash of the namespace of the contract.\n     */\n    function getNamespaceHash() external pure returns (bytes32);\n\n    /**\n     * @notice Returns whether `tokenId` exists.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     *\n     * @return bool Whether the token exists.\n     */\n    function exists(uint256 tokenId) external view returns (bool);\n\n    /**\n     * @notice Returns the amount of tokens in circulation.\n     *\n     * @return uint256 The current total supply of tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns the HandleTokenURI contract address.\n     *\n     * @return address The HandleTokenURI contract address.\n     */\n    function getHandleTokenURIContract() external view returns (address);\n\n    /**\n     * @notice Sets the HandleTokenURI contract address.\n     * @custom:permissions Only LensHandles contract's owner\n     *\n     * @param handleTokenURIContract The HandleTokenURI contract address to set.\n     */\n    function setHandleTokenURIContract(address handleTokenURIContract) external;\n\n    /**\n     * @notice DANGER: Triggers disabling the profile protection mechanism for the msg.sender, which will allow\n     * transfers or approvals over profiles held by it.\n     * Disabling the mechanism will have a timelock before it becomes effective, allowing the owner to re-enable\n     * the protection back in case of being under attack.\n     * The protection layer only applies to EOA wallets.\n     */\n    function DANGER__disableTokenGuardian() external;\n\n    /**\n     * @notice Enables back the profile protection mechanism for the msg.sender, preventing profile transfers or\n     * approvals (except when revoking them).\n     * The protection layer only applies to EOA wallets.\n     */\n    function enableTokenGuardian() external;\n\n    /**\n     * @notice Returns the timestamp at which the Token Guardian will become effectively disabled.\n     *\n     * @param wallet The address to check the timestamp for.\n     *\n     * @return uint256 The timestamp at which the Token Guardian will become effectively disabled.\n     * Max 256-bit unsigned integer value if enabled.\n     */\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256);\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {ILensProtocol} from '../interfaces/ILensProtocol.sol';\nimport {ILensGovernable} from '../interfaces/ILensGovernable.sol';\nimport {ILensHubEventHooks} from '../interfaces/ILensHubEventHooks.sol';\nimport {ILensImplGetters} from '../interfaces/ILensImplGetters.sol';\nimport {ILensProfiles} from '../interfaces/ILensProfiles.sol';\nimport {ILensVersion} from '../interfaces/ILensVersion.sol';\n\ninterface ILensHub is\n    ILensProfiles,\n    ILensProtocol,\n    ILensGovernable,\n    ILensHubEventHooks,\n    ILensImplGetters,\n    ILensVersion\n{}\n"
    },
    "lens-modules/contracts/interfaces/ILensHubEventHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ILensHubEventHooks\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHub contract's event hooks. As we want most of the core events to be\n * emitted by the LensHub contract, event hooks are needed for core events generated by pheripheral contracts.\n */\ninterface ILensHubEventHooks {\n    /**\n     * @dev Helper function to emit an `Unfollowed` event from the hub, to be consumed by indexers to track unfollows.\n     * @custom:permissions FollowNFT of the Profile unfollowed.\n     *\n     * @param unfollowerProfileId The ID of the profile that executed the unfollow.\n     * @param idOfProfileUnfollowed The ID of the profile that was unfollowed.\n     * @param transactionExecutor The address of the account executing the unfollow operation.\n     */\n    function emitUnfollowedEvent(\n        uint256 unfollowerProfileId,\n        uint256 idOfProfileUnfollowed,\n        address transactionExecutor\n    ) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensHubInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ILensHub\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHub contract, the main entry point for the Lens Protocol.\n * You'll find all the events and external functions, as well as the reasoning behind them here.\n */\ninterface ILensHubInitializable {\n    /**\n     * @notice Initializes the LensHub, setting the initial governance address, the name and symbol of the profiles\n     * in the LensNFTBase contract, and Protocol State (Paused).\n     * @dev This is assuming a proxy pattern is implemented.\n     * @custom:permissions Callable once.\n     *\n     * @param name The name of the Profile NFT.\n     * @param symbol The symbol of the Profile NFT.\n     * @param newGovernance The governance address to set.\n     */\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensImplGetters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ILensImplGetters\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHub contract's implementation getters. These implementations will be used\n * for deploying each respective contract for each profile.\n */\ninterface ILensImplGetters {\n    /**\n     * @notice Returns the Follow NFT implementation address that is used for all deployed Follow NFTs.\n     *\n     * @return address The Follow NFT implementation address.\n     */\n    function getFollowNFTImpl() external view returns (address);\n\n    /**\n     * @notice Returns the Collect NFT implementation address that is used for each new deployed Collect NFT.\n     * @custom:pending-deprecation\n     *\n     * @return address The Collect NFT implementation address.\n     */\n    function getLegacyCollectNFTImpl() external view returns (address);\n\n    /**\n     * @notice Returns the address of the registry that stores all modules that are used by the Lens Protocol.\n     *\n     * @return address The address of the Module Registry contract.\n     */\n    function getModuleRegistry() external view returns (address);\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensProfiles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {ILensERC721} from '../interfaces/ILensERC721.sol';\n\ninterface ILensProfiles is ILensERC721 {\n    /**\n     * @notice DANGER: Triggers disabling the profile protection mechanism for the msg.sender, which will allow\n     * transfers or approvals over profiles held by it.\n     * Disabling the mechanism will have a timelock before it becomes effective, allowing the owner to re-enable\n     * the protection back in case of being under attack.\n     * The protection layer only applies to EOA wallets.\n     */\n    function DANGER__disableTokenGuardian() external;\n\n    /**\n     * @notice Enables back the profile protection mechanism for the msg.sender, preventing profile transfers or\n     * approvals (except when revoking them).\n     * The protection layer only applies to EOA wallets.\n     */\n    function enableTokenGuardian() external;\n\n    /**\n     * @notice Returns the timestamp at which the Token Guardian will become effectively disabled.\n     *\n     * @param wallet The address to check the timestamp for.\n     *\n     * @return uint256 The timestamp at which the Token Guardian will become effectively disabled. Zero if enabled.\n     */\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256);\n\n    /**\n     * @notice allows transferring of profile but keeping the delegate settings\n     */\n    function transferFromKeepingDelegates(address from, address to, uint256 tokenId) external;\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title ILensProtocol\n * @author Lens Protocol\n *\n * @notice This is the interface for Lens Protocol's core functions. It contains all the entry points for performing\n * social operations.\n */\ninterface ILensProtocol {\n    /**\n     * @notice Creates a profile with the specified parameters, minting a Profile NFT to the given recipient.\n     * @custom:permissions Any whitelisted profile creator.\n     *\n     * @param createProfileParams A CreateProfileParams struct containing the needed params.\n     */\n    function createProfile(Types.CreateProfileParams calldata createProfileParams) external returns (uint256);\n\n    /**\n     * @notice Sets the metadata URI for the given profile.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param profileId The token ID of the profile to set the metadata URI for.\n     * @param metadataURI The metadata URI to set for the given profile.\n     */\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI) external;\n\n    /**\n     * @custom:meta-tx setProfileMetadataURI.\n     */\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external;\n\n    /**\n     * @notice Sets the follow module for the given profile.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param profileId The token ID of the profile to set the follow module for.\n     * @param followModule The follow module to set for the given profile, must be whitelisted.\n     * @param followModuleInitData The data to be passed to the follow module for initialization.\n     */\n    function setFollowModule(uint256 profileId, address followModule, bytes calldata followModuleInitData) external;\n\n    /**\n     * @custom:meta-tx setFollowModule.\n     */\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external;\n\n    /**\n     * @notice Changes the delegated executors configuration for the given profile. It allows setting the approvals for\n     * delegated executors in the specified configuration, as well as switching to it.\n     * @custom:permissions Profile Owner.\n     *\n     * @param delegatorProfileId The ID of the profile to which the delegated executor is being changed for.\n     * @param delegatedExecutors The array of delegated executors to set the approval for.\n     * @param approvals The array of booleans indicating the corresponding executor's new approval status.\n     * @param configNumber The number of the configuration where the executor approval state is being set.\n     * @param switchToGivenConfig A boolean indicating if the configuration must be switched to the one with the given\n     * number.\n     */\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external;\n\n    /**\n     * @notice Changes the delegated executors configuration for the given profile under the current configuration.\n     * @custom:permissions Profile Owner.\n     *\n     * @param delegatorProfileId The ID of the profile to which the delegated executor is being changed for.\n     * @param delegatedExecutors The array of delegated executors to set the approval for.\n     * @param approvals The array of booleans indicating the corresponding executor's new approval status.\n     */\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external;\n\n    /**\n     * @custom:meta-tx changeDelegatedExecutorsConfig.\n     */\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external;\n\n    /**\n     * @notice Publishes a post.\n     * Post is the most basic publication type, and can be used to publish any kind of content.\n     * Posts can have these types of modules initialized:\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\n     *  - Reference module: a module handling the rules when referencing this post (e.g. token-gated comments)\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param postParams A PostParams struct containing the needed parameters.\n     *\n     * @return uint256 An integer representing the post's publication ID.\n     */\n    function post(Types.PostParams calldata postParams) external returns (uint256);\n\n    /**\n     * @custom:meta-tx post.\n     */\n    function postWithSig(\n        Types.PostParams calldata postParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256);\n\n    /**\n     * @notice Publishes a comment on the given publication.\n     * Comment is a type of reference publication that points to another publication.\n     * Comments can have these types of modules initialized:\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\n     *  - Reference module: a module handling the rules when referencing this comment (e.g. token-gated mirrors)\n     * Comments can have referrers (e.g. publications or profiles that helped to discover the pointed publication).\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param commentParams A CommentParams struct containing the needed parameters.\n     *\n     * @return uint256 An integer representing the comment's publication ID.\n     */\n    function comment(Types.CommentParams calldata commentParams) external returns (uint256);\n\n    /**\n     * @custom:meta-tx comment.\n     */\n    function commentWithSig(\n        Types.CommentParams calldata commentParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256);\n\n    /**\n     * @notice Publishes a mirror of the given publication.\n     * Mirror is a type of reference publication that points to another publication but doesn't have content.\n     * Mirrors don't have any modules initialized.\n     * Mirrors can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\n     * You cannot mirror a mirror, comment on a mirror, or quote a mirror.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param mirrorParams A MirrorParams struct containing the necessary parameters.\n     *\n     * @return uint256 An integer representing the mirror's publication ID.\n     */\n    function mirror(Types.MirrorParams calldata mirrorParams) external returns (uint256);\n\n    /**\n     * @custom:meta-tx mirror.\n     */\n    function mirrorWithSig(\n        Types.MirrorParams calldata mirrorParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256);\n\n    /**\n     * @notice Publishes a quote of the given publication.\n     * Quote is a type of reference publication similar to mirror, but it has content and modules.\n     * Quotes can have these types of modules initialized:\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\n     *  - Reference module: a module handling the rules when referencing this quote (e.g. token-gated comments on quote)\n     * Quotes can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\n     * Unlike mirrors, you can mirror a quote, comment on a quote, or quote a quote.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param quoteParams A QuoteParams struct containing the needed parameters.\n     *\n     * @return uint256 An integer representing the quote's publication ID.\n     */\n    function quote(Types.QuoteParams calldata quoteParams) external returns (uint256);\n\n    /**\n     * @custom:meta-tx quote.\n     */\n    function quoteWithSig(\n        Types.QuoteParams calldata quoteParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256);\n\n    /**\n     * @notice Follows given profiles, executing each profile's follow module logic (if any).\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @dev Both the `idsOfProfilesToFollow`, `followTokenIds`, and `datas` arrays must be of the same length,\n     * regardless if the profiles do not have a follow module set.\n     *\n     * @param followerProfileId The ID of the profile the follows are being executed for.\n     * @param idsOfProfilesToFollow The array of IDs of profiles to follow.\n     * @param followTokenIds The array of follow token IDs to use for each follow (0 if you don't own a follow token).\n     * @param datas The arbitrary data array to pass to the follow module for each profile if needed.\n     *\n     * @return uint256[] An array of follow token IDs representing the follow tokens created for each follow.\n     */\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    ) external returns (uint256[] memory);\n\n    /**\n     * @custom:meta-tx follow.\n     */\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256[] memory);\n\n    /**\n     * @notice Unfollows given profiles.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @param unfollowerProfileId The ID of the profile the unfollows are being executed for.\n     * @param idsOfProfilesToUnfollow The array of IDs of profiles to unfollow.\n     */\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow) external;\n\n    /**\n     * @custom:meta-tx unfollow.\n     */\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external;\n\n    /**\n     * @notice Sets the block status for the given profiles. Changing a profile's block status to `true` (i.e. blocked),\n     * when will also force them to unfollow.\n     * Blocked profiles cannot perform any actions with the profile that blocked them: they cannot comment or mirror\n     * their publications, they cannot follow them, they cannot collect, tip them, etc.\n     * @custom:permissions Profile Owner or Delegated Executor.\n     *\n     * @dev Both the `idsOfProfilesToSetBlockStatus` and `blockStatus` arrays must be of the same length.\n     *\n     * @param byProfileId The ID of the profile that is blocking/unblocking somebody.\n     * @param idsOfProfilesToSetBlockStatus The array of IDs of profiles to set block status.\n     * @param blockStatus The array of block statuses to use for each (true is blocked).\n     */\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external;\n\n    /**\n     * @custom:meta-tx setBlockStatus.\n     */\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external;\n\n    /**\n     * @notice Collects a given publication via signature with the specified parameters.\n     * Collect can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\n     * @custom:permissions Collector Profile Owner or its Delegated Executor.\n     * @custom:pending-deprecation Collect modules were replaced by PublicationAction Collect modules in V2. This method\n     * is left here for backwards compatibility with posts made in V1 that had Collect modules.\n     *\n     * @param collectParams A CollectParams struct containing the parameters.\n     *\n     * @return uint256 An integer representing the minted token ID.\n     */\n    function collectLegacy(Types.LegacyCollectParams calldata collectParams) external returns (uint256);\n\n    /**\n     * @custom:meta-tx collect.\n     * @custom:pending-deprecation\n     */\n    function collectLegacyWithSig(\n        Types.LegacyCollectParams calldata collectParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (uint256);\n\n    /**\n     * @notice Acts on a given publication with the specified parameters.\n     * You can act on a publication except a mirror (if it has at least one action module initialized).\n     * Actions can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\n     * @custom:permissions Actor Profile Owner or its Delegated Executor.\n     *\n     * @param publicationActionParams A PublicationActionParams struct containing the parameters.\n     *\n     * @return bytes Arbitrary data the action module returns.\n     */\n    function act(Types.PublicationActionParams calldata publicationActionParams) external returns (bytes memory);\n\n    /**\n     * @custom:meta-tx act.\n     */\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    ) external returns (bytes memory);\n\n    /**\n     * @dev This function is used to invalidate signatures by incrementing the nonce of the signer.\n     * @param increment The amount to increment the nonce by (max 255).\n     */\n    function incrementNonce(uint8 increment) external;\n\n    /////////////////////////////////\n    ///       VIEW FUNCTIONS      ///\n    /////////////////////////////////\n\n    /**\n     * @notice Returns whether or not `followerProfileId` is following `followedProfileId`.\n     *\n     * @param followerProfileId The ID of the profile whose following state should be queried.\n     * @param followedProfileId The ID of the profile whose followed state should be queried.\n     *\n     * @return bool True if `followerProfileId` is following `followedProfileId`, false otherwise.\n     */\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool);\n\n    /**\n     * @notice Returns whether the given address is approved as delegated executor, in the configuration with the given\n     * number, to act on behalf of the given profile.\n     *\n     * @param delegatorProfileId The ID of the profile to check the delegated executor approval for.\n     * @param delegatedExecutor The address to query the delegated executor approval for.\n     * @param configNumber The number of the configuration where the executor approval state is being queried.\n     *\n     * @return bool True if the address is approved as a delegated executor to act on behalf of the profile in the\n     * given configuration, false otherwise.\n     */\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns whether the given address is approved as delegated executor, in the current configuration, to act\n     * on behalf of the given profile.\n     *\n     * @param delegatorProfileId The ID of the profile to check the delegated executor approval for.\n     * @param delegatedExecutor The address to query the delegated executor approval for.\n     *\n     * @return bool True if the address is approved as a delegated executor to act on behalf of the profile in the\n     * current configuration, false otherwise.\n     */\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns the current delegated executor config number for the given profile.\n     *\n     * @param delegatorProfileId The ID of the profile from which the delegated executors config number is being queried\n     *\n     * @return uint256 The current delegated executor configuration number.\n     */\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64);\n\n    /**\n     * @notice Returns the previous used delegated executor config number for the given profile.\n     *\n     * @param delegatorProfileId The ID of the profile from which the delegated executors' previous configuration number\n     * set is being queried.\n     *\n     * @return uint256 The delegated executor configuration number previously set. It will coincide with the current\n     * configuration set if it was never switched from the default one.\n     */\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64);\n\n    /**\n     * @notice Returns the maximum delegated executor config number for the given profile.\n     * This is the maximum config number that was ever used by this profile.\n     * When creating a new clean configuration, you can only use a number that is maxConfigNumber + 1.\n     *\n     * @param delegatorProfileId The ID of the profile from which the delegated executors' maximum configuration number\n     * set is being queried.\n     *\n     * @return uint256 The delegated executor maximum configuration number set.\n     */\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64);\n\n    /**\n     * @notice Returns whether `profileId` is blocked by `byProfileId`.\n     * See setBlockStatus() for more information on how blocking works on the platform.\n     *\n     * @param profileId The ID of the profile whose blocked status should be queried.\n     * @param byProfileId The ID of the profile whose blocker status should be queried.\n     *\n     * @return bool True if `profileId` is blocked by `byProfileId`, false otherwise.\n     */\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool);\n\n    /**\n     * @notice Returns the URI associated with a given publication.\n     * This is used to store the publication's metadata, e.g.: content, images, etc.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return string The URI associated with a given publication.\n     */\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory);\n\n    /**\n     * @notice Returns the full profile struct associated with a given profile token ID.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return Profile The profile struct of the given profile.\n     */\n    function getProfile(uint256 profileId) external view returns (Types.Profile memory);\n\n    /**\n     * @notice Returns the full publication struct for a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return Publication The publication struct associated with the queried publication.\n     */\n    function getPublication(uint256 profileId, uint256 pubId) external view returns (Types.PublicationMemory memory);\n\n    /**\n     * @notice Returns the type of a given publication.\n     * The type can be one of the following (see PublicationType enum):\n     * - Nonexistent\n     * - Post\n     * - Comment\n     * - Mirror\n     * - Quote\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return PublicationType The publication type of the queried publication.\n     */\n    function getPublicationType(uint256 profileId, uint256 pubId) external view returns (Types.PublicationType);\n\n    /**\n     * @notice Returns wether a given Action Module is enabled for a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     * @param module The address of the Action Module to query.\n     *\n     * @return bool True if the Action Module is enabled for the queried publication, false if not.\n     */\n    function isActionModuleEnabledInPublication(\n        uint256 profileId,\n        uint256 pubId,\n        address module\n    ) external view returns (bool);\n}\n"
    },
    "lens-modules/contracts/interfaces/ILensVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ILensVersion\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHub Version getters and emitter.\n * It allows to emit a LensHub version during an upgrade, and also to get the current version.\n */\ninterface ILensVersion {\n    /**\n     * @notice Returns the LensHub current Version.\n     *\n     * @return version The LensHub current Version.\n     */\n    function getVersion() external view returns (string memory);\n\n    /**\n     * @notice Returns the LensHub current Git Commit.\n     *\n     * @return gitCommit The LensHub current Git Commit.\n     */\n    function getGitCommit() external view returns (bytes20);\n\n    /**\n     * @notice Emits the LensHub current Version. Used in upgradeAndCall().\n     */\n    function emitVersion() external;\n}\n"
    },
    "lens-modules/contracts/interfaces/IModuleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IModuleRegistry {\n    enum ModuleType {\n        __, // Just to avoid 0 as valid ModuleType\n        PUBLICATION_ACTION_MODULE,\n        REFERENCE_MODULE,\n        FOLLOW_MODULE\n    }\n\n    // Modules functions\n\n    function verifyModule(address moduleAddress, uint256 moduleType) external returns (bool);\n\n    function registerModule(address moduleAddress, uint256 moduleType) external returns (bool);\n\n    function getModuleTypes(address moduleAddress) external view returns (uint256);\n\n    function isModuleRegistered(address moduleAddress) external view returns (bool);\n\n    function isModuleRegisteredAs(address moduleAddress, uint256 moduleType) external view returns (bool);\n\n    // Currencies functions\n\n    function verifyErc20Currency(address currencyAddress) external returns (bool);\n\n    function registerErc20Currency(address currencyAddress) external returns (bool);\n\n    function isErc20CurrencyRegistered(address currencyAddress) external view returns (bool);\n}\n"
    },
    "lens-modules/contracts/interfaces/IProfileTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IProfileTokenURI {\n    function getTokenURI(uint256 profileId, uint256 mintTimestamp) external view returns (string memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/IPublicationActionModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title IPublicationAction\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible Publication Actions.\n * Publication action modules allow users to execute actions directly from a publication, like:\n *  - Minting NFTs.\n *  - Collecting a publication.\n *  - Sending funds to the publication author (e.g. tipping).\n *  - Etc.\n * Referrers are supported, so any publication or profile that references the publication can receive a share from the\n * publication's action if the action module supports it.\n */\ninterface IPublicationActionModule {\n    /**\n     * @notice Initializes the action module for the given publication being published with this Action module.\n     * @custom:permissions LensHub.\n     *\n     * @param profileId The profile ID of the author publishing the content with this Publication Action.\n     * @param pubId The publication ID being published.\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\n     * @param data Arbitrary data passed from the user to be decoded by the Action Module during initialization.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function initializePublicationAction(\n        uint256 profileId,\n        uint256 pubId,\n        address transactionExecutor,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes the action for a given publication. This includes the action's logic and any monetary/token\n     * operations.\n     * @custom:permissions LensHub.\n     *\n     * @param processActionParams The parameters needed to execute the publication action.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processPublicationAction(Types.ProcessActionParams calldata processActionParams)\n        external\n        returns (bytes memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/IReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\n/**\n * @title IReferenceModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible ReferenceModules.\n * Reference modules allow executing some action when a publication is referenced, like:\n *  - Rewards for mirroring/commenting/quoting a publication.\n *  - Token-gated comments/mirrors/quotes of a publication.\n *  - Etc.\n */\ninterface IReferenceModule {\n    /**\n     * @notice Initializes data for the given publication being published with this Reference module.\n     * @custom:permissions LensHub.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\n     * @param data Arbitrary data passed from the user to be decoded by the Reference Module during initialization.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        address transactionExecutor,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a comment being published. This includes any module logic like transferring tokens,\n     * checking for conditions (e.g. token-gated), etc.\n     * @custom:permissions LensHub.\n     *\n     * @param processCommentParams The parameters for processing a comment.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processComment(Types.ProcessCommentParams calldata processCommentParams) external returns (bytes memory);\n\n    /**\n     * @notice Processes a quote being published. This includes any module logic like transferring tokens,\n     * checking for conditions (e.g. token-gated), etc.\n     * @custom:permissions LensHub\n     *\n     * @param processQuoteParams The parameters for processing a quote.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processQuote(Types.ProcessQuoteParams calldata processQuoteParams) external returns (bytes memory);\n\n    /**\n     * @notice Processes a mirror being published. This includes any module logic like transferring tokens,\n     * checking for conditions (e.g. token-gated), etc.\n     * @custom:permissions LensHub\n     *\n     * @param processMirrorParams The parameters for processing a mirror.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processMirror(Types.ProcessMirrorParams calldata processMirrorParams) external returns (bytes memory);\n}\n"
    },
    "lens-modules/contracts/interfaces/ITokenHandleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title ITokenHandleRegistry\n * @author Lens Protocol\n *\n * @notice The interface for TokenHandleRegistry contract that is responsible for linking a handle NFT to a token NFT.\n * Linking means a connection between the two NFTs is created, and the handle NFT can be used to resolve the token NFT\n * or vice versa.\n * The registry is responsible for keeping track of the links between the NFTs, and for resolving them.\n * The first version of the registry is hard-coded to support only the .lens namespace and the Lens Protocol Profiles.\n */\ninterface ITokenHandleRegistry {\n    /**\n     * @notice Lens V1 -> V2 migration function. Links a handle NFT to a profile NFT without additional checks to save\n     * gas.\n     * Will be called by the migration function (in MigrationLib) in LensHub, only for new handles being migrated.\n     *\n     * @custom:permissions LensHub\n     *\n     * @param handleId ID of the .lens namespace handle NFT\n     * @param profileId ID of the Lens Protocol Profile NFT\n     */\n    function migrationLink(uint256 handleId, uint256 profileId) external;\n\n    /**\n     * @notice Links a handle NFT with a profile NFT.\n     * Linking means a connection between the two NFTs is created, and the handle NFT can be used to resolve the profile\n     * NFT or vice versa.\n     * @custom:permissions Both NFTs must be owned by the same address, and caller must be the owner of profile or its\n     * approved DelegatedExecutor.\n     *\n     * @dev In the first version of the registry, the NFT contracts are hard-coded:\n     *  - Handle is hard-coded to be of the .lens namespace\n     *  - Token is hard-coded to be of the Lens Protocol Profile\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\n     * function might be deprecated and replaced with a new one accepting addresses of the handle and token contracts.\n     *\n     * @param handleId ID of the .lens namespace handle NFT\n     * @param profileId ID of the Lens Protocol Profile NFT\n     */\n    function link(uint256 handleId, uint256 profileId) external;\n\n    /**\n     * @notice Unlinks a handle NFT from a profile NFT.\n     * @custom:permissions Caller can be the owner of either of the NFTs.\n     *\n     * @dev In the first version of the registry, the contracts are hard-coded:\n     *  - Handle is hard-coded to be of the .lens namespace\n     *  - Token is hard-coded to be of the Lens Protocol Profile\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\n     * function might be deprecated and replaced with a new one accepting addresses of the handle and token contracts.\n     *\n     * @param handleId ID of the .lens namespace handle NFT\n     * @param profileId ID of the Lens Protocol Profile NFT\n     */\n    function unlink(uint256 handleId, uint256 profileId) external;\n\n    /**\n     * @notice Resolves a handle NFT to a profile NFT.\n     *\n     * @dev In the first version of the registry, the contracts are hard-coded:\n     *  - Handle is hard-coded to be of the .lens namespace\n     *  - Token is hard-coded to be of the Lens Protocol Profile\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\n     * function might be deprecated and replaced with a new one.\n     *\n     * @param handleId ID of the .lens namespace handle NFT\n     *\n     * @return tokenId ID of the Lens Protocol Profile NFT\n     */\n    function resolve(uint256 handleId) external view returns (uint256);\n\n    /**\n     * @notice Gets a default handle for a profile NFT (aka reverse resolution).\n     *\n     * @dev In the first version of the registry, the contracts are hard-coded:\n     *  - Handle is hard-coded to be of the .lens namespace\n     *  - Token is hard-coded to be of the Lens Protocol Profile\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\n     * function might be deprecated and replaced with a new one.\n     *\n     * @param tokenId ID of the Lens Protocol Profile NFT\n     *\n     * @return handleId ID of the .lens namespace handle NFT\n     */\n    function getDefaultHandle(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "lens-modules/contracts/LensHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from './interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from './interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from './libraries/constants/Types.sol';\nimport {Errors} from './libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from './base/LensHubStorage.sol';\nimport {LensImplGetters} from './base/LensImplGetters.sol';\nimport {LensGovernable} from './base/LensGovernable.sol';\nimport {LensProfiles} from './base/LensProfiles.sol';\nimport {LensHubEventHooks} from './base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from './libraries/ActionLib.sol';\nimport {LegacyCollectLib} from './libraries/LegacyCollectLib.sol';\nimport {FollowLib} from './libraries/FollowLib.sol';\nimport {MetaTxLib} from './libraries/MetaTxLib.sol';\nimport {ProfileLib} from './libraries/ProfileLib.sol';\nimport {PublicationLib} from './libraries/PublicationLib.sol';\nimport {StorageLib} from './libraries/StorageLib.sol';\nimport {ValidationLib} from './libraries/ValidationLib.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n *\n * @custom:upgradeable Transparent upgradeable proxy. In this version, without initializer.\n * See `../misc/LensHubInitializable.sol` for the initializable version.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address followNFTImpl,\n        address legacyCollectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address moduleRegistry,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(tokenGuardianCooldown)\n        LensImplGetters(followNFTImpl, legacyCollectNFTImpl, moduleRegistry)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(\n        Types.CreateProfileParams calldata createProfileParams\n    ) external override whenNotPaused returns (uint256) {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(\n        uint256 profileId,\n        string calldata metadataURI\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI, msg.sender);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI, signature.signer);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData, msg.sender);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData, signature.signer);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(\n        Types.PostParams calldata postParams\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(\n        Types.PostParams calldata postParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(\n        Types.CommentParams calldata commentParams\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(\n        Types.CommentParams calldata commentParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(\n        Types.MirrorParams calldata mirrorParams\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(\n        Types.MirrorParams calldata mirrorParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(\n        Types.QuoteParams calldata quoteParams\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(\n        Types.QuoteParams calldata quoteParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId) {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus, msg.sender);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus, signature.signer);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectLegacy(\n        Types.LegacyCollectParams calldata collectParams\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getLegacyCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectLegacyWithSig(\n        Types.LegacyCollectParams calldata collectParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getLegacyCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(\n        Types.PublicationActionParams calldata publicationActionParams\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function incrementNonce(uint8 increment) external {\n        MetaTxLib.incrementNonce(increment);\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor\n    ) external view returns (bool) {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(\n        uint256 profileId,\n        uint256 pubId\n    ) external pure override returns (Types.PublicationMemory memory) {\n        return StorageLib.getPublicationMemory(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isActionModuleEnabledInPublication(\n        uint256 profileId,\n        uint256 pubId,\n        address module\n    ) external view returns (bool) {\n        return StorageLib.getPublication(profileId, pubId).actionModuleEnabled[module];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(\n        uint256 profileId,\n        uint256 pubId\n    ) external view override returns (Types.PublicationType) {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getFollowModule(uint256 profileId) external view returns (address) {\n        if (__DEPRECATED__collectModuleWhitelisted[msg.sender]) {\n            // Injecting LensHub as follow module when a Lens V1 collect module is performing the call.\n            // This is a hack to make legacy collect work when configured for followers only.\n            return address(this);\n        } else {\n            return StorageLib.getProfile(profileId).followModule;\n        }\n    }\n\n    function isFollowing(\n        uint256 followedProfileId,\n        address followerAddress,\n        uint256 /* tokenId */\n    ) external view returns (bool) {\n        if (__DEPRECATED__collectModuleWhitelisted[msg.sender]) {\n            // This state was pre-filled at LegacyCollectLib and it is a hack to make legacy collect work when\n            // configured for followers only.\n            return\n                _legacyCollectFollowValidationHelper[followerAddress] == followedProfileId ||\n                ProfileLib.isExecutorApproved(followedProfileId, followerAddress) ||\n                ProfileLib.ownerOf(followedProfileId) == followerAddress;\n        } else {\n            revert Errors.ExecutorInvalid();\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/ActionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from './constants/Types.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {ValidationLib} from './ValidationLib.sol';\nimport {IPublicationActionModule} from '../interfaces/IPublicationActionModule.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {Events} from './constants/Events.sol';\n\nlibrary ActionLib {\n    function act(\n        Types.PublicationActionParams calldata publicationActionParams,\n        address transactionExecutor,\n        address actorProfileOwner\n    ) external returns (bytes memory) {\n        ValidationLib.validateNotBlocked({\n            profile: publicationActionParams.actorProfileId,\n            byProfile: publicationActionParams.publicationActedProfileId\n        });\n\n        Types.Publication storage _actedOnPublication = StorageLib.getPublication(\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId\n        );\n\n        if (!_isActionEnabled(_actedOnPublication, publicationActionParams.actionModuleAddress)) {\n            // This will also revert for:\n            //   - Non-existent action modules\n            //   - Non-existent publications\n            //   - Legacy V1 publications\n            // Because the storage will be empty.\n            revert Errors.ActionNotAllowed();\n        }\n\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\n            publicationActionParams.referrerProfileIds,\n            publicationActionParams.referrerPubIds,\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId\n        );\n\n        bytes memory actionModuleReturnData = IPublicationActionModule(publicationActionParams.actionModuleAddress)\n            .processPublicationAction(\n                Types.ProcessActionParams({\n                    publicationActedProfileId: publicationActionParams.publicationActedProfileId,\n                    publicationActedId: publicationActionParams.publicationActedId,\n                    actorProfileId: publicationActionParams.actorProfileId,\n                    actorProfileOwner: actorProfileOwner,\n                    transactionExecutor: transactionExecutor,\n                    referrerProfileIds: publicationActionParams.referrerProfileIds,\n                    referrerPubIds: publicationActionParams.referrerPubIds,\n                    referrerPubTypes: referrerPubTypes,\n                    actionModuleData: publicationActionParams.actionModuleData\n                })\n            );\n        emit Events.Acted(publicationActionParams, actionModuleReturnData, transactionExecutor, block.timestamp);\n\n        return actionModuleReturnData;\n    }\n\n    function _isActionEnabled(\n        Types.Publication storage _publication,\n        address actionModuleAddress\n    ) private view returns (bool) {\n        return _publication.actionModuleEnabled[actionModuleAddress];\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/constants/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary Errors {\n    error CannotInitImplementation();\n    error Initialized();\n    error SignatureExpired();\n    error SignatureInvalid();\n    error InvalidOwner();\n    error NotOwnerOrApproved();\n    error NotHub();\n    error TokenDoesNotExist();\n    error NotGovernance();\n    error NotGovernanceOrEmergencyAdmin();\n    error EmergencyAdminCanOnlyPauseFurther();\n    error NotProfileOwner();\n    error PublicationDoesNotExist();\n    error CallerNotFollowNFT();\n    error CallerNotCollectNFT(); // Legacy\n    error ArrayMismatch();\n    error NotWhitelisted();\n    error NotRegistered();\n    error InvalidParameter();\n    error ExecutorInvalid();\n    error Blocked();\n    error SelfBlock();\n    error NotFollowing();\n    error SelfFollow();\n    error InvalidReferrer();\n    error InvalidPointedPub();\n    error NonERC721ReceiverImplementer();\n    error AlreadyEnabled();\n\n    // Module Errors\n    error InitParamsInvalid();\n    error ActionNotAllowed();\n\n    error CollectNotAllowed(); // Used in LegacyCollectLib (pending deprecation)\n\n    // MultiState Errors\n    error Paused();\n    error PublishingPaused();\n\n    // Profile Guardian Errors\n    error GuardianEnabled();\n    error NotEOA();\n    error DisablingAlreadyTriggered();\n\n    // Migration Errors\n    error NotMigrationAdmin();\n\n    error NotAllowed();\n}\n"
    },
    "lens-modules/contracts/libraries/constants/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from './Types.sol';\n\nlibrary Events {\n    /**\n     * @dev Emitted when the NFT contract's name and symbol are set at initialization.\n     *\n     * @param name The NFT name set.\n     * @param symbol The NFT symbol set.\n     * @param timestamp The current block timestamp.\n     */\n    event BaseInitialized(string name, string symbol, uint256 timestamp);\n\n    /**\n     * @dev Emitted when the hub state is set.\n     *\n     * @param caller The caller who set the state.\n     * @param prevState The previous protocol state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\n     * @param newState The newly set state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\n     * @param timestamp The current block timestamp.\n     */\n    event StateSet(\n        address indexed caller,\n        Types.ProtocolState indexed prevState,\n        Types.ProtocolState indexed newState,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the governance address is changed. We emit the caller even though it should be the previous\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\n     *\n     * @param caller The caller who set the governance address.\n     * @param prevGovernance The previous governance address.\n     * @param newGovernance The new governance address set.\n     * @param timestamp The current block timestamp.\n     */\n    event GovernanceSet(\n        address indexed caller,\n        address indexed prevGovernance,\n        address indexed newGovernance,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the emergency admin is changed. We emit the caller even though it should be the previous\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\n     *\n     * @param caller The caller who set the emergency admin address.\n     * @param oldEmergencyAdmin The previous emergency admin address.\n     * @param newEmergencyAdmin The new emergency admin address set.\n     * @param timestamp The current block timestamp.\n     */\n    event EmergencyAdminSet(\n        address indexed caller,\n        address indexed oldEmergencyAdmin,\n        address indexed newEmergencyAdmin,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a profile creator is added to or removed from the whitelist.\n     *\n     * @param profileCreator The address of the profile creator.\n     * @param whitelisted Whether or not the profile creator is being added to the whitelist.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileCreatorWhitelisted(address indexed profileCreator, bool indexed whitelisted, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a profile is created.\n     *\n     * @param profileId The newly created profile's token ID.\n     * @param creator The profile creator, who created the token with the given profile ID.\n     * @param to The address receiving the profile with the given profile ID.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileCreated(uint256 indexed profileId, address indexed creator, address indexed to, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a delegated executors configuration is changed.\n     *\n     * @param delegatorProfileId The ID of the profile for which the delegated executor was changed.\n     * @param configNumber The number of the configuration where the executor approval state was set.\n     * @param delegatedExecutors The array of delegated executors whose approval was set for.\n     * @param approvals The array of booleans indicating the corresponding executor new approval status.\n     * @param timestamp The current block timestamp.\n     */\n    event DelegatedExecutorsConfigChanged(\n        uint256 indexed delegatorProfileId,\n        uint256 indexed configNumber,\n        address[] delegatedExecutors,\n        bool[] approvals,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a delegated executors configuration is applied.\n     *\n     * @param delegatorProfileId The ID of the profile applying the configuration.\n     * @param configNumber The number of the configuration applied.\n     * @param timestamp The current block timestamp.\n     */\n    event DelegatedExecutorsConfigApplied(\n        uint256 indexed delegatorProfileId,\n        uint256 indexed configNumber,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a profile's follow module is set.\n     *\n     * @param profileId The profile's token ID.\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\n     * @param followModuleInitData The data passed to the follow module, if any.\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is ABI-encoded\n     * and depends on the follow module chosen.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowModuleSet(\n        uint256 indexed profileId,\n        address followModule,\n        bytes followModuleInitData,\n        bytes followModuleReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a post is successfully published.\n     *\n     * @param postParams The parameters passed to create the post publication.\n     * @param pubId The publication ID assigned to the created post.\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\n     * publication. This is ABI-encoded and depends on the action module chosen.\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\n     * ABI-encoded and depends on the reference module chosen.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event PostCreated(\n        Types.PostParams postParams,\n        uint256 indexed pubId,\n        bytes[] actionModulesInitReturnDatas,\n        bytes referenceModuleInitReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a comment is successfully published.\n     *\n     * @param commentParams The parameters passed to create the comment publication.\n     * @param pubId The publication ID assigned to the created comment.\n     * @param referenceModuleReturnData The data returned by the commented publication reference module's\n     * processComment function, if the commented publication has a reference module set.\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\n     * publication. This is ABI-encoded and depends on the action module chosen.\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\n     * ABI-encoded and depends on the reference module chosen.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event CommentCreated(\n        Types.CommentParams commentParams,\n        uint256 indexed pubId,\n        bytes referenceModuleReturnData,\n        bytes[] actionModulesInitReturnDatas,\n        bytes referenceModuleInitReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a mirror is successfully published.\n     *\n     * @param mirrorParams The parameters passed to create the mirror publication.\n     * @param pubId The publication ID assigned to the created mirror.\n     * @param referenceModuleReturnData The data returned by the mirrored publication reference module's\n     * processMirror function, if the mirrored publication has a reference module set.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event MirrorCreated(\n        Types.MirrorParams mirrorParams,\n        uint256 indexed pubId,\n        bytes referenceModuleReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a quote is successfully published.\n     *\n     * @param quoteParams The parameters passed to create the quote publication.\n     * @param pubId The publication ID assigned to the created quote.\n     * @param referenceModuleReturnData The data returned by the quoted publication reference module's\n     * processQuote function, if the quoted publication has a reference module set.\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\n     * publication. This is ABI-encoded and depends on the action module chosen.\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\n     * ABI-encoded and depends on the reference module chosen.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event QuoteCreated(\n        Types.QuoteParams quoteParams,\n        uint256 indexed pubId,\n        bytes referenceModuleReturnData,\n        bytes[] actionModulesInitReturnDatas,\n        bytes referenceModuleInitReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a followNFT clone is deployed using a lazy deployment pattern.\n     *\n     * @param profileId The token ID of the profile to which this followNFT is associated.\n     * @param followNFT The address of the newly deployed followNFT clone.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTDeployed(uint256 indexed profileId, address indexed followNFT, uint256 timestamp);\n    /**\n     * @dev Emitted when a collectNFT clone is deployed using a lazy deployment pattern.\n     *\n     * @param profileId The publisher's profile token ID.\n     * @param pubId The publication associated with the newly deployed collectNFT clone's ID.\n     * @param collectNFT The address of the newly deployed collectNFT clone.\n     * @param timestamp The current block timestamp.\n     */\n    event LegacyCollectNFTDeployed(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        address indexed collectNFT,\n        uint256 timestamp\n    );\n    /**\n     * @dev Emitted upon a successful action.\n     *\n     * @param publicationActionParams The parameters passed to act on a publication.\n     * @param actionModuleReturnData The data returned from the action modules. This is ABI-encoded and the format\n     * depends on the action module chosen.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event Acted(\n        Types.PublicationActionParams publicationActionParams,\n        bytes actionModuleReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful follow operation.\n     *\n     * @param followerProfileId The ID of the profile that executed the follow.\n     * @param idOfProfileFollowed The ID of the profile that was followed.\n     * @param followTokenIdAssigned The ID of the follow token assigned to the follower.\n     * @param followModuleData The data to pass to the follow module, if any.\n     * @param processFollowModuleReturnData The data returned by the followed profile follow module's processFollow\n     * function, if the followed profile has a reference module set.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The timestamp of the follow operation.\n     */\n    event Followed(\n        uint256 indexed followerProfileId,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenIdAssigned,\n        bytes followModuleData,\n        bytes processFollowModuleReturnData,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful unfollow operation.\n     *\n     * @param unfollowerProfileId The ID of the profile that executed the unfollow.\n     * @param idOfProfileUnfollowed The ID of the profile that was unfollowed.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The timestamp of the unfollow operation.\n     */\n    event Unfollowed(\n        uint256 indexed unfollowerProfileId,\n        uint256 idOfProfileUnfollowed,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful block, through a block status setting operation.\n     *\n     * @param byProfileId The ID of the profile that executed the block status change.\n     * @param idOfProfileBlocked The ID of the profile whose block status have been set to blocked.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The timestamp of the block operation.\n     */\n    event Blocked(\n        uint256 indexed byProfileId,\n        uint256 idOfProfileBlocked,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful unblock, through a block status setting operation.\n     *\n     * @param byProfileId The ID of the profile that executed the block status change.\n     * @param idOfProfileUnblocked The ID of the profile whose block status have been set to unblocked.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The timestamp of the unblock operation.\n     */\n    event Unblocked(\n        uint256 indexed byProfileId,\n        uint256 idOfProfileUnblocked,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted via callback when a collectNFT is transferred.\n     *\n     * @param profileId The token ID of the profile associated with the collectNFT being transferred.\n     * @param pubId The publication ID associated with the collectNFT being transferred.\n     * @param collectNFTId The collectNFT being transferred's token ID.\n     * @param from The address the collectNFT is being transferred from.\n     * @param to The address the collectNFT is being transferred to.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectNFTTransferred(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        uint256 indexed collectNFTId,\n        address from,\n        address to,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when the treasury address is set.\n     *\n     * @param prevTreasury The previous treasury address.\n     * @param newTreasury The new treasury address set.\n     * @param timestamp The current block timestamp.\n     */\n    event TreasurySet(address indexed prevTreasury, address indexed newTreasury, uint256 timestamp);\n\n    /**\n     * @notice Emitted when the treasury fee is set.\n     *\n     * @param prevTreasuryFee The previous treasury fee in BPS.\n     * @param newTreasuryFee The new treasury fee in BPS.\n     * @param timestamp The current block timestamp.\n     */\n    event TreasuryFeeSet(uint16 indexed prevTreasuryFee, uint16 indexed newTreasuryFee, uint256 timestamp);\n\n    /**\n     * @dev Emitted when the metadata associated with a profile is set in the `LensPeriphery`.\n     *\n     * @param profileId The profile ID the metadata is set for.\n     * @param metadata The metadata set for the profile and user.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileMetadataSet(\n        uint256 indexed profileId,\n        string metadata,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when an address' Profile Guardian state change is triggered.\n     *\n     * @param wallet The address whose Token Guardian state change is being triggered.\n     * @param enabled True if the Token Guardian is being enabled, false if it is being disabled.\n     * @param tokenGuardianDisablingTimestamp The UNIX timestamp when disabling the Token Guardian will take effect,\n     * if disabling it. Zero if the protection is being enabled.\n     * @param timestamp The UNIX timestamp of the change being triggered.\n     */\n    event TokenGuardianStateChanged(\n        address indexed wallet,\n        bool indexed enabled,\n        uint256 tokenGuardianDisablingTimestamp,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a signer's nonce is used and, as a consequence, the next available nonce is updated.\n     *\n     * @param signer The signer whose next available nonce was updated.\n     * @param nonce The next available nonce that can be used to execute a meta-tx successfully.\n     * @param timestamp The UNIX timestamp of the nonce being used.\n     */\n    event NonceUpdated(address indexed signer, uint256 nonce, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a collection's token URI is updated.\n     * @param fromTokenId The ID of the smallest token that requires its token URI to be refreshed.\n     * @param toTokenId The ID of the biggest token that requires its token URI to be refreshed. Max uint256 to refresh\n     * all of them.\n     */\n    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\n}\n"
    },
    "lens-modules/contracts/libraries/constants/Typehash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary Typehash {\n\n    bytes32 constant ACT = keccak256('Act(uint256 publicationActedProfileId,uint256 publicationActedId,uint256 actorProfileId,uint256[] referrerProfileIds,uint256[] referrerPubIds,address actionModuleAddress,bytes actionModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant CHANGE_DELEGATED_EXECUTORS_CONFIG = keccak256('ChangeDelegatedExecutorsConfig(uint256 delegatorProfileId,address[] delegatedExecutors,bool[] approvals,uint64 configNumber,bool switchToGivenConfig,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant COLLECT_LEGACY = keccak256('CollectLegacy(uint256 publicationCollectedProfileId,uint256 publicationCollectedId,uint256 collectorProfileId,uint256 referrerProfileId,uint256 referrerPubId,bytes collectModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant COMMENT = keccak256('Comment(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant EIP712_DOMAIN = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n\n    bytes32 constant FOLLOW = keccak256('Follow(uint256 followerProfileId,uint256[] idsOfProfilesToFollow,uint256[] followTokenIds,bytes[] datas,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant MIRROR = keccak256('Mirror(uint256 profileId,string metadataURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant POST = keccak256('Post(uint256 profileId,string contentURI,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant QUOTE = keccak256('Quote(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_BLOCK_STATUS = keccak256('SetBlockStatus(uint256 byProfileId,uint256[] idsOfProfilesToSetBlockStatus,bool[] blockStatus,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_FOLLOW_MODULE = keccak256('SetFollowModule(uint256 profileId,address followModule,bytes followModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_PROFILE_METADATA_URI = keccak256('SetProfileMetadataURI(uint256 profileId,string metadataURI,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant UNFOLLOW = keccak256('Unfollow(uint256 unfollowerProfileId,uint256[] idsOfProfilesToUnfollow,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant PUBLIC_PAID_ACT = keccak256('PublicPaidAct(uint256 publicationActedProfileId,uint256 publicationActedId,uint256 actorProfileId,uint256[] referrerProfileIds,uint256[] referrerPubIds,address actionModuleAddress,bytes actionModuleData,address currency,uint256 amount,address approveTo,uint256 nonce,uint256 deadline)');\n}\n"
    },
    "lens-modules/contracts/libraries/constants/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title Types\n * @author Lens Protocol\n *\n * @notice A standard library of data types used throughout the Lens Protocol.\n */\nlibrary Types {\n    /**\n     * @notice ERC721Timestamped storage. Contains the owner address and the mint timestamp for every NFT.\n     *\n     * Note: Instead of the owner address in the _tokenOwners private mapping, we now store it in the\n     * _tokenData mapping, alongside the mint timestamp.\n     *\n     * @param owner The token owner.\n     * @param mintTimestamp The mint timestamp.\n     */\n    struct TokenData {\n        address owner;\n        uint96 mintTimestamp;\n    }\n\n    /**\n     * @notice A struct containing token follow-related data.\n     *\n     * @param followerProfileId The ID of the profile using the token to follow.\n     * @param originalFollowTimestamp The timestamp of the first follow performed with the token.\n     * @param followTimestamp The timestamp of the current follow, if a profile is using the token to follow.\n     * @param profileIdAllowedToRecover The ID of the profile allowed to recover the follow ID, if any.\n     */\n    struct FollowData {\n        uint160 followerProfileId;\n        uint48 originalFollowTimestamp;\n        uint48 followTimestamp;\n        uint256 profileIdAllowedToRecover;\n    }\n\n    /**\n     * @notice An enum containing the different states the protocol can be in, limiting certain actions.\n     *\n     * @param Unpaused The fully unpaused state.\n     * @param PublishingPaused The state where only publication creation functions are paused.\n     * @param Paused The fully paused state.\n     */\n    enum ProtocolState {\n        Unpaused,\n        PublishingPaused,\n        Paused\n    }\n\n    /**\n     * @notice An enum specifically used in a helper function to easily retrieve the publication type for integrations.\n     *\n     * @param Nonexistent An indicator showing the queried publication does not exist.\n     * @param Post A standard post, having an URI, action modules and no pointer to another publication.\n     * @param Comment A comment, having an URI, action modules and a pointer to another publication.\n     * @param Mirror A mirror, having a pointer to another publication, but no URI or action modules.\n     * @param Quote A quote, having an URI, action modules, and a pointer to another publication.\n     */\n    enum PublicationType {\n        Nonexistent,\n        Post,\n        Comment,\n        Mirror,\n        Quote\n    }\n\n    /**\n     * @notice A struct containing the necessary information to reconstruct an EIP-712 typed data signature.\n     *\n     * @param signer The address of the signer. Specially needed as a parameter to support EIP-1271.\n     * @param v The signature's recovery parameter.\n     * @param r The signature's r parameter.\n     * @param s The signature's s parameter.\n     * @param deadline The signature's deadline.\n     */\n    struct EIP712Signature {\n        address signer;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice A struct containing profile data.\n     *\n     * @param pubCount The number of publications made to this profile.\n     * @param followModule The address of the current follow module in use by this profile, can be address(0) in none.\n     * @param followNFT The address of the followNFT associated with this profile. It can be address(0) if the\n     * profile has not been followed yet, as the collection is lazy-deployed upon the first follow.\n     * @param __DEPRECATED__handle DEPRECATED in V2: handle slot, was replaced with LensHandles.\n     * @param __DEPRECATED__imageURI DEPRECATED in V2: The URI to be used for the profile image.\n     * @param __DEPRECATED__followNFTURI DEPRECATED in V2: The URI used for the follow NFT image.\n     * @param metadataURI MetadataURI is used to store the profile's metadata, for example: displayed name, description,\n     * interests, etc.\n     */\n    struct Profile {\n        uint256 pubCount; // offset 0\n        address followModule; // offset 1\n        address followNFT; // offset 2\n        string __DEPRECATED__handle; // offset 3\n        string __DEPRECATED__imageURI; // offset 4\n        string __DEPRECATED__followNFTURI; // Deprecated in V2 as we have a common tokenURI for all Follows, offset 5\n        string metadataURI; // offset 6\n    }\n\n    /**\n     * @notice A struct containing publication data.\n     *\n     * @param pointedProfileId The profile token ID to point the publication to.\n     * @param pointedPubId The publication ID to point the publication to.\n     * These are used to implement the \"reference\" feature of the platform and is used in:\n     * - Mirrors\n     * - Comments\n     * - Quotes\n     * There are (0,0) if the publication is not pointing to any other publication (i.e. the publication is a Post).\n     * @param contentURI The URI to set for the content of publication (can be ipfs, arweave, http, etc).\n     * @param referenceModule Reference module associated with this profile, if any.\n     * @param __DEPRECATED__collectModule Collect module associated with this publication, if any. Deprecated in V2.\n     * @param __DEPRECATED__collectNFT Collect NFT associated with this publication, if any. Deprecated in V2.\n     * @param pubType The type of publication, can be Nonexistent, Post, Comment, Mirror or Quote.\n     * @param rootProfileId The profile ID of the root post (to determine if comments/quotes and mirrors come from it).\n     * Posts, V1 publications and publications rooted in V1 publications don't have it set.\n     * @param rootPubId The publication ID of the root post (to determine if comments/quotes and mirrors come from it).\n     * Posts, V1 publications and publications rooted in V1 publications don't have it set.\n     * @param actionModuleEnabled The action modules enabled in a given publication.\n     */\n    struct Publication {\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        string contentURI;\n        address referenceModule;\n        address __DEPRECATED__collectModule; // Deprecated in V2\n        address __DEPRECATED__collectNFT; // Deprecated in V2\n        // Added in Lens V2, so these will be zero for old publications:\n        PublicationType pubType;\n        uint256 rootProfileId;\n        uint256 rootPubId;\n        mapping(address => bool) actionModuleEnabled;\n    }\n\n    struct PublicationMemory {\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        string contentURI;\n        address referenceModule;\n        address __DEPRECATED__collectModule; // Deprecated in V2\n        address __DEPRECATED__collectNFT; // Deprecated in V2\n        // Added in Lens V2, so these will be zero for old publications:\n        PublicationType pubType;\n        uint256 rootProfileId;\n        uint256 rootPubId;\n        // bytes32 __ACTION_MODULE_ENABLED_MAPPING; // Mappings are not supported in memory.\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `createProfile()` function.\n     *\n     * @param to The address receiving the profile.\n     * @param followModule The follow module to use, can be the zero address.\n     * @param followModuleInitData The follow module initialization data, if any.\n     */\n    struct CreateProfileParams {\n        address to;\n        address followModule;\n        bytes followModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `post()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param actionModules The action modules to set for this new publication.\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct PostParams {\n        uint256 profileId;\n        string contentURI;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `comment()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param pointedProfileId The profile token ID to point the comment to.\n     * @param pointedPubId The publication ID to point the comment to.\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param actionModules The action modules to set for this new publication.\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct CommentParams {\n        uint256 profileId;\n        string contentURI;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `quote()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param pointedProfileId The profile token ID of the publication author that is quoted.\n     * @param pointedPubId The publication ID that is quoted.\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param actionModules The action modules to set for this new publication.\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct QuoteParams {\n        uint256 profileId;\n        string contentURI;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `comment()` or `quote()` internal functions.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param pointedProfileId The profile token ID of the publication author that is commented on/quoted.\n     * @param pointedPubId The publication ID that is commented on/quoted.\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param actionModules The action modules to set for this new publication.\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct ReferencePubParams {\n        uint256 profileId;\n        string contentURI;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `mirror()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param metadataURI the URI containing metadata attributes to attach to this mirror publication.\n     * @param pointedProfileId The profile token ID to point the mirror to.\n     * @param pointedPubId The publication ID to point the mirror to.\n     * @param referenceModuleData The data passed to the reference module.\n     */\n    struct MirrorParams {\n        uint256 profileId;\n        string metadataURI;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n    }\n\n    /**\n     * Deprecated in V2: Will be removed after some time after upgrading to V2.\n     * @notice A struct containing the parameters required for the legacy `collect()` function.\n     * @dev The referrer can only be a mirror of the publication being collected.\n     *\n     * @param publicationCollectedProfileId The token ID of the profile that published the publication to collect.\n     * @param publicationCollectedId The publication to collect's publication ID.\n     * @param collectorProfileId The collector profile.\n     * @param referrerProfileId The ID of a profile that authored a mirror that helped discovering the collected pub.\n     * @param referrerPubId The ID of the mirror that helped discovering the collected pub.\n     * @param collectModuleData The arbitrary data to pass to the collectModule if needed.\n     */\n    struct LegacyCollectParams {\n        uint256 publicationCollectedProfileId;\n        uint256 publicationCollectedId;\n        uint256 collectorProfileId;\n        uint256 referrerProfileId;\n        uint256 referrerPubId;\n        bytes collectModuleData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `action()` function.\n     *\n     * @param publicationActedProfileId The token ID of the profile that published the publication to action.\n     * @param publicationActedId The publication to action's publication ID.\n     * @param actorProfileId The actor profile.\n     * @param referrerProfileId\n     * @param referrerPubId\n     * @param actionModuleAddress\n     * @param actionModuleData The arbitrary data to pass to the actionModule if needed.\n     */\n    struct PublicationActionParams {\n        uint256 publicationActedProfileId;\n        uint256 publicationActedId;\n        uint256 actorProfileId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        address actionModuleAddress;\n        bytes actionModuleData;\n    }\n\n    struct ProcessActionParams {\n        uint256 publicationActedProfileId;\n        uint256 publicationActedId;\n        uint256 actorProfileId;\n        address actorProfileOwner;\n        address transactionExecutor;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        Types.PublicationType[] referrerPubTypes;\n        bytes actionModuleData;\n    }\n\n    struct ProcessCommentParams {\n        uint256 profileId;\n        uint256 pubId;\n        address transactionExecutor;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        Types.PublicationType[] referrerPubTypes;\n        bytes data;\n    }\n\n    struct ProcessQuoteParams {\n        uint256 profileId;\n        uint256 pubId;\n        address transactionExecutor;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        Types.PublicationType[] referrerPubTypes;\n        bytes data;\n    }\n\n    struct ProcessMirrorParams {\n        uint256 profileId;\n        uint256 pubId;\n        address transactionExecutor;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        Types.PublicationType[] referrerPubTypes;\n        bytes data;\n    }\n\n    /**\n     * @notice A struct containing a profile's delegated executors configuration.\n     *\n     * @param isApproved Tells when an address is approved as delegated executor in the given configuration number.\n     * @param configNumber Current configuration number in use.\n     * @param prevConfigNumber Previous configuration number set, before switching to the current one.\n     * @param maxConfigNumberSet Maximum configuration number ever used.\n     */\n    struct DelegatedExecutorsConfig {\n        mapping(uint256 => mapping(address => bool)) isApproved; // isApproved[configNumber][delegatedExecutor]\n        uint64 configNumber;\n        uint64 prevConfigNumber;\n        uint64 maxConfigNumberSet;\n    }\n\n    struct TreasuryData {\n        address treasury;\n        uint16 treasuryFeeBPS;\n    }\n\n    struct MigrationParams {\n        address lensHandlesAddress;\n        address tokenHandleRegistryAddress;\n        address legacyFeeFollowModule;\n        address legacyProfileFollowModule;\n        address newFeeFollowModule;\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/FollowLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ValidationLib} from './ValidationLib.sol';\nimport {Types} from './constants/Types.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {Events} from './constants/Events.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {FollowNFTProxy} from '../base/upgradeability/FollowNFTProxy.sol';\n\nlibrary FollowLib {\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata followModuleDatas\n    ) external returns (uint256[] memory) {\n        if (\n            idsOfProfilesToFollow.length != followTokenIds.length ||\n            idsOfProfilesToFollow.length != followModuleDatas.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256[] memory followTokenIdsAssigned = new uint256[](idsOfProfilesToFollow.length);\n        uint256 i;\n        while (i < idsOfProfilesToFollow.length) {\n            ValidationLib.validateProfileExists({profileId: idsOfProfilesToFollow[i]});\n\n            ValidationLib.validateNotBlocked({\n                profile: followerProfileId,\n                byProfile: idsOfProfilesToFollow[i],\n                unidirectionalCheck: true // We allow to follow a blocked profile. Rest of interactions are restricted.\n            });\n\n            if (followerProfileId == idsOfProfilesToFollow[i]) {\n                revert Errors.SelfFollow();\n            }\n\n            followTokenIdsAssigned[i] = _follow({\n                followerProfileId: followerProfileId,\n                transactionExecutor: transactionExecutor,\n                idOfProfileToFollow: idsOfProfilesToFollow[i],\n                followTokenId: followTokenIds[i],\n                followModuleData: followModuleDatas[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n        return followTokenIdsAssigned;\n    }\n\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n\n            address followNFT = StorageLib.getProfile(idOfProfileToUnfollow).followNFT;\n\n            // We don't validate the profile exists because we want to allow unfollowing a burnt profile.\n            // Because, if the profile never existed, followNFT will be address(0) and the call will revert.\n            if (followNFT == address(0)) {\n                revert Errors.NotFollowing();\n            }\n\n            IFollowNFT(followNFT).unfollow(unfollowerProfileId);\n\n            emit Events.Unfollowed(unfollowerProfileId, idOfProfileToUnfollow, transactionExecutor, block.timestamp);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) internal view returns (bool) {\n        address followNFT = StorageLib.getProfile(followedProfileId).followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /**\n     * @notice Deploys the given profile's Follow NFT contract.\n     *\n     * @param profileId The token ID of the profile which Follow NFT should be deployed.\n     *\n     * @return address The address of the deployed Follow NFT contract.\n     */\n    function _deployFollowNFT(uint256 profileId) private returns (address) {\n        bytes memory functionData = abi.encodeCall(IFollowNFT.initialize, profileId);\n        address followNFT = address(new FollowNFTProxy(functionData));\n        emit Events.FollowNFTDeployed(profileId, followNFT, block.timestamp);\n\n        return followNFT;\n    }\n\n    function _follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 idOfProfileToFollow,\n        uint256 followTokenId,\n        bytes calldata followModuleData\n    ) private returns (uint256) {\n        Types.Profile storage _profileToFollow = StorageLib.getProfile(idOfProfileToFollow);\n\n        address followNFT = _profileToFollow.followNFT;\n        if (followNFT == address(0)) {\n            followNFT = _deployFollowNFT(idOfProfileToFollow);\n            _profileToFollow.followNFT = followNFT;\n        }\n\n        return\n            _processFollow(\n                ProcessFollowParams({\n                    followNFT: followNFT,\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    idOfProfileToFollow: idOfProfileToFollow,\n                    followTokenId: followTokenId,\n                    followModule: _profileToFollow.followModule,\n                    followModuleData: followModuleData\n                })\n            );\n    }\n\n    // Struct defined for the sole purpose of avoiding 'stack too deep' error.\n    struct ProcessFollowParams {\n        address followNFT;\n        uint256 followerProfileId;\n        address transactionExecutor;\n        uint256 idOfProfileToFollow;\n        uint256 followTokenId;\n        address followModule;\n        bytes followModuleData;\n    }\n\n    function _processFollow(ProcessFollowParams memory processFollowParams) private returns (uint256) {\n        uint256 followTokenIdAssigned = IFollowNFT(processFollowParams.followNFT).follow({\n            followerProfileId: processFollowParams.followerProfileId,\n            transactionExecutor: processFollowParams.transactionExecutor,\n            followTokenId: processFollowParams.followTokenId\n        });\n\n        bytes memory processFollowModuleReturnData;\n        if (processFollowParams.followModule != address(0)) {\n            processFollowModuleReturnData = IFollowModule(processFollowParams.followModule).processFollow(\n                processFollowParams.followerProfileId,\n                processFollowParams.followTokenId,\n                processFollowParams.transactionExecutor,\n                processFollowParams.idOfProfileToFollow,\n                processFollowParams.followModuleData\n            );\n        }\n\n        emit Events.Followed(\n            processFollowParams.followerProfileId,\n            processFollowParams.idOfProfileToFollow,\n            followTokenIdAssigned,\n            processFollowParams.followModuleData,\n            processFollowModuleReturnData,\n            processFollowParams.transactionExecutor,\n            block.timestamp\n        );\n\n        return followTokenIdAssigned;\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/GovernanceLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from './constants/Types.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {Events} from './constants/Events.sol';\n\nlibrary GovernanceLib {\n    uint16 internal constant BPS_MAX = 10000;\n\n    /**\n     * @notice Sets the governance address.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external {\n        address prevGovernance = StorageLib.getGovernance();\n        StorageLib.setGovernance(newGovernance);\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the emergency admin address.\n     *\n     * @param newEmergencyAdmin The new governance address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external {\n        address prevEmergencyAdmin = StorageLib.getEmergencyAdmin();\n        StorageLib.setEmergencyAdmin(newEmergencyAdmin);\n        emit Events.EmergencyAdminSet(msg.sender, prevEmergencyAdmin, newEmergencyAdmin, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the protocol state, only meant to be called at initialization since\n     * this does not validate the caller.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function initState(Types.ProtocolState newState) external {\n        _setState(newState);\n    }\n\n    /**\n     * @notice Sets the protocol state and validates the caller. The emergency admin can only\n     * pause further (Unpaused => PublishingPaused => Paused). Whereas governance can set any\n     * state.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n\n        if (msg.sender != StorageLib.getGovernance()) {\n            // If the sender is the emergency admin, prevent them from reducing restrictions.\n            if (msg.sender == StorageLib.getEmergencyAdmin()) {\n                if (newState <= prevState) {\n                    revert Errors.EmergencyAdminCanOnlyPauseFurther();\n                }\n            } else {\n                revert Errors.NotGovernanceOrEmergencyAdmin();\n            }\n        }\n    }\n\n    function _setState(Types.ProtocolState newState) private returns (Types.ProtocolState) {\n        Types.ProtocolState prevState = StorageLib.getState();\n        StorageLib.setState(newState);\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n        return prevState;\n    }\n\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external {\n        StorageLib.profileCreatorWhitelisted()[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    function setTreasury(address newTreasury) internal {\n        if (newTreasury == address(0)) {\n            revert Errors.InitParamsInvalid();\n        }\n        Types.TreasuryData storage _treasuryData = StorageLib.getTreasuryData();\n\n        address prevTreasury = _treasuryData.treasury;\n        _treasuryData.treasury = newTreasury;\n\n        emit Events.TreasurySet(prevTreasury, newTreasury, block.timestamp);\n    }\n\n    function setTreasuryFee(uint16 newTreasuryFee) internal {\n        if (newTreasuryFee >= BPS_MAX / 2) {\n            revert Errors.InitParamsInvalid();\n        }\n        Types.TreasuryData storage _treasuryData = StorageLib.getTreasuryData();\n\n        uint16 prevTreasuryFee = _treasuryData.treasuryFeeBPS;\n        _treasuryData.treasuryFeeBPS = newTreasuryFee;\n\n        emit Events.TreasuryFeeSet(prevTreasuryFee, newTreasuryFee, block.timestamp);\n    }\n\n    function setProfileTokenURIContract(address profileTokenURIContract) external {\n        StorageLib.setProfileTokenURIContract(profileTokenURIContract);\n    }\n\n    function setFollowTokenURIContract(address followTokenURIContract) external {\n        StorageLib.setFollowTokenURIContract(followTokenURIContract);\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/LegacyCollectLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ValidationLib} from './ValidationLib.sol';\nimport {Types} from './constants/Types.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {Events} from './constants/Events.sol';\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {ILegacyCollectModule} from '../interfaces/ILegacyCollectModule.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {FollowLib} from './FollowLib.sol';\n\n/**\n * @title LegacyCollectLib\n * @author Lens Protocol\n * @notice Library containing the logic for legacy collect operation.\n */\nlibrary LegacyCollectLib {\n    using Strings for uint256;\n\n    /**\n     * @dev Emitted upon a successful legacy collect action.\n     *\n     * @param publicationCollectedProfileId The profile ID of the publication being collected.\n     * @param publicationCollectedId The publication ID of the publication being collected.\n     * @param collectorProfileId The profile ID of the profile that collected the publication.\n     * @param transactionExecutor The address of the account that executed the collect transaction.\n     * @param referrerProfileId The profile ID of the referrer, if any. Zero if no referrer.\n     * @param referrerPubId The publication ID of the referrer, if any. Zero if no referrer.\n     * @param collectModule The address of the collect module that was used to collect the publication.\n     * @param collectModuleData The data passed to the collect module's collect action. This is ABI-encoded and depends\n     * on the collect module chosen.\n     * @param tokenId The token ID of the collect NFT that was minted as a collect of the publication.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectedLegacy(\n        uint256 indexed publicationCollectedProfileId,\n        uint256 indexed publicationCollectedId,\n        uint256 indexed collectorProfileId,\n        address transactionExecutor,\n        uint256 referrerProfileId,\n        uint256 referrerPubId,\n        address collectModule,\n        bytes collectModuleData,\n        uint256 tokenId,\n        uint256 timestamp\n    );\n\n    function collect(\n        Types.LegacyCollectParams calldata collectParams,\n        address transactionExecutor,\n        address collectorProfileOwner,\n        address collectNFTImpl\n    ) external returns (uint256) {\n        ValidationLib.validateNotBlocked({\n            profile: collectParams.collectorProfileId,\n            byProfile: collectParams.publicationCollectedProfileId\n        });\n\n        address collectModule;\n        uint256 tokenId;\n        address collectNFT;\n        {\n            Types.Publication storage _collectedPublication = StorageLib.getPublication(\n                collectParams.publicationCollectedProfileId,\n                collectParams.publicationCollectedId\n            );\n            // This is a legacy collect operation, so we get the collect module from the deprecated storage field.\n            collectModule = _collectedPublication.__DEPRECATED__collectModule;\n            if (collectModule == address(0)) {\n                // It doesn't have collect module, thus it cannot be collected (a mirror or non-existent).\n                revert Errors.CollectNotAllowed();\n            }\n\n            if (collectParams.referrerProfileId != 0 || collectParams.referrerPubId != 0) {\n                ValidationLib.validateLegacyCollectReferrer(\n                    collectParams.referrerProfileId,\n                    collectParams.referrerPubId,\n                    collectParams.publicationCollectedProfileId,\n                    collectParams.publicationCollectedId\n                );\n            }\n\n            collectNFT = _getOrDeployCollectNFT(\n                _collectedPublication,\n                collectParams.publicationCollectedProfileId,\n                collectParams.publicationCollectedId,\n                collectNFTImpl\n            );\n            tokenId = ICollectNFT(collectNFT).mint(collectorProfileOwner);\n        }\n\n        _prefillLegacyCollectFollowValidationHelper({\n            profileId: collectParams.publicationCollectedProfileId,\n            collectorProfileId: collectParams.collectorProfileId,\n            collector: transactionExecutor\n        });\n\n        ILegacyCollectModule(collectModule).processCollect({\n            // Legacy collect modules expect referrer profile ID to match the collected pub's author if no referrer set.\n            referrerProfileId: collectParams.referrerProfileId == 0\n                ? collectParams.publicationCollectedProfileId\n                : collectParams.referrerProfileId,\n            // Collect NFT is minted to the `collectorProfileOwner`. Some follow-based constraints are expected to be\n            // broken in legacy collect modules if the `transactionExecutor` does not match the `collectorProfileOwner`.\n            collector: transactionExecutor,\n            profileId: collectParams.publicationCollectedProfileId,\n            pubId: collectParams.publicationCollectedId,\n            data: collectParams.collectModuleData\n        });\n\n        emit CollectedLegacy({\n            publicationCollectedProfileId: collectParams.publicationCollectedProfileId,\n            publicationCollectedId: collectParams.publicationCollectedId,\n            collectorProfileId: collectParams.collectorProfileId,\n            transactionExecutor: transactionExecutor,\n            referrerProfileId: collectParams.referrerProfileId,\n            referrerPubId: collectParams.referrerPubId,\n            collectModule: collectModule,\n            collectModuleData: collectParams.collectModuleData,\n            tokenId: tokenId,\n            timestamp: block.timestamp\n        });\n\n        return tokenId;\n    }\n\n    function _getOrDeployCollectNFT(\n        Types.Publication storage _collectedPublication,\n        uint256 publicationCollectedProfileId,\n        uint256 publicationCollectedId,\n        address collectNFTImpl\n    ) private returns (address) {\n        address collectNFT = _collectedPublication.__DEPRECATED__collectNFT;\n        if (collectNFT == address(0)) {\n            collectNFT = _deployCollectNFT(publicationCollectedProfileId, publicationCollectedId, collectNFTImpl);\n            _collectedPublication.__DEPRECATED__collectNFT = collectNFT;\n        }\n        return collectNFT;\n    }\n\n    /**\n     * @notice Deploys the given profile's Collect NFT contract.\n     *\n     * @param profileId The token ID of the profile which Collect NFT should be deployed.\n     * @param pubId The publication ID of the publication being collected, which Collect NFT should be deployed.\n     * @param collectNFTImpl The address of the Collect NFT implementation that should be used for the deployment.\n     *\n     * @return address The address of the deployed Collect NFT contract.\n     */\n    function _deployCollectNFT(uint256 profileId, uint256 pubId, address collectNFTImpl) private returns (address) {\n        address collectNFT = Clones.clone(collectNFTImpl);\n\n        ICollectNFT(collectNFT).initialize(profileId, pubId);\n        emit Events.LegacyCollectNFTDeployed(profileId, pubId, collectNFT, block.timestamp);\n\n        return collectNFT;\n    }\n\n    function _prefillLegacyCollectFollowValidationHelper(\n        uint256 profileId,\n        uint256 collectorProfileId,\n        address collector\n    ) private {\n        // It's important to set it as zero if not following, as the storage could be dirty from a previous transaction.\n        StorageLib.legacyCollectFollowValidationHelper()[collector] = FollowLib.isFollowing({\n            followerProfileId: collectorProfileId,\n            followedProfileId: profileId\n        })\n            ? profileId\n            : 0;\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/MetaTxLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {ILensERC721} from '../interfaces/ILensERC721.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {Typehash} from '../libraries/constants/Typehash.sol';\nimport {StorageLib} from '../libraries/StorageLib.sol';\nimport {Events} from '../libraries/constants/Events.sol';\n\n/**\n * @title MetaTxLib\n * @author Lens Protocol\n *\n * NOTE: the functions in this contract operate under the assumption that the passed signer is already validated\n * to either be the originator or one of their delegated executors.\n *\n * @dev User nonces are incremented from this library as well.\n */\nlibrary MetaTxLib {\n    string constant EIP712_DOMAIN_VERSION = '2';\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\n    bytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    /**\n     * @dev We store the domain separator and LensHub Proxy address as constants to save gas.\n     *\n     * keccak256(\n     *     abi.encode(\n     *         keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n     *         keccak256('Lens Protocol Profiles'), // Contract Name\n     *         keccak256('2'), // Version Hash\n     *         137, // Polygon Chain ID\n     *         address(0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d) // Verifying Contract Address - LensHub Address\n     *     )\n     * );\n     */\n    bytes32 constant LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR =\n        0xbf9544cf7d7a0338fc4f071be35409a61e51e9caef559305410ad74e16a05f2d;\n\n    address constant LENS_HUB_ADDRESS = 0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d;\n\n    uint256 constant POLYGON_CHAIN_ID = 137;\n\n    function validateSetProfileMetadataURISignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        string calldata metadataURI\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_PROFILE_METADATA_URI,\n                        profileId,\n                        _encodeUsingEip712Rules(metadataURI),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetFollowModuleSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_FOLLOW_MODULE,\n                        profileId,\n                        followModule,\n                        _encodeUsingEip712Rules(followModuleInitData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateChangeDelegatedExecutorsConfigSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        address signer = signature.signer;\n        uint256 deadline = signature.deadline;\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.CHANGE_DELEGATED_EXECUTORS_CONFIG,\n                        delegatorProfileId,\n                        _encodeUsingEip712Rules(delegatedExecutors),\n                        _encodeUsingEip712Rules(approvals),\n                        configNumber,\n                        switchToGivenConfig,\n                        _getNonceIncrementAndEmitEvent(signer),\n                        deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validatePostSignature(\n        Types.EIP712Signature calldata signature,\n        Types.PostParams calldata postParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.POST,\n                        postParams.profileId,\n                        _encodeUsingEip712Rules(postParams.contentURI),\n                        _encodeUsingEip712Rules(postParams.actionModules),\n                        _encodeUsingEip712Rules(postParams.actionModulesInitDatas),\n                        postParams.referenceModule,\n                        _encodeUsingEip712Rules(postParams.referenceModuleInitData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateCommentSignature(\n        Types.EIP712Signature calldata signature,\n        Types.CommentParams calldata commentParams\n    ) external {\n        bytes memory encodedAbi = abi.encode(\n            Typehash.COMMENT,\n            commentParams.profileId,\n            _encodeUsingEip712Rules(commentParams.contentURI),\n            commentParams.pointedProfileId,\n            commentParams.pointedPubId,\n            _encodeUsingEip712Rules(commentParams.referrerProfileIds),\n            _encodeUsingEip712Rules(commentParams.referrerPubIds),\n            _encodeUsingEip712Rules(commentParams.referenceModuleData),\n            _encodeUsingEip712Rules(commentParams.actionModules),\n            _encodeUsingEip712Rules(commentParams.actionModulesInitDatas),\n            commentParams.referenceModule,\n            _encodeUsingEip712Rules(commentParams.referenceModuleInitData),\n            _getNonceIncrementAndEmitEvent(signature.signer),\n            signature.deadline\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateQuoteSignature(\n        Types.EIP712Signature calldata signature,\n        Types.QuoteParams calldata quoteParams\n    ) external {\n        bytes memory encodedAbi = abi.encode(\n            Typehash.QUOTE,\n            quoteParams.profileId,\n            _encodeUsingEip712Rules(quoteParams.contentURI),\n            quoteParams.pointedProfileId,\n            quoteParams.pointedPubId,\n            _encodeUsingEip712Rules(quoteParams.referrerProfileIds),\n            _encodeUsingEip712Rules(quoteParams.referrerPubIds),\n            _encodeUsingEip712Rules(quoteParams.referenceModuleData),\n            _encodeUsingEip712Rules(quoteParams.actionModules),\n            _encodeUsingEip712Rules(quoteParams.actionModulesInitDatas),\n            quoteParams.referenceModule,\n            _encodeUsingEip712Rules(quoteParams.referenceModuleInitData),\n            _getNonceIncrementAndEmitEvent(signature.signer),\n            signature.deadline\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateMirrorSignature(\n        Types.EIP712Signature calldata signature,\n        Types.MirrorParams calldata mirrorParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.MIRROR,\n                        mirrorParams.profileId,\n                        _encodeUsingEip712Rules(mirrorParams.metadataURI),\n                        mirrorParams.pointedProfileId,\n                        mirrorParams.pointedPubId,\n                        _encodeUsingEip712Rules(mirrorParams.referrerProfileIds),\n                        _encodeUsingEip712Rules(mirrorParams.referrerPubIds),\n                        _encodeUsingEip712Rules(mirrorParams.referenceModuleData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateFollowSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.FOLLOW,\n                        followerProfileId,\n                        _encodeUsingEip712Rules(idsOfProfilesToFollow),\n                        _encodeUsingEip712Rules(followTokenIds),\n                        _encodeUsingEip712Rules(datas),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateUnfollowSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.UNFOLLOW,\n                        unfollowerProfileId,\n                        _encodeUsingEip712Rules(idsOfProfilesToUnfollow),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetBlockStatusSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_BLOCK_STATUS,\n                        byProfileId,\n                        _encodeUsingEip712Rules(idsOfProfilesToSetBlockStatus),\n                        _encodeUsingEip712Rules(blockStatus),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateLegacyCollectSignature(\n        Types.EIP712Signature calldata signature,\n        Types.LegacyCollectParams calldata collectParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.COLLECT_LEGACY,\n                        collectParams.publicationCollectedProfileId,\n                        collectParams.publicationCollectedId,\n                        collectParams.collectorProfileId,\n                        collectParams.referrerProfileId,\n                        collectParams.referrerPubId,\n                        _encodeUsingEip712Rules(collectParams.collectModuleData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateActSignature(\n        Types.EIP712Signature calldata signature,\n        Types.PublicationActionParams calldata publicationActionParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.ACT,\n                        publicationActionParams.publicationActedProfileId,\n                        publicationActionParams.publicationActedId,\n                        publicationActionParams.actorProfileId,\n                        _encodeUsingEip712Rules(publicationActionParams.referrerProfileIds),\n                        _encodeUsingEip712Rules(publicationActionParams.referrerPubIds),\n                        publicationActionParams.actionModuleAddress,\n                        _encodeUsingEip712Rules(publicationActionParams.actionModuleData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    /// @dev This function is used to invalidate signatures by incrementing the nonce\n    function incrementNonce(uint8 increment) external {\n        uint256 currentNonce = StorageLib.nonces()[msg.sender];\n        StorageLib.nonces()[msg.sender] = currentNonce + increment;\n        emit Events.NonceUpdated(msg.sender, currentNonce + increment, block.timestamp);\n    }\n\n    function calculateDomainSeparator() internal view returns (bytes32) {\n        if (address(this) == LENS_HUB_ADDRESS && block.chainid == POLYGON_CHAIN_ID) {\n            return LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR;\n        }\n        return\n            keccak256(\n                abi.encode(\n                    Typehash.EIP712_DOMAIN,\n                    keccak256(bytes(ILensERC721(address(this)).name())),\n                    EIP712_DOMAIN_VERSION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\n        if (block.timestamp > signature.deadline) revert Errors.SignatureExpired();\n        // If the expected address is a contract, check the signature there.\n        if (signature.signer.code.length != 0) {\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\n                revert Errors.SignatureInvalid();\n            }\n        } else {\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\n                revert Errors.SignatureInvalid();\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\n        return keccak256(abi.encodePacked('\\x19\\x01', calculateDomainSeparator(), hashedMessage));\n    }\n\n    /**\n     * @dev This fetches a signer's current nonce and increments it so it's ready for the next meta-tx. Also emits\n     * the `NonceUpdated` event.\n     *\n     * @param signer The address to get and increment the nonce for.\n     *\n     * @return uint256 The current nonce for the given signer prior to being incremented.\n     */\n    function _getNonceIncrementAndEmitEvent(address signer) private returns (uint256) {\n        uint256 currentNonce;\n        unchecked {\n            currentNonce = StorageLib.nonces()[signer]++;\n        }\n        emit Events.NonceUpdated(signer, currentNonce + 1, block.timestamp);\n        return currentNonce;\n    }\n\n    function _encodeUsingEip712Rules(bytes[] memory bytesArray) private pure returns (bytes32) {\n        bytes32[] memory bytesArrayEncodedElements = new bytes32[](bytesArray.length);\n        uint256 i;\n        while (i < bytesArray.length) {\n            // A `bytes` type is encoded as its keccak256 hash.\n            bytesArrayEncodedElements[i] = _encodeUsingEip712Rules(bytesArray[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        // An array is encoded as the keccak256 hash of the concatenation of their encoded elements.\n        return _encodeUsingEip712Rules(bytesArrayEncodedElements);\n    }\n\n    function _encodeUsingEip712Rules(bool[] memory boolArray) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(boolArray));\n    }\n\n    function _encodeUsingEip712Rules(address[] memory addressArray) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(addressArray));\n    }\n\n    function _encodeUsingEip712Rules(uint256[] memory uint256Array) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint256Array));\n    }\n\n    function _encodeUsingEip712Rules(bytes32[] memory bytes32Array) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(bytes32Array));\n    }\n\n    function _encodeUsingEip712Rules(string memory stringValue) private pure returns (bytes32) {\n        return keccak256(bytes(stringValue));\n    }\n\n    function _encodeUsingEip712Rules(bytes memory bytesValue) private pure returns (bytes32) {\n        return keccak256(bytesValue);\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/ProfileLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ValidationLib} from './ValidationLib.sol';\nimport {Types} from './constants/Types.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {Events} from './constants/Events.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {IModuleRegistry} from '../interfaces/IModuleRegistry.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\n\nlibrary ProfileLib {\n    function MODULE_REGISTRY() internal view returns (IModuleRegistry) {\n        return IModuleRegistry(ILensHub(address(this)).getModuleRegistry());\n    }\n\n    function ownerOf(uint256 profileId) internal view returns (address) {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        if (profileOwner == address(0)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return profileOwner;\n    }\n\n    function exists(uint256 profileId) internal view returns (bool) {\n        return StorageLib.getTokenData(profileId).owner != address(0);\n    }\n\n    /**\n     * @notice Creates a profile with the given parameters to the given address. Minting happens\n     * in the hub.\n     *\n     * @param createProfileParams The CreateProfileParams struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleInitData: The follow module initialization data, if any\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     */\n    function createProfile(Types.CreateProfileParams calldata createProfileParams, uint256 profileId) external {\n        emit Events.ProfileCreated(profileId, msg.sender, createProfileParams.to, block.timestamp);\n        emit Events.DelegatedExecutorsConfigApplied(profileId, 0, block.timestamp);\n        _setFollowModule(\n            profileId,\n            createProfileParams.followModule,\n            createProfileParams.followModuleInitData,\n            msg.sender // Sender accounts for any initialization requirements (e.g. pay fees, stake asset, etc.).\n        );\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleInitData The data to pass to the follow module for profile initialization.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        address transactionExecutor\n    ) external {\n        _setFollowModule(profileId, followModule, followModuleInitData, transactionExecutor);\n    }\n\n    function setProfileMetadataURI(\n        uint256 profileId,\n        string calldata metadataURI,\n        address transactionExecutor\n    ) external {\n        StorageLib.getProfile(profileId).metadataURI = metadataURI;\n        emit Events.ProfileMetadataSet(profileId, metadataURI, transactionExecutor, block.timestamp);\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address transactionExecutor,\n        address followModule,\n        bytes memory followModuleInitData\n    ) private returns (bytes memory) {\n        MODULE_REGISTRY().verifyModule(followModule, uint256(IModuleRegistry.ModuleType.FOLLOW_MODULE));\n        return IFollowModule(followModule).initializeFollowModule(profileId, transactionExecutor, followModuleInitData);\n    }\n\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        address transactionExecutor\n    ) external {\n        if (idsOfProfilesToSetBlockStatus.length != blockStatus.length) {\n            revert Errors.ArrayMismatch();\n        }\n        address followNFT = StorageLib.getProfile(byProfileId).followNFT;\n        uint256 i;\n        uint256 idOfProfileToSetBlockStatus;\n        bool blockedStatus;\n        mapping(uint256 => bool) storage _blockedStatus = StorageLib.blockedStatus(byProfileId);\n        while (i < idsOfProfilesToSetBlockStatus.length) {\n            idOfProfileToSetBlockStatus = idsOfProfilesToSetBlockStatus[i];\n            ValidationLib.validateProfileExists(idOfProfileToSetBlockStatus);\n            if (byProfileId == idOfProfileToSetBlockStatus) {\n                revert Errors.SelfBlock();\n            }\n            blockedStatus = blockStatus[i];\n            if (followNFT != address(0) && blockedStatus) {\n                bool hasUnfollowed = IFollowNFT(followNFT).processBlock(idOfProfileToSetBlockStatus);\n                if (hasUnfollowed) {\n                    emit Events.Unfollowed(\n                        idOfProfileToSetBlockStatus,\n                        byProfileId,\n                        transactionExecutor,\n                        block.timestamp\n                    );\n                }\n            }\n            _blockedStatus[idOfProfileToSetBlockStatus] = blockedStatus;\n            if (blockedStatus) {\n                emit Events.Blocked(byProfileId, idOfProfileToSetBlockStatus, transactionExecutor, block.timestamp);\n            } else {\n                emit Events.Unblocked(byProfileId, idOfProfileToSetBlockStatus, transactionExecutor, block.timestamp);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function switchToNewFreshDelegatedExecutorsConfig(uint256 profileId) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig({\n            delegatorProfileId: profileId\n        });\n        _changeDelegatedExecutorsConfig({\n            _delegatedExecutorsConfig: _delegatedExecutorsConfig,\n            delegatorProfileId: profileId,\n            delegatedExecutors: new address[](0),\n            approvals: new bool[](0),\n            configNumber: _delegatedExecutorsConfig.maxConfigNumberSet + 1,\n            switchToGivenConfig: true\n        });\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        _changeDelegatedExecutorsConfig(\n            _delegatedExecutorsConfig,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            _delegatedExecutorsConfig.configNumber,\n            false\n        );\n    }\n\n    function changeGivenDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        _changeDelegatedExecutorsConfig(\n            StorageLib.getDelegatedExecutorsConfig(delegatorProfileId),\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function isExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor) external view returns (bool) {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        return _delegatedExecutorsConfig.isApproved[_delegatedExecutorsConfig.configNumber][delegatedExecutor];\n    }\n\n    function _changeDelegatedExecutorsConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint256 delegatorProfileId,\n        address[] memory delegatedExecutors,\n        bool[] memory approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private {\n        if (delegatedExecutors.length != approvals.length) {\n            revert Errors.ArrayMismatch();\n        }\n        bool configSwitched = _prepareStorageToApplyChangesUnderGivenConfig(\n            _delegatedExecutorsConfig,\n            configNumber,\n            switchToGivenConfig\n        );\n        uint256 i;\n        while (i < delegatedExecutors.length) {\n            _delegatedExecutorsConfig.isApproved[configNumber][delegatedExecutors[i]] = approvals[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit Events.DelegatedExecutorsConfigChanged(\n            delegatorProfileId,\n            configNumber,\n            delegatedExecutors,\n            approvals,\n            block.timestamp\n        );\n        if (configSwitched) {\n            emit Events.DelegatedExecutorsConfigApplied(delegatorProfileId, configNumber, block.timestamp);\n        }\n    }\n\n    function _prepareStorageToApplyChangesUnderGivenConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private returns (bool) {\n        uint64 nextAvailableConfigNumber = _delegatedExecutorsConfig.maxConfigNumberSet + 1;\n        if (configNumber > nextAvailableConfigNumber) {\n            revert Errors.InvalidParameter();\n        }\n        bool configSwitched;\n        if (configNumber == nextAvailableConfigNumber) {\n            // The next configuration available is being changed, it must be marked.\n            // Otherwise, on a profile transfer, the next owner can inherit a used/dirty configuration.\n            _delegatedExecutorsConfig.maxConfigNumberSet = nextAvailableConfigNumber;\n            configSwitched = switchToGivenConfig;\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = _delegatedExecutorsConfig.configNumber;\n                _delegatedExecutorsConfig.configNumber = nextAvailableConfigNumber;\n            }\n        } else {\n            // The configuration corresponding to the given number is not a fresh/clean one.\n            uint64 currentConfigNumber = _delegatedExecutorsConfig.configNumber;\n            // If the given configuration matches the one that is already in use, we keep `configSwitched` as `false`.\n            if (configNumber != currentConfigNumber) {\n                configSwitched = switchToGivenConfig;\n            }\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = currentConfigNumber;\n                _delegatedExecutorsConfig.configNumber = configNumber;\n            }\n        }\n        return configSwitched;\n    }\n\n    function _setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        address transactionExecutor\n    ) private {\n        StorageLib.getProfile(profileId).followModule = followModule;\n        bytes memory followModuleReturnData;\n        if (followModule != address(0)) {\n            followModuleReturnData = _initFollowModule(\n                profileId,\n                transactionExecutor,\n                followModule,\n                followModuleInitData\n            );\n        }\n        emit Events.FollowModuleSet(\n            profileId,\n            followModule,\n            followModuleInitData,\n            followModuleReturnData,\n            transactionExecutor,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/PublicationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ValidationLib} from './ValidationLib.sol';\nimport {Types} from './constants/Types.sol';\nimport {Events} from './constants/Events.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\nimport {ILegacyReferenceModule} from '../interfaces/ILegacyReferenceModule.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {IPublicationActionModule} from '../interfaces/IPublicationActionModule.sol';\nimport {IModuleRegistry} from '../interfaces/IModuleRegistry.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\n\nlibrary PublicationLib {\n    function MODULE_REGISTRY() internal view returns (IModuleRegistry) {\n        return IModuleRegistry(ILensHub(address(this)).getModuleRegistry());\n    }\n\n    /**\n     * @notice Publishes a post to a given profile.\n     *\n     * @param postParams The PostParams struct.\n     *\n     * @return uint256 The created publication's pubId.\n     */\n    function post(Types.PostParams calldata postParams, address transactionExecutor) external returns (uint256) {\n        uint256 pubIdAssigned = ++StorageLib.getProfile(postParams.profileId).pubCount;\n\n        Types.Publication storage _post = StorageLib.getPublication(postParams.profileId, pubIdAssigned);\n        _post.contentURI = postParams.contentURI;\n        _post.pubType = Types.PublicationType.Post;\n\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            InitReferenceModuleParams(\n                postParams.profileId,\n                transactionExecutor,\n                pubIdAssigned,\n                postParams.referenceModule,\n                postParams.referenceModuleInitData\n            )\n        );\n\n        bytes[] memory actionModulesReturnDatas = _initPubActionModules(\n            InitActionModuleParams(\n                postParams.profileId,\n                transactionExecutor,\n                pubIdAssigned,\n                postParams.actionModules,\n                postParams.actionModulesInitDatas\n            )\n        );\n\n        emit Events.PostCreated(\n            postParams,\n            pubIdAssigned,\n            actionModulesReturnDatas,\n            referenceModuleReturnData,\n            transactionExecutor,\n            block.timestamp\n        );\n\n        return pubIdAssigned;\n    }\n\n    /**\n     * @notice Publishes a comment to a given profile via signature.\n     *\n     * @param commentParams the CommentParams struct.\n     *\n     * @return uint256 The created publication's pubId.\n     */\n    function comment(\n        Types.CommentParams calldata commentParams,\n        address transactionExecutor\n    ) external returns (uint256) {\n        (\n            uint256 pubIdAssigned,\n            bytes[] memory actionModulesInitReturnDatas,\n            bytes memory referenceModuleInitReturnData,\n            Types.PublicationType[] memory referrerPubTypes\n        ) = _createReferencePublication(\n                _asReferencePubParams(commentParams),\n                transactionExecutor,\n                Types.PublicationType.Comment\n            );\n\n        bytes memory referenceModuleReturnData = _processCommentIfNeeded(\n            commentParams,\n            pubIdAssigned,\n            transactionExecutor,\n            referrerPubTypes\n        );\n\n        emit Events.CommentCreated(\n            commentParams,\n            pubIdAssigned,\n            referenceModuleReturnData,\n            actionModulesInitReturnDatas,\n            referenceModuleInitReturnData,\n            transactionExecutor,\n            block.timestamp\n        );\n\n        return pubIdAssigned;\n    }\n\n    /**\n     * @notice Publishes a mirror to a given profile.\n     *\n     * @param mirrorParams the MirrorParams struct.\n     *\n     * @return uint256 The created publication's pubId.\n     */\n    function mirror(Types.MirrorParams calldata mirrorParams, address transactionExecutor) external returns (uint256) {\n        ValidationLib.validatePointedPub(mirrorParams.pointedProfileId, mirrorParams.pointedPubId);\n        ValidationLib.validateNotBlocked({profile: mirrorParams.profileId, byProfile: mirrorParams.pointedProfileId});\n\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\n            mirrorParams.referrerProfileIds,\n            mirrorParams.referrerPubIds,\n            mirrorParams.pointedProfileId,\n            mirrorParams.pointedPubId\n        );\n\n        uint256 pubIdAssigned = ++StorageLib.getProfile(mirrorParams.profileId).pubCount;\n\n        Types.Publication storage _publication = StorageLib.getPublication(mirrorParams.profileId, pubIdAssigned);\n        _publication.pointedProfileId = mirrorParams.pointedProfileId;\n        _publication.pointedPubId = mirrorParams.pointedPubId;\n        _publication.contentURI = mirrorParams.metadataURI;\n        _publication.pubType = Types.PublicationType.Mirror;\n        _fillRootOfPublicationInStorage(_publication, mirrorParams.pointedProfileId, mirrorParams.pointedPubId);\n\n        bytes memory referenceModuleReturnData = _processMirrorIfNeeded(\n            mirrorParams,\n            pubIdAssigned,\n            transactionExecutor,\n            referrerPubTypes\n        );\n\n        emit Events.MirrorCreated(\n            mirrorParams,\n            pubIdAssigned,\n            referenceModuleReturnData,\n            transactionExecutor,\n            block.timestamp\n        );\n\n        return pubIdAssigned;\n    }\n\n    /**\n     * @notice Publishes a quote publication to a given profile via signature.\n     *\n     * @param quoteParams the QuoteParams struct.\n     *\n     * @return uint256 The created publication's pubId.\n     */\n    function quote(Types.QuoteParams calldata quoteParams, address transactionExecutor) external returns (uint256) {\n        (\n            uint256 pubIdAssigned,\n            bytes[] memory actionModulesReturnDatas,\n            bytes memory referenceModuleInitReturnData,\n            Types.PublicationType[] memory referrerPubTypes\n        ) = _createReferencePublication(\n                _asReferencePubParams(quoteParams),\n                transactionExecutor,\n                Types.PublicationType.Quote\n            );\n\n        bytes memory referenceModuleReturnData = _processQuoteIfNeeded(\n            quoteParams,\n            pubIdAssigned,\n            transactionExecutor,\n            referrerPubTypes\n        );\n\n        emit Events.QuoteCreated(\n            quoteParams,\n            pubIdAssigned,\n            referenceModuleReturnData,\n            actionModulesReturnDatas,\n            referenceModuleInitReturnData,\n            transactionExecutor,\n            block.timestamp\n        );\n\n        return pubIdAssigned;\n    }\n\n    function getPublicationType(uint256 profileId, uint256 pubId) internal view returns (Types.PublicationType) {\n        Types.Publication storage _publication = StorageLib.getPublication(profileId, pubId);\n        Types.PublicationType pubType = _publication.pubType;\n        if (uint8(pubType) == 0) {\n            // Legacy V1: If the publication type is 0, we check using the legacy rules.\n            if (_publication.pointedProfileId != 0) {\n                // It is pointing to a publication, so it can be either a comment or a mirror, depending on if it has a\n                // collect module or not.\n                if (_publication.__DEPRECATED__collectModule == address(0)) {\n                    return Types.PublicationType.Mirror;\n                } else {\n                    return Types.PublicationType.Comment;\n                }\n            } else if (_publication.__DEPRECATED__collectModule != address(0)) {\n                return Types.PublicationType.Post;\n            }\n        }\n        return pubType;\n    }\n\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory) {\n        Types.Publication storage _publication = StorageLib.getPublication(profileId, pubId);\n        Types.PublicationType pubType = _publication.pubType;\n        if (pubType == Types.PublicationType.Nonexistent) {\n            pubType = getPublicationType(profileId, pubId);\n        }\n        if (pubType == Types.PublicationType.Mirror) {\n            return StorageLib.getPublication(_publication.pointedProfileId, _publication.pointedPubId).contentURI;\n        } else {\n            return StorageLib.getPublication(profileId, pubId).contentURI;\n        }\n    }\n\n    function _asReferencePubParams(\n        Types.QuoteParams calldata quoteParams\n    ) private pure returns (Types.ReferencePubParams calldata referencePubParams) {\n        // We use assembly to cast the types keeping the params in calldata, as they match the fields.\n        assembly {\n            referencePubParams := quoteParams\n        }\n    }\n\n    function _asReferencePubParams(\n        Types.CommentParams calldata commentParams\n    ) private pure returns (Types.ReferencePubParams calldata referencePubParams) {\n        // We use assembly to cast the types keeping the params in calldata, as they match the fields.\n        assembly {\n            referencePubParams := commentParams\n        }\n    }\n\n    function _createReferencePublication(\n        Types.ReferencePubParams calldata referencePubParams,\n        address transactionExecutor,\n        Types.PublicationType referencePubType\n    ) private returns (uint256, bytes[] memory, bytes memory, Types.PublicationType[] memory) {\n        ValidationLib.validatePointedPub(referencePubParams.pointedProfileId, referencePubParams.pointedPubId);\n        ValidationLib.validateNotBlocked({\n            profile: referencePubParams.profileId,\n            byProfile: referencePubParams.pointedProfileId\n        });\n\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\n            referencePubParams.referrerProfileIds,\n            referencePubParams.referrerPubIds,\n            referencePubParams.pointedProfileId,\n            referencePubParams.pointedPubId\n        );\n\n        (uint256 pubIdAssigned, uint256 rootProfileId) = _fillReferencePublicationStorage(\n            referencePubParams,\n            referencePubType\n        );\n\n        if (rootProfileId != referencePubParams.pointedProfileId) {\n            // We check the block state between the profile commenting/quoting and the root publication's author.\n            ValidationLib.validateNotBlocked({profile: referencePubParams.profileId, byProfile: rootProfileId});\n        }\n\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            InitReferenceModuleParams(\n                referencePubParams.profileId,\n                transactionExecutor,\n                pubIdAssigned,\n                referencePubParams.referenceModule,\n                referencePubParams.referenceModuleInitData\n            )\n        );\n\n        bytes[] memory actionModulesReturnDatas = _initPubActionModules(\n            InitActionModuleParams(\n                referencePubParams.profileId,\n                transactionExecutor,\n                pubIdAssigned,\n                referencePubParams.actionModules,\n                referencePubParams.actionModulesInitDatas\n            )\n        );\n\n        return (pubIdAssigned, actionModulesReturnDatas, referenceModuleReturnData, referrerPubTypes);\n    }\n\n    function _fillReferencePublicationStorage(\n        Types.ReferencePubParams calldata referencePubParams,\n        Types.PublicationType referencePubType\n    ) private returns (uint256, uint256) {\n        uint256 pubIdAssigned = ++StorageLib.getProfile(referencePubParams.profileId).pubCount;\n        Types.Publication storage _referencePub;\n        _referencePub = StorageLib.getPublication(referencePubParams.profileId, pubIdAssigned);\n        _referencePub.pointedProfileId = referencePubParams.pointedProfileId;\n        _referencePub.pointedPubId = referencePubParams.pointedPubId;\n        _referencePub.contentURI = referencePubParams.contentURI;\n        _referencePub.pubType = referencePubType;\n        uint256 rootProfileId = _fillRootOfPublicationInStorage(\n            _referencePub,\n            referencePubParams.pointedProfileId,\n            referencePubParams.pointedPubId\n        );\n        return (pubIdAssigned, rootProfileId);\n    }\n\n    function _fillRootOfPublicationInStorage(\n        Types.Publication storage _publication,\n        uint256 pointedProfileId,\n        uint256 pointedPubId\n    ) internal returns (uint256) {\n        Types.Publication storage _pubPointed = StorageLib.getPublication(pointedProfileId, pointedPubId);\n        Types.PublicationType pubPointedType = _pubPointed.pubType;\n        if (pubPointedType == Types.PublicationType.Post) {\n            // The publication pointed is a Lens V2 post.\n            _publication.rootPubId = pointedPubId;\n            return _publication.rootProfileId = pointedProfileId;\n        } else if (pubPointedType == Types.PublicationType.Comment || pubPointedType == Types.PublicationType.Quote) {\n            // The publication pointed is either a Lens V2 comment or a Lens V2 quote.\n            // Note that even when the publication pointed is a V2 one, it will lack `rootProfileId` and `rootPubId` if\n            // there is a Lens V1 Legacy publication in the thread of interactions (including the root post itself).\n            _publication.rootPubId = _pubPointed.rootPubId;\n            return _publication.rootProfileId = _pubPointed.rootProfileId;\n        }\n        // Otherwise the root is not filled, as the pointed publication is a Lens V1 Legacy publication, which does not\n        // support Lens V2 referral system.\n        return 0;\n    }\n\n    function _processCommentIfNeeded(\n        Types.CommentParams calldata commentParams,\n        uint256 pubIdAssigned,\n        address transactionExecutor,\n        Types.PublicationType[] memory referrerPubTypes\n    ) private returns (bytes memory) {\n        address refModule = StorageLib\n            .getPublication(commentParams.pointedProfileId, commentParams.pointedPubId)\n            .referenceModule;\n        if (refModule != address(0)) {\n            try\n                IReferenceModule(refModule).processComment(\n                    Types.ProcessCommentParams({\n                        profileId: commentParams.profileId,\n                        pubId: pubIdAssigned,\n                        transactionExecutor: transactionExecutor,\n                        pointedProfileId: commentParams.pointedProfileId,\n                        pointedPubId: commentParams.pointedPubId,\n                        referrerProfileIds: commentParams.referrerProfileIds,\n                        referrerPubIds: commentParams.referrerPubIds,\n                        referrerPubTypes: referrerPubTypes,\n                        data: commentParams.referenceModuleData\n                    })\n                )\n            returns (bytes memory returnData) {\n                return (returnData);\n            } catch (bytes memory err) {\n                assembly {\n                    /// Equivalent to reverting with the returned error selector if\n                    /// the length is not zero.\n                    let length := mload(err)\n                    if iszero(iszero(length)) {\n                        revert(add(err, 32), length)\n                    }\n                }\n                if (commentParams.referrerProfileIds.length > 0) {\n                    // Deprecated reference modules don't support referrers.\n                    revert Errors.InvalidReferrer();\n                }\n                ILegacyReferenceModule(refModule).processComment(\n                    commentParams.profileId,\n                    commentParams.pointedProfileId,\n                    commentParams.pointedPubId,\n                    commentParams.referenceModuleData\n                );\n            }\n        } else {\n            if (commentParams.referrerProfileIds.length > 0) {\n                // We don't allow referrers if the reference module is not set.\n                revert Errors.InvalidReferrer();\n            }\n        }\n        return '';\n    }\n\n    function _processQuoteIfNeeded(\n        Types.QuoteParams calldata quoteParams,\n        uint256 pubIdAssigned,\n        address transactionExecutor,\n        Types.PublicationType[] memory referrerPubTypes\n    ) private returns (bytes memory) {\n        address refModule = StorageLib\n            .getPublication(quoteParams.pointedProfileId, quoteParams.pointedPubId)\n            .referenceModule;\n        if (refModule != address(0)) {\n            try\n                IReferenceModule(refModule).processQuote(\n                    Types.ProcessQuoteParams({\n                        profileId: quoteParams.profileId,\n                        pubId: pubIdAssigned,\n                        transactionExecutor: transactionExecutor,\n                        pointedProfileId: quoteParams.pointedProfileId,\n                        pointedPubId: quoteParams.pointedPubId,\n                        referrerProfileIds: quoteParams.referrerProfileIds,\n                        referrerPubIds: quoteParams.referrerPubIds,\n                        referrerPubTypes: referrerPubTypes,\n                        data: quoteParams.referenceModuleData\n                    })\n                )\n            returns (bytes memory returnData) {\n                return (returnData);\n            } catch (bytes memory err) {\n                assembly {\n                    /// Equivalent to reverting with the returned error selector if\n                    /// the length is not zero.\n                    let length := mload(err)\n                    if iszero(iszero(length)) {\n                        revert(add(err, 32), length)\n                    }\n                }\n                if (quoteParams.referrerProfileIds.length > 0) {\n                    // Deprecated reference modules don't support referrers.\n                    revert Errors.InvalidReferrer();\n                }\n                ILegacyReferenceModule(refModule).processComment(\n                    quoteParams.profileId,\n                    quoteParams.pointedProfileId,\n                    quoteParams.pointedPubId,\n                    quoteParams.referenceModuleData\n                );\n            }\n        } else {\n            if (quoteParams.referrerProfileIds.length > 0) {\n                // We don't allow referrers if the reference module is not set.\n                revert Errors.InvalidReferrer();\n            }\n        }\n        return '';\n    }\n\n    function _processMirrorIfNeeded(\n        Types.MirrorParams calldata mirrorParams,\n        uint256 pubIdAssigned,\n        address transactionExecutor,\n        Types.PublicationType[] memory referrerPubTypes\n    ) private returns (bytes memory) {\n        address refModule = StorageLib\n            .getPublication(mirrorParams.pointedProfileId, mirrorParams.pointedPubId)\n            .referenceModule;\n        if (refModule != address(0)) {\n            try\n                IReferenceModule(refModule).processMirror(\n                    Types.ProcessMirrorParams({\n                        profileId: mirrorParams.profileId,\n                        pubId: pubIdAssigned,\n                        transactionExecutor: transactionExecutor,\n                        pointedProfileId: mirrorParams.pointedProfileId,\n                        pointedPubId: mirrorParams.pointedPubId,\n                        referrerProfileIds: mirrorParams.referrerProfileIds,\n                        referrerPubIds: mirrorParams.referrerPubIds,\n                        referrerPubTypes: referrerPubTypes,\n                        data: mirrorParams.referenceModuleData\n                    })\n                )\n            returns (bytes memory returnData) {\n                return (returnData);\n            } catch (bytes memory err) {\n                assembly {\n                    /// Equivalent to reverting with the returned error selector if\n                    /// the length is not zero.\n                    let length := mload(err)\n                    if iszero(iszero(length)) {\n                        revert(add(err, 32), length)\n                    }\n                }\n                if (mirrorParams.referrerProfileIds.length > 0) {\n                    // Deprecated reference modules don't support referrers.\n                    revert Errors.InvalidReferrer();\n                }\n                ILegacyReferenceModule(refModule).processMirror(\n                    mirrorParams.profileId,\n                    mirrorParams.pointedProfileId,\n                    mirrorParams.pointedPubId,\n                    mirrorParams.referenceModuleData\n                );\n            }\n        } else {\n            if (mirrorParams.referrerProfileIds.length > 0) {\n                // We don't allow referrers if the reference module is not set.\n                revert Errors.InvalidReferrer();\n            }\n        }\n        return '';\n    }\n\n    // Needed to avoid 'stack too deep' issue.\n    struct InitActionModuleParams {\n        uint256 profileId;\n        address transactionExecutor;\n        uint256 pubId;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n    }\n\n    function _initPubActionModules(InitActionModuleParams memory params) private returns (bytes[] memory) {\n        if (params.actionModules.length != params.actionModulesInitDatas.length) {\n            revert Errors.ArrayMismatch();\n        }\n\n        bytes[] memory actionModuleInitResults = new bytes[](params.actionModules.length);\n\n        uint256 i;\n        while (i < params.actionModules.length) {\n            MODULE_REGISTRY().verifyModule(\n                params.actionModules[i],\n                uint256(IModuleRegistry.ModuleType.PUBLICATION_ACTION_MODULE)\n            );\n\n            StorageLib.getPublication(params.profileId, params.pubId).actionModuleEnabled[\n                params.actionModules[i]\n            ] = true;\n\n            actionModuleInitResults[i] = IPublicationActionModule(params.actionModules[i]).initializePublicationAction(\n                params.profileId,\n                params.pubId,\n                params.transactionExecutor,\n                params.actionModulesInitDatas[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return actionModuleInitResults;\n    }\n\n    // Needed to avoid 'stack too deep' issue.\n    struct InitReferenceModuleParams {\n        uint256 profileId;\n        address transactionExecutor;\n        uint256 pubId;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    function _initPubReferenceModule(InitReferenceModuleParams memory params) private returns (bytes memory) {\n        if (params.referenceModule == address(0)) {\n            return new bytes(0);\n        }\n        MODULE_REGISTRY().verifyModule(params.referenceModule, uint256(IModuleRegistry.ModuleType.REFERENCE_MODULE));\n        StorageLib.getPublication(params.profileId, params.pubId).referenceModule = params.referenceModule;\n        return\n            IReferenceModule(params.referenceModule).initializeReferenceModule(\n                params.profileId,\n                params.pubId,\n                params.transactionExecutor,\n                params.referenceModuleInitData\n            );\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/StorageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from '../libraries/constants/Types.sol';\n\nlibrary StorageLib {\n    // uint256 constant NAME_SLOT = 0;\n    // uint256 constant SYMBOL_SLOT = 1;\n    uint256 constant TOKEN_DATA_MAPPING_SLOT = 2;\n    uint256 constant BALANCES_SLOT = 3;\n    // uint256 constant TOKEN_APPROVAL_MAPPING_SLOT = 4;\n    // uint256 constant OPERATOR_APPROVAL_MAPPING_SLOT = 5;\n    // Slot 6 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokens`.\n    // Slot 7 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokensIndex`.\n    // uint256 constant TOTAL_SUPPLY_SLOT = 8;\n    // Slot 9 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `allTokensIndex`.\n    uint256 constant SIG_NONCES_MAPPING_SLOT = 10;\n    uint256 constant LAST_INITIALIZED_REVISION_SLOT = 11; // VersionedInitializable's `lastInitializedRevision` field.\n    uint256 constant PROTOCOL_STATE_SLOT = 12;\n    uint256 constant PROFILE_CREATOR_WHITELIST_MAPPING_SLOT = 13;\n    // Slot 14 is deprecated in Lens V2. In V1 it was used for the follow module address whitelist.\n    // Slot 15 is deprecated in Lens V2. In V1 it was used for the collect module address whitelist.\n    // Slot 16 is deprecated in Lens V2. In V1 it was used for the reference module address whitelist.\n    // Slot 17 is deprecated in Lens V2. In V1 it was used for the dispatcher address by profile ID.\n    uint256 constant PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT = 18; // Deprecated slot, but still needed for V2 migration.\n    uint256 constant PROFILES_MAPPING_SLOT = 19;\n    uint256 constant PUBLICATIONS_MAPPING_SLOT = 20;\n    // Slot 21 is deprecated in Lens V2. In V1 it was used for the default profile ID by address.\n    uint256 constant PROFILE_COUNTER_SLOT = 22;\n    uint256 constant GOVERNANCE_SLOT = 23;\n    uint256 constant EMERGENCY_ADMIN_SLOT = 24;\n    //////////////////////////////////\n    ///  Introduced in Lens V1.3:  ///\n    //////////////////////////////////\n    uint256 constant TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT = 25;\n    //////////////////////////////////\n    ///   Introduced in Lens V2:   ///\n    //////////////////////////////////\n    uint256 constant DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT = 26;\n    uint256 constant BLOCKED_STATUS_MAPPING_SLOT = 27;\n    uint256 constant PROFILE_ROYALTIES_BPS_SLOT = 28;\n    uint256 constant MIGRATION_ADMINS_WHITELISTED_MAPPING_SLOT = 29;\n    uint256 constant TREASURY_DATA_SLOT = 30;\n    uint256 constant PROFILE_TOKEN_URI_CONTRACT_SLOT = 31;\n    uint256 constant FOLLOW_TOKEN_URI_CONTRACT_SLOT = 32;\n    uint256 constant LEGACY_COLLECT_FOLLOW_VALIDATION_HELPER_MAPPING_SLOT = 33;\n\n    function getPublication(\n        uint256 profileId,\n        uint256 pubId\n    ) internal pure returns (Types.Publication storage _publication) {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\n            mstore(32, keccak256(0, 64))\n            mstore(0, pubId)\n            _publication.slot := keccak256(0, 64)\n        }\n    }\n\n    function getPublicationMemory(\n        uint256 profileId,\n        uint256 pubId\n    ) internal pure returns (Types.PublicationMemory memory) {\n        Types.PublicationMemory storage _publicationStorage;\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\n            mstore(32, keccak256(0, 64))\n            mstore(0, pubId)\n            _publicationStorage.slot := keccak256(0, 64)\n        }\n\n        Types.PublicationMemory memory _publicationMemory;\n        _publicationMemory = _publicationStorage;\n\n        return _publicationMemory;\n    }\n\n    function getProfile(uint256 profileId) internal pure returns (Types.Profile storage _profiles) {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PROFILES_MAPPING_SLOT)\n            _profiles.slot := keccak256(0, 64)\n        }\n    }\n\n    function getDelegatedExecutorsConfig(\n        uint256 delegatorProfileId\n    ) internal pure returns (Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig) {\n        assembly {\n            mstore(0, delegatorProfileId)\n            mstore(32, DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT)\n            _delegatedExecutorsConfig.slot := keccak256(0, 64)\n        }\n    }\n\n    function tokenGuardianDisablingTimestamp()\n    internal\n    pure\n    returns (mapping(address => uint256) storage _tokenGuardianDisablingTimestamp)\n    {\n        assembly {\n            _tokenGuardianDisablingTimestamp.slot := TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT\n        }\n    }\n\n    function getTokenData(uint256 tokenId) internal pure returns (Types.TokenData storage _tokenData) {\n        assembly {\n            mstore(0, tokenId)\n            mstore(32, TOKEN_DATA_MAPPING_SLOT)\n            _tokenData.slot := keccak256(0, 64)\n        }\n    }\n\n    function balances() internal pure returns (mapping(address => uint256) storage _balances) {\n        assembly {\n            _balances.slot := BALANCES_SLOT\n        }\n    }\n\n    function blockedStatus(\n        uint256 blockerProfileId\n    ) internal pure returns (mapping(uint256 => bool) storage _blockedStatus) {\n        assembly {\n            mstore(0, blockerProfileId)\n            mstore(32, BLOCKED_STATUS_MAPPING_SLOT)\n            _blockedStatus.slot := keccak256(0, 64)\n        }\n    }\n\n    function nonces() internal pure returns (mapping(address => uint256) storage _nonces) {\n        assembly {\n            _nonces.slot := SIG_NONCES_MAPPING_SLOT\n        }\n    }\n\n    function profileIdByHandleHash()\n    internal\n    pure\n    returns (mapping(bytes32 => uint256) storage _profileIdByHandleHash)\n    {\n        assembly {\n            _profileIdByHandleHash.slot := PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT\n        }\n    }\n\n    function profileCreatorWhitelisted()\n    internal\n    pure\n    returns (mapping(address => bool) storage _profileCreatorWhitelisted)\n    {\n        assembly {\n            _profileCreatorWhitelisted.slot := PROFILE_CREATOR_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function migrationAdminWhitelisted()\n    internal\n    pure\n    returns (mapping(address => bool) storage _migrationAdminWhitelisted)\n    {\n        assembly {\n            _migrationAdminWhitelisted.slot := MIGRATION_ADMINS_WHITELISTED_MAPPING_SLOT\n        }\n    }\n\n    function legacyCollectFollowValidationHelper()\n    internal\n    pure\n    returns (mapping(address => uint256) storage _legacyCollectFollowValidationHelper)\n    {\n        assembly {\n            _legacyCollectFollowValidationHelper.slot := LEGACY_COLLECT_FOLLOW_VALIDATION_HELPER_MAPPING_SLOT\n        }\n    }\n\n    function getGovernance() internal view returns (address _governance) {\n        assembly {\n            _governance := sload(GOVERNANCE_SLOT)\n        }\n    }\n\n    function setGovernance(address newGovernance) internal {\n        assembly {\n            sstore(GOVERNANCE_SLOT, newGovernance)\n        }\n    }\n\n    function getEmergencyAdmin() internal view returns (address _emergencyAdmin) {\n        assembly {\n            _emergencyAdmin := sload(EMERGENCY_ADMIN_SLOT)\n        }\n    }\n\n    function setEmergencyAdmin(address newEmergencyAdmin) internal {\n        assembly {\n            sstore(EMERGENCY_ADMIN_SLOT, newEmergencyAdmin)\n        }\n    }\n\n    function getState() internal view returns (Types.ProtocolState _state) {\n        assembly {\n            _state := sload(PROTOCOL_STATE_SLOT)\n        }\n    }\n\n    function setState(Types.ProtocolState newState) internal {\n        assembly {\n            sstore(PROTOCOL_STATE_SLOT, newState)\n        }\n    }\n\n    function getLastInitializedRevision() internal view returns (uint256 _lastInitializedRevision) {\n        assembly {\n            _lastInitializedRevision := sload(LAST_INITIALIZED_REVISION_SLOT)\n        }\n    }\n\n    function setLastInitializedRevision(uint256 newLastInitializedRevision) internal {\n        assembly {\n            sstore(LAST_INITIALIZED_REVISION_SLOT, newLastInitializedRevision)\n        }\n    }\n\n    function getTreasuryData() internal pure returns (Types.TreasuryData storage _treasuryData) {\n        assembly {\n            _treasuryData.slot := TREASURY_DATA_SLOT\n        }\n    }\n\n    function setProfileTokenURIContract(address profileTokenURIContract) internal {\n        assembly {\n            sstore(PROFILE_TOKEN_URI_CONTRACT_SLOT, profileTokenURIContract)\n        }\n    }\n\n    function setFollowTokenURIContract(address followTokenURIContract) internal {\n        assembly {\n            sstore(FOLLOW_TOKEN_URI_CONTRACT_SLOT, followTokenURIContract)\n        }\n    }\n\n    function getProfileTokenURIContract() internal view returns (address _profileTokenURIContract) {\n        assembly {\n            _profileTokenURIContract := sload(PROFILE_TOKEN_URI_CONTRACT_SLOT)\n        }\n    }\n\n    function getFollowTokenURIContract() internal view returns (address _followTokenURIContract) {\n        assembly {\n            _followTokenURIContract := sload(FOLLOW_TOKEN_URI_CONTRACT_SLOT)\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/svgs/Follow/FollowSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary FollowSVG {\n    uint8 private constant MAX_GOLD_TOKEN_ID = 10;\n\n    function getFollowSVG(uint256 followTokenId) public pure returns (string memory) {\n        if (followTokenId <= MAX_GOLD_TOKEN_ID) {\n            return\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"275\" height=\"275\" fill=\"none\"><g><path fill=\"url(#b)\" d=\"M0 0h275v275H0z\"/><path fill=\"url(#c)\" stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"4\" d=\"M168.9 116.8v0a1 1 0 0 1-1.8-.8v0-2.7c-1.1-37.7-58.1-37.7-59.1 0v2.7a1 1 0 0 1-1.9.8v0l-2-2C76.8 89 36.5 129.3 62.5 156.6l2 2a113.3 113.3 0 0 0 73.1 31.3s0 0 0 0 41.8 0 73.2-31.3a81 81 0 0 0 2-2c26-27.4-14.4-67.6-41.9-41.6l-2 1.9Z\"/><g><path fill=\"#B96326\" d=\"M127.3 152.2a1 1 0 0 0-1-1.3H125a1 1 0 0 1-1-1v-1.8c0-.6.4-1 1-1h2.8a1 1 0 0 0 1-.8l.7-3.1a1 1 0 0 0-1-1.2h-1.7a1 1 0 0 1-1-1v-2c0-.5.4-1 1-1h3.2a1 1 0 0 0 1-.7l1-4.6a1 1 0 0 1 1-.8h3a1 1 0 0 1 1 1.2l-.9 3.7a1 1 0 0 0 1 1.2h3a1 1 0 0 0 1-.7l1.2-4.6a1 1 0 0 1 1-.8h3a1 1 0 0 1 1 1.2l-1 3.7a1 1 0 0 0 1 1.2h1.8a1 1 0 0 1 1 1.3l-.5 1.8a1 1 0 0 1-1 .8H146a1 1 0 0 0-1 .7l-.7 3.1a1 1 0 0 0 1 1.3h1.8a1 1 0 0 1 1 1.2l-.5 1.9a1 1 0 0 1-1 .7h-2.8a1 1 0 0 0-1 .8l-1.3 5.5a1 1 0 0 1-1 .8h-3a1 1 0 0 1-1-1.3l1.2-4.5a1 1 0 0 0-1-1.3h-3.1a1 1 0 0 0-1 .8l-1.3 5.5a1 1 0 0 1-1 .8h-3a1 1 0 0 1-1-1.3l1.1-4.5Zm10.8-5a1 1 0 0 0 1-.8l.7-3.3a1 1 0 0 0-1-1.2h-3.2a1 1 0 0 0-1 .7l-.8 3.3a1 1 0 0 0 1 1.3h3.3Z\"/></g></g><defs><radialGradient id=\"b\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFE7A5\"/><stop offset=\"1\" stop-color=\"#FFF2CE\"/></radialGradient><radialGradient id=\"c\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(0 83 -132 0 137.5 107.1)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFDF85\"/><stop offset=\".9\" stop-color=\"#F8C944\"/></radialGradient></defs></svg>';\n        } else {\n            return\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"275\" height=\"275\" fill=\"none\"><g><path fill=\"url(#green)\" d=\"M0 0h275v275H0z\"/><path fill=\"#A0D170\" stroke=\"#000\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"4\" d=\"M168.9 116.8v0a1 1 0 0 1-1.8-.8v0-2.7c-1.1-37.7-58.1-37.7-59.1 0v2.7a1 1 0 0 1-1.9.8v0l-2-2C76.8 89 36.5 129.3 62.5 156.6l2 2a113.3 113.3 0 0 0 73.1 31.3s41.8 0 73.2-31.3a81 81 0 0 0 2-2c26-27.4-14.4-67.6-41.9-41.6l-2 1.9Z\"/><g><path fill=\"#000\" d=\"M127.3 152.2a1 1 0 0 0-1-1.3H125a1 1 0 0 1-1-1v-1.8c0-.6.4-1 1-1h2.8a1 1 0 0 0 1-.8l.7-3.1a1 1 0 0 0-1-1.2h-1.7a1 1 0 0 1-1-1v-2c0-.5.4-1 1-1h3.2a1 1 0 0 0 1-.7l1-4.6a1 1 0 0 1 1-.8h3a1 1 0 0 1 1 1.2l-.9 3.7a1 1 0 0 0 1 1.2h3a1 1 0 0 0 1-.7l1.2-4.6a1 1 0 0 1 1-.8h3a1 1 0 0 1 1 1.2l-1 3.7a1 1 0 0 0 1 1.2h1.8a1 1 0 0 1 1 1.3l-.5 1.8a1 1 0 0 1-1 .8H146a1 1 0 0 0-1 .7l-.7 3.1a1 1 0 0 0 1 1.3h1.8a1 1 0 0 1 1 1.2l-.5 1.9a1 1 0 0 1-1 .7h-2.8a1 1 0 0 0-1 .8l-1.3 5.5a1 1 0 0 1-1 .8h-3a1 1 0 0 1-1-1.3l1.2-4.5a1 1 0 0 0-1-1.3h-3.1a1 1 0 0 0-1 .8l-1.3 5.5a1 1 0 0 1-1 .8h-3a1 1 0 0 1-1-1.3l1.1-4.5Zm10.8-5a1 1 0 0 0 1-.8l.7-3.3a1 1 0 0 0-1-1.2h-3.2a1 1 0 0 0-1 .7l-.8 3.3a1 1 0 0 0 1 1.3h3.3Z\"/></g></g><defs><radialGradient id=\"green\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#DFFFBF\"/><stop offset=\"1\" stop-color=\"#EFD\"/></radialGradient></defs></svg>';\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/svgs/Handle/GintoNordFontSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary GintoNordFontSVG {\n    function getFontStyle() external pure returns (string memory) {\n        return\n            '<style>@font-face{font-family:\"Ginto Nord Medium\";src:url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAACKgAA4AAAAAQRQAARmaAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABRAAAAFcAAABgXKGBW2NtYXAAAAGcAAAAjAAAAXLpzuMfY3Z0IAAAAigAAABeAAAAihQGIaBmcGdtAAACiAAABvIAAA4VnjYU0Gdhc3AAAAl8AAAACAAAAAgAAAAQZ2x5ZgAACYQAABM3AAAliPbIdb5oZWFkAAAcvAAAADYAAAA2GW8/k2hoZWEAABz0AAAAHQAAACQDvANKaG10eAAAHRQAAACgAAAArG9wB0lsb2NhAAAdtAAAAFgAAABYw1LMgm1heHAAAB4MAAAAIAAAACAB0w7CbmFtZQAAHiwAAAOvAAAHs7kildFwb3N0AAAh3AAAABQAAAAg/7gAXXByZXAAACHwAAAArgAAAMuEpHX+eJxjYGGazviFgZWBg6mLKYKBgcEbQjPGMRgxRjEwMHEzsDAzMbExsQDl2AUYEMDRydmFwYFBgaGKWey/HsMJ5p+MKgoMDJNBckyOTHuAlAIDNwAmJwvQAHicY2BgYGaAYBkGRgYQyAHyGMF8FoYAIC0AhCB5BQZlBj0GSwYHhniGqv//oSK6DAZgkcT///8//H///7X/V/+f/7/x/waoaSiAkQ1TDEMNAwMTnMPMwsDKxs7BycXNw8sHEeLHr12AQVBIWERUTFxCUkpaRlZOXkFRSVlFVU1dQ1OLsOV0AACuhRipeJxjYCAKSEAg0woGBibH/9/+OyFYDLVAmMyQzBzB9JExjOEKcyUzE6M3wzGGpUDYwtDCtAeo8gKTIwMDUNfF/6+ZfjJF/n//34ihAgiTGJKYrjJqMT1glAcAqxQewwAAeJytV2tbG8cVntUNjAEDkrCbdd1RxqIuO5JJ6zjEVhyyy6I4SlKBcbvrNO0uEu79kvRGr+n9ovyZs6J96nzLT8t7ZlYKOOA+fZ7yQeedmXfmXOfMQkJLEg+jMJay90Qs7vao8uBRRLdcuhEnj+XoYUSFZvrRrJgVg4E6cBsNEjGJQG2PhSOCxG+Ro0kmj1tU0KqhGi0qajk8Ltbqwg+oGsgk8bNCLfCzZjGgQrB/JGleAQTpkEr9o3GhUMAx1Di82uDZ8WLd8a9KQOWPq04Va4pEPzqMx6tOwSgsaSp6VA8i1kerQZATXDmU9HGfSmuPxjechSAchFQJowYVm/HeOxHI7iiS1O9jagts2mS0Gccys2xYdANT+UjSBq9vMPPjfiQRjVEqaa4fJZiRvDbH6Daj24mbxHHsIlo0HwxI7EUkekxuYOz26Bqja730yZIYMONJWRzE8TCNyfHiOPcglkP4o/y4RWUtYUGpmcKnmaAf0YzyaVb5yAC2JC2qmHAjEnKYzRz4khfZXdeaz79USsIBldcbWAzkSI6gK9soNxGh3Sjpu+leHKm4EUvaehBhzeW45Ka0aEbThcAbi4JN8yyGylcoF+WnVDh4TM4AhtDMeosuaMnWLsKtkjiQfAJtJTFTkm1j7ZweX1gUQeivN6aFc1GfLqR5e4rjwQTY3kxkOFIpJ9UEW7icEJIujJxYidSqdNuqWDhnO13HLuF+6trJTYvaOHS8MC+KIbS4qhGvo4gv6axQCGmYbrdoSYMqJV0K3uADAJAhWuLRHkZLJl/LOGjJBEUiBgNopuUgkaNE0jLC1qIV3duPstJwO75OC4fqqEVV3duNeg/spNvAfNXM13QmVoKHUbayEpCT+rTs8ZVDafnZJf5Zwg85q8hFsdmPMg4f/PVHyDDULq03FLZNsGvXeQtuMs/E8KQL+7uYPZ2sc1KYCVFViFdA4t7YcRyTrboWmSiE+xGtKF+GtIjyW1AoOZRiDTMJbPjPlSuOWBZV4fs+R6IGQ7CW1WY9+tBzn0fcVuFs3WvRZZ05LK8g8Cw/p7Miy+d0VmLp6qzM8qrOKiw/r7MZltd0NsvyCzq7wNLTapIIqiQIuZJtct7la9MifWJxdbr4nl1snVhcmy6+bxelFnTJO89h9vXf1ld29KR/DfgnYdfz8I+lgn8sr8M/lk34x3IN/rH8IvxjeQP+sfwS/GO5Dv9YtrXsmMq9qaH2SiLR/ZwkMLnFbWxz8W5ouunRTVzMF3AnuvKctKp0U3GHfybDZe+/PMl1tlgJufTohfWs7NTDCN2RvfzKifCcx7ml5YvG8hdxmuWEn9WJ+3umLTwvVv8l+G/7ntrMbjl19vU24gEHzrYftybdbNFLun2506LN/0ZFhQ9AfxkpEqtN2ZZd7g0I7f3RqKu6aCYRXkC0XzxNm45TryHCd9DEVukyaCX01aahZfPCp4uBdzhqKyk7I5x59zRNtu15VMFtyNmSEm4uW7vRcUmWpXtcWis/F/vccufQvZXZoXYSqgRP39uE2559nkpBMlRUxuuK5VKQusAJt7yn96QwDQ+B2kGOFTTs8NM1FxgtOO8MJco21wouMZJRRsGVP3MqTmQjmmxEEb95S/1UFwqhM4mFxGx5LY+F6iBMr0yXaM6s76guK+Us3puGkJ2xkSaxH7VlBy87W59PSrYrTwVVmhjdP/kRY5N4VrXn2VJc8q+esCSYpCvhL52nXZ6keAv9o81R3KHLQdR38bjKTtzONpwa7u1rp1b33P6pVf/Mvc/aEWi64z1L4bamu94ItnGNwalzqUhomzawIzQuc32u2cin+FLzretcoArXp42bZ8/f0dkcHp3Jlv+xpLv/rypmn7iPdRRa1Yl6acS5nV004DveJCqvY3TXa6g8Lrk30xDcRwjq9trjswQ3vNqm27jlb5wz38NxTq1KLwG/qelliLc4iiHCLXfwAk+i9bbmgqa3AL+qx0LsAPQBHAa7euyYmT0AM/OAOV2AfeYweMgcBl9jDoOv62P0wgAoAnIMivWxY+ceAdm5d5jnMPoG8wx6l3kGfZN5Bn2LdYYACetkkLJOBgesk8GAOa8DDJnD4JA5DB4zh8G3jV3bQN8xdjH6rrGL0feMXYy+b+xi9ANjF6MfGrsY/cjYxejHiHFnmsCfmBFtAb5n4WuA73PQzcjH6Kd4a3POzyxkzs8Nx8k5v8DmV6an/tKMzI4jC3nHryxk+q9xTk74jYVM+K2FTPgduPem5/3ejAz9AwuZ/gcLmf5H7MwJf7KQCX+2kAl/AffV6Xl/NSND/5uFTP+7hUz/B3bmhH9ayISRhUz4UI8vmk9cqrjjUqEY4r8ntMHY92j2kIrX+0eTx7r1CRR6A/0AAAABAAH//wAPeJzFWmtwk9eZPud8F/mGrQuy5Iss62obyca2LMk2YGSD75Ylyza2AsbIGBxRLrkABkPAEOIAAUJI2GxoGoJNmmloNqQbTKdJQzbTpt10dss2M213Zzuzmdmd7my3ITM73Zlkannfcz7dbZMf+6NkTNB5H+l7L897OxYiaAdC5GfkA8QhGSr3WBDmMUcwN4EICIYQIWgU/oF8PM/LeJlSIRfEApvFoDAICoOC/GzhFTIRMeF+RD44HlmPf4JS/xBUDn/9AT6/COnR7e7bZv+wx5ohEl6el8lxhOcezc0iZFU2wYjgCRkWhBpvDkaoFvUWdd+2UzQc8sIzK76Hop2A9qyVgPAao5klcIzJEP0/waP0nQT7gkFPSXFxsb5YX6IrKizQavLVq1VKRfSPXJGpt7lNbpPTwX4cMvYjM7EfOHfDwednqnYeN+x/tuJM+cWKMxWThYcMhwsmq86svVRvvGJEH+26MP4m/Bm/sOujj/7n8mUEmrXgTPwZ/ivwt9ajhtcIDyGMqZMx8inkJFNrwwanAX8WOYBfwJkX6bl98QH6XzSHspFT8kkOuBaHwCa8DoPlCkQ/Ihg7RLgv6MmCV9koy8xlamz5Vmedy1EL9omm3Y2NdltDg01RV2Z1OKxldRCj6sUvyXvkeygPovRY9+1CeIKGRj4En1HjFTDH4RAffZikgJrGlkMknCr0FCWdY8wF42IOdAp6lHI5QvIieWH+anhYrlUE5fgq7Kxrwo7aEqxenYtNTfDSajKK6tX5Dqx60d93ZXTHFb//yo6ugYGuzsGBLvnQa7snrg8Hr0/s/s7Qs4+PjU0eHht7gvqpEP46T64hEXXdFQXEgSd6JMplU9+Mgpdq4ybEj5xUcTlz4VD0DFF2vKdQ0Gio3A6FSSEr/OPT3/mMKM4t7MaLU4BwgaEN4DMtOufJzcOEywU2gqGI65E8qAYPciHEcTXe1IdTfVQQf4I4El6q1xIR00+bOE3XMzhvLlPI+cxCSEu1wemOOVDmdElOFWVAd/dC5LNud/fmxrB59/nAUU/f9snJb73sCFTWrreZnm9z7mxpn9oIn9gAXOgAu8rQZU9+CeYFHeb4MrAvEzIoA54oRO3TUY2gVkwgnhdCiCYuVY1yZl08eYuQgHhO4MNxcBLEU7pUCnYFoxiMKGUyzSaD2WwRM4ttKJ8RxFjmLAG6uMBKG3Y7apda+3Vv55mBc7sM4U2dgbaeOc0LJ7o6No3rd54dnPJs9uDgtpbGkbrGJzX6usryqvCA1W7UnKqr8jtcvatYzSqAv64Aj7LQKnRgPjuDID5GJDXiEf+MAGEGdyD8KAS5liSyYonQCUJwFT0HE8kMCGn8BGroDo7mqp8aqaR1R06NxA61SW1yGpzYIeMcpPjw4auRK7jmV1d/9zucue/VV4/j009EPqe1FaMmiNUjoKcO7fHkFWEi5NPKlgUfSklINSoGz/ICx0+IWIDnC8Cf5AAYlhGnRcCTC2AdKlYozRarLLPIhqJ5arQm4mAyyhTAPbXLgef31nee3dZ2uqx6oqlvINC3bxR/EXmldQj/wD26vm3fBpPuSKnOU+dYb8OTT53XM3/XLP4R/P0WKoZu8ZEnVwF0VQIdtFDPqSHFYIhexJKqYXAqDoGCNV7aLZgt9SiWVzrQmXCYhOPwNJD94SDmFdNycoSEYAwmUGYGPat1OnBNua7MZADViywWa0ZmQZJ/pLKWr1FXwStRh+GV3JVU3P5r7/qec8Pn3xq+Hm4+vMawb8PuJ7UHevt6PRsDgSb8sXu8pf1xz43ZyVvDuqKzReYju0l9c2Suvb6+rd3t7gAlTeC8dazejdyhlIuRNA8BA2l3nEipLCnHrKrkI3g9g2itpyWFjIIcEdoZaXUUkahU8LQEOg1qbMImoo38zTx+lJQcP7Xwe1ICEI7FbhpipwFt1qIfzmuyCc8UYVGD4PIC4aknuYdGTWRTRziGXz5qK4FiUVsqXy5qZrNWa15rrlpTrjVpjWvWmFnUpJjRXuS2JvqRzMpCJZFcmRQ8Mt0xExx+tvOFk5tP9vc/tfnE/eaW+vqW5gZPT7enpbvHg+tPNo44nSPrTpRZ9zkGamoGHPusv65ZU1FXV7GmJlLZWFnV0FBlX0f5Xwk+nIny/x7lv8BnQTgzo4nMPCmLZyjPcyHqz0S9TfJkCmVTEj7JkyuDmCeNy8nTC/My9LcwR+anVocNOOZX8GmyB/Hnbwx+e5fnkM24d/2uPfl7ujv2bYDK0eDzrfd4ezaSt15/4/Bbw4aS6RLrkcdzNrQ5x5ohHSKXW12u9o56Vwv4rWLxKLeH/C2yg3G/6b4tB9uUeVgGBQJl6DAPmSjwfE9RyiGWDoMS3AyfIssgsnAmzgDj+AwE/kUwRu6Cxi2GkCjWcDHf2hDKwBkITye9B8blDLzcWzw1cbQIbVtkrEx/lyDwwWj35AXa7BSVlZX1le5yq9lqsprkWZklNovJmeTAWg2tJbnATOZct1pMiICvYpJ/uT3f1u5sbdxW59jedLqeHNwzcrFn6M2DgXc2vvTja/92+OCvzk6+OfgfXR0N7qYNrpluW7XNV1vrr/IHx3pO9w3OeKvLjg+H35868sGjPee33qq2mNZWWS1VrO84Fy+QV1j2l74rjm9eaY59V0SbBZhlySsLr5LxgwdZrS8DrodIECbNMix4lAUwXWhhulACy6ApijzwPQecXQpQQSQCjAYcH5Jhnm/0ZmBRRCEc3w700QCm4+A5tQzMKk59fOgyghjRhSAcf9MySPtKSGcCyWZd4IOIRYjwEnAGPRaDMbhIZ1+Irrq4GKHismKrsRTML4QYqzJhaoOMUaQF2UmjTCealIT5+Pr1kl2bN+5wusZbppvwxMBjvl1nN/V0rmtsaa4nwZfORX7SW11Tu8XlGqzuL/QPes91Lyw4K8pqaysqHNT3XYsPyJfkPlIiPa6fz8siAptrcll1JcThjdeWxmiZps6WpjkVgAzpINpevClluPu2Ngqs+SagngGTMHQ3Ww5oXtL/l4XZl4U5vWltIrm4YWgP4Jf47ploE6zAqVQIqfSqkgINuEyhUKX19zK1SeFQJMoaTUvoDLXHNnVNewNThtlZ3Ymt/OiIr85n2+YjQf+FLVsv+dqbJ8n9yH93DkSKdnq9O9f2OXqAI8gCsdnL8mLSkwezNtLSpRXSg9AWQH2VHyvSzFUcbFUct46LWb6aZiaYEk6ReQoSx7ALB2NCwtFyQ9dIICJUGwEMiy9i0sCSUmRw/mv9W17/1vmgJbRu01hd7Xibe9y6a0YRuDg0dNG/6WyJxd5bW+OrMhefbkPRPH9A/iHKNdu8kk/iGmQBitII0cDD8ClI26w0q6hY/qdiWMApkITAhnUkxrRStqI+HKdnuAQktnKl4yjPSlCMPyuh7MuhnKkojzEGgGOYy4PRKEzEUAKJkSxXpaIUK7eaFHI6XmNHWjHI15DklZismZsrnRr2P7W5++m+vidLp/z2UX/v6HYvub9QfabN57849MhFX1db5BZj1livdyeLB+XXVSBAPgzzFzxZMuBSBgx/JEquEuhh0JYQ0zDhyzS7YZ0Q6VAuhGPwZAxdJ5aIgcTBKAhToz25Go1GpylWWy1GyWBDlGUpRqvNoswANCRXI47cQ6NN++1VM53h14d8V8effyXy8mAO9gj+Nixr67UaThnLfZe2bXnO/+Lpqy3uxo2sR0HqEhf5T7Qa/aMnW4FFQQkBEKm5lF5FfGxJg7wXRba/Nnjjy5x6BYg7AaFkKUACiKDmhxPYlIVwBYBTchbdB5MBdDHkaScdZYuhj/EDhnawQWWid1LKDLoF6+mKqID/nA6n1UXT1WrCnQL+59/OXbsmTk9ta7B1kP17Vh2JnMInj+TuP2Q6VBLLyVryU+CAHiamRU+eXkFEISu62tMqk80qMi2DVI06L7WbcaHWG9u61rMM1QDQgigE0HwI0a67IpjSy0StlMag1HelQqtZR4fMgYFqmk5VIi+EE29NwnoqHgIDc4JRMIn23rzS0lJ7qa3carGY5Rlsz1asPKcuSTrTbHDuQNezlRVHW5543HCwr/9Ea+epgH+/8ajfNur1btvaTZoj1ePP91jNZ6z2AxOWjm6Qb5np7miPfGLrXtuxbXtn+1bKyy4IxF2oiyr0yztyGvMoIzXgOQdNOT4ksCmGxOccbVRcs7xYz8QJCSDRaELMbi1AAs/mcThNaF9eyO5TCxEHc83QEimHfFLpopclKqRUqEwqMTbHKCSfKaKdkWyYmmtt7+6bndUfCJDg889E3seG4cFtPZF/gSb4pbeH8ZJm7J/JVygb5aFZyR359EqRdbsGalBdIvGKpWZH7xQRU6ouNSlTZGQ0JR+XylgqFiQdQ4Mcigo5IqVgLkJ5uaty2HWqkKmxKZOuUyExHYdcrooKp6u8b26OjFQajTab0Vi5MEfWgm2Lf7dYBe2W2laA7niypJtCnsQKUbGw1E5+TIRAruep1jrAFMJQkmptMqJauovD9AJtOoFMBtF2tETO8yxJGIrwATbw5MBEkFOQo1WvVsqZubI0cwmkC6zDToguvHrK7V5TXldX/lLTanNZx1x4a8L8P/+TMudwYYC4Fm4HdsR4/0PgfRb6cD6DI6BQ1AMKaaikluEUyiukITJVoI/dTY+ys3Sxeak4+s843RNiZ0LMCK9hV9cQfdhshmKiGNvnlQp6GVJoy8QmzOjtduCXsPnnkcjNmw9+jjsjd3F15D6w+uK/U3sps78AezkUluzMhhR1sN0kbmE2uxBBycpnR5eoJIXjR0xJefquRZV7T1q43KDWF7OzCB6Loj7nFiHKRvB5aSGRig0t8vnQYLAQypCJnCDUeYGOyf4tRPSQQkSAEFFsTEZQLbX0mDYpEZgE/WI0SW5fUc701yE6dQ8tBxAkY+hdPKhsMClWQ3rBiqRLLy3SP2gPdKilau1ycC/unat3NTbNNjgbPHj2RuGOjtaQuhZGnlOTkeu4qa3b1xL5GPdsaAt2Rj4jzUe72rs2XYz7CWpyEIrZrXhNzmZX8ZAsIYEnlGTpBZel4nL1+P9TcPFDCu431Vt1cr29oT/Qn1Zvm5/u9aL4LPgLsDf6+554TknLxV/y9z3Ka/3913ZPXAsErk34t2/30x9F4NLQ8HN+/3PDQ5cCT+/0+UIhn2+ntM+2kAdgB+wY6PPEPpvNKiLUt5AI5ZzUJW2ANGKu+FRC19S6pUtvKjB1rUxGRDdMV3x0Sb1YQ/ATTgZBGSY8JkMrokh05vvGxTMW7rTFc2pT10lp8Sx+aiRt8Xy+t70l8ilZPN+zJXnxjM6FLbCrSX78dWJXy2YTP8+jEMfGwcSKk+rGUmmmS9nn0nEpW1MyILpAJZxYnISKXj4mYSBmkBpoaCVQbGxebq1SPGzCq7h5U39kS9+Jts7T/YEn9VN99h3+3u0jXtK8gHFzW6/vwvAjl3zd7ZG3meNCvb07Y7UD/570AL1vebKhoJEcetNI2zsdkpXUvyFeomH8Ml7a5tkRVGi2rCdJ2RADZ/DBXIJAiWv8pTJ2l19ALzLIULowxim660MKQvGguz6iS4NRlKmjRMI/NVrWtfbjmzfUW5pIj/blotD2r0jza4MD1MZKqBde4EcFvZvQwEdqoYHDx3MocTcRnc0bEyYl301gplw4RQYax4+h0gVjQhS/m6hA5Ra7heqbn/TLprU4EUPpVysQQD2OZsefLjW6nmt3N+gqpkcCzVOB7iOVlQebG9eXrz04OLzxaL+i3HqyotJQoi7NLtEENtT57SbdMb2lpFBTmF2g6OusH5TuOKHY4kXyS5iCJt/LzoJaIxmqpG0R2hVLiJS5U77CDihfuvpp2eq3/MZ3l335QGCUja95bhx4++2bN27cJM3HIo34k2N7jey7BIt/IN8jzdAUbt7hadeIJq1SylfISDyWuFbRS42fSei9Bq2QY6BSfdwEJo3eeqRK7SlSZ1y6ThqfoarxQSZmZkpCntChMniXzshRg6JXG1Y2P7JfqxBxbk73WM/jUzdbW9t9kGz3DrW2Pn0MD0f+3ucd7pH6cwYk0Y/AThH1S2bkkLgZ8ZShZxg9k5IqiTOWIlnxl4dBsTvgaA64ZVE5YKRz4LFbb0e+/m7k63e+j68u3IPHsWfD8M/9CV7koF3zWQKRvlJAdciFrKZKJBxsjp3CMxKn9rRTpklO0gHV5S6dLhXUSaANZ8rGJs5RBO38Xw/dvHfr0oU3P7i1f+atd/CVhXt4LjICu+Zj+LKkH/2azmugXzYK380UOfqL9KiCq2DmJ+nDMTtMH4mTDtkgoqK/BoRJOH5M2AQyr1RKIzBWmcpkJhXn0MAM/Mlv7125/P5vfvGjmbPv0wn4/n1cjRUffgi6ZUFf+THoJkPeOwJOuC4RvkTZZ2eJMq8kUnbETlly3FEmRczNOfD2H7wdOT4//dU7n+LJBfyAyCWfWED53fDcTPSMJws4ydGHx2662PcyRqXxbcXvZUys/L2MuCjlexkTy30vg8ZUWhnoFzPo13rIQOSv8RREcSzyBinHn0bePTaFvVP/B1+1FbUAAAEAAAABGZoGbToNXw889QAHA+gAAAAA20nvpAAAAADbSfNK/8H/LgP/AvkAAAAHAAIAAAAAAAB4nGNgZGBg/vnvDgMDi9P/gwwgwMiACrQBhdMFCgAAAHicFY29CkFhHMZ/7/MaRM4ixKrjUBQDRaLOeDK5AjegrC6AS7CKC5DNKC7ATciuDDLxNz0fPR++xszlwKepq0DsqjT1oO3uVDSnpyV9HShrxUgXOppS1dHwRMvvaOhGV3siXyLRhtAw0plQQ/I+MP4hcQPGLv5ebCdxfSap2LLm62n5Ism/496mF7SUJacXsa6kUyLQFtlvRmvCH8bfHhMAAAAqADAAuADSAQIBZgGcAggCigLeA0ID3gQgBMIFXgYaBjgG9gfECCwI9AlsCfYKuAtCC7AMNAysDO4Ngg36Dl4PAg+gEBIQjBDeEVIRkBHgEi4SahLEAAEAAAArADkAAwAAAAAAAgA8AHIAjQAAANsOFQAAAAB4nI1U3WrcRhQ+u+s4MbF9VyhtINO7pBjt2tCbQCG2g+24zpXB0NKbkTRaTTPSiJmRN5uXyE37BH2EUtK7vkJK36f0m6PZeBMXUgvtfHN+v/MjE9GD0RWNaPg7xzvgEZ7zhMd4v0t4soY3cK7wHdqhi4Q3cX6f8F36hn5I+B40bxLeol36JeH79Bn9mvA2fU5/JLwzyuhdwrv01egfZB9tbOH28/hhwiMaj39LGDzHvyc8WcMbsFnhO/TF+G3Cm5D/lfBd+mn8d8L3aHvybcJb9GDyPOH79PVEJbxNs8mbhHfGP07+THiXjja/PLbd0ul5HcTB7GAmnulWNlY8Ore1bFvlxZFTS+X2xInMtWzFmXT540wcGiPYywunvHLXqsyy7Eo5r20r9rP92Sw7PDoWp7oNVmgvpAhOlqqR7qWw1SrNaZOf7YnLhQ6vlTOyLbNBcaly8aK4kH1RQ1qH0Pkn06nMi5LVWWGbKITMq7wpTDKM8gu5qHojeq9inlArUdkWNK3jSymDFAUkUreqFMhc6/a9mai0Qc3qVWH6EqCxpa6Wup3voUzpvWpyk27gwcgH6wAEyu56aAuzFPJaaiNzowS3xvnoUGofdN4Htkap0JkYDM1sl6JvzUfE0bSw7Ozcya7WhfC2CgvpFCij97kSnbNeFX1A58UJqpNlqQO6L43QbWVdI+MNWdRQbxFEA1pPb3XxVmuna/50TJY6WpIjTXOqKZCgA5rxK+gZpC1JamAl6BE+QwsbCVlLijxkR/BU8Fc493A/gTaHV7QRdIbT4f6YMtwOyeARa7k832Kk6H+N3xKW8bliiYel5Uj7kO2D0wznIbIeQ3bK7AJz0xxL4g3wk4ijwDpmfwmZpepWNac4czCMrC9pAV2g15zVMPvIZN3jErocti+owL8XST3OOtnGWgL66OkJTfHEHhSIcOOd4W6BVpaDneeYDXTmo4gr+5hpAfY9d65nj1U9AdbxVnGPhm5a8L/RlPAO3JUi2UjmFPssUs01S25Hi0gj6zBnRa+YZc+djZJYVaywwvRjhDl3Mk5TQu+5/zk8PtQN/biReZ6fSxKRpt0hz+Abcy55stfM3XBvDTO92Zq4KasMJe9CwG+OKGEt9jDVwc+8ZzZsZstZepzmEx0fNi3AvoN0ztvWsbzg2NEyIIJkNkOXh73P+d5BbjlqwfyGnY9fzjC7uLslT2bYfcm+kWvFFg3PdPVdxDjqg/kWPLsmdevp/9jFT2/t9L/z/wt1eJ9GAHicY2BmAIP/WxmMGDCBNgAs7QIVeJw1ybEOwVAYBeBz6297tYJFDMSCoIuYJBZX3c1EDO3cPoBH6CLpwrP0RiStpLu3wqX+s5zz/djleB4Cxdg1zFjBwRGdFGz/jpU3IHi6C2dNcz60OjY5FWyNpTWjvvkF1y/baKAOMwHB/UjLLyGqaClQA6QasXQfZCIN9I6lmuqdc/wAMuypiaYHT8BIpNHx/9AnnI2xsMbUNanp5ex1zuiiDMibGVuQ8g1Ioi18AAA=) format(\"woff\"); font-weight:normal;font-style:normal;}</style>';\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/svgs/Handle/HandleSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GintoNordFontSVG} from './GintoNordFontSVG.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\nlibrary HandleSVG {\n    using Strings for uint256;\n    uint256 constant MAX_WIDTH = 275;\n\n    enum FaceColors {\n        GREEN,\n        PEACH,\n        PURPLE,\n        BLUE,\n        GOLD,\n        BLACK\n    }\n\n    function getHandleSVG(string memory localName) public pure returns (string memory) {\n        FaceColors baseColor = getBaseColor(localName);\n        if (baseColor == FaceColors.GOLD) {\n            return getGoldHandleSVG(localName);\n        } else if (baseColor == FaceColors.BLACK) {\n            return getBlackHandleSVG(localName);\n        } else {\n            return getBaseHandleSVG(localName, baseColor);\n        }\n    }\n\n    function getGoldHandleSVG(string memory localName) internal pure returns (string memory) {\n        return\n            string.concat(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"275\" height=\"275\" fill=\"none\"><style>text {fill: #B96326}</style><g><path fill=\"url(#b)\" d=\"M197.7 162.1a2 2 0 0 1-3.5-1.4v-5.3c-2-72.3-111.4-72.3-113.4 0v5.3a2 2 0 0 1-3.5 1.4l-3.7-3.7c-52.8-49.7-130 27.4-80.2 80l3.7 3.7c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60a156 156 0 0 0 3.7-3.8c49.8-52.5-27.5-129.6-80.1-79.9a115 115 0 0 0-3.8 3.7Z\"/><circle cx=\"6.3\" cy=\"6.3\" r=\"6.3\" fill=\"#fff\" fill-opacity=\".5\" transform=\"matrix(-1 0 0 1 285.5 195.5)\"/><path fill=\"#fff\" fill-opacity=\".5\" d=\"M279.6 182a7.7 7.7 0 0 1-14 6.4l-.2-.3a34.7 34.7 0 0 0-2.2-4 28 28 0 0 0-11.5-11l-2.8-1.5a4.7 4.7 0 0 1-2.1-6.3l.2-.4c1.1-2.3 0-5.1-2.5-5.5-2.9-.4-5.3-.5-7.9-.3a2.8 2.8 0 0 1-.6-5.5 37 37 0 0 1 26.1 7.5 46 46 0 0 1 17.2 20.3l.3.4v.1\"/><path stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6.3\" d=\"M197.7 162.1v0a2 2 0 0 1-3.5-1.4v0-5.3c-2-72.3-111.4-72.3-113.4 0v5.3a2 2 0 0 1-3.5 1.4v0l-3.7-3.7c-52.8-49.7-130 27.4-80.2 80l3.7 3.7c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60a156 156 0 0 0 3.7-3.8c49.8-52.5-27.5-129.6-80.1-79.9a115 115 0 0 0-3.8 3.7Z\"/><path stroke=\"#B96326\" stroke-linecap=\"round\" stroke-width=\"4.7\" d=\"M115.5 247.2s6.8 9.4 22 9.4 22-9.4 22-9.4\"/><path stroke=\"#B96326\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"3.9\" d=\"M112.4 247.2a7.3 7.3 0 0 0 3.1-3.2m47.1 3.2a7.3 7.3 0 0 1-3.1-3.2\"/><path fill=\"#B96326\" fill-rule=\"evenodd\" d=\"M120.4 215.7c1-.5 1.7-1.7 1.3-2.7-2.2-5.8-7-9.8-12.7-9.8-7.7 0-13.9 7.3-13.9 16.3S101.3 236 109 236c5.4 0 10.2-3.7 12.4-9.2.5-1-.1-2.3-1.2-2.7l-5.6-2.4a1.9 1.9 0 0 1 0-3.5l5.8-2.4Zm32.6 3.8c0-9 6.3-16.3 14-16.3 5.7 0 10.7 4.3 12.8 10.3.4 1-.2 2.2-1.3 2.6l-4.7 2a1.9 1.9 0 0 0 0 3.5l4.5 2c1 .4 1.7 1.5 1.3 2.6-2.2 5.7-7 9.7-12.7 9.7-7.6 0-13.9-7.3-13.9-16.4Z\" clip-rule=\"evenodd\"/><path fill=\"#DF772C\" fill-opacity=\".3\" d=\"M90 239.6a2.3 2.3 0 1 1-4-2.3 2.3 2.3 0 0 1 4 2.3Zm8 4.6a2.3 2.3 0 1 1-4-2.3 2.3 2.3 0 0 1 4 2.3Zm-7.1 3.1a2.3 2.3 0 1 1-4-2.3 2.3 2.3 0 0 1 4 2.3Zm87-5.3a2.3 2.3 0 1 1-4 2.2 2.3 2.3 0 0 1 4-2.3Zm8-4.7a2.3 2.3 0 1 1-4 2.3 2.3 2.3 0 0 1 4-2.3Zm-.9 7.7a2.3 2.3 0 1 1-4 2.3 2.3 2.3 0 0 1 4-2.3Z\"/><path fill=\"#fff\" stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"5.5\" d=\"M-1.8 135.6c.2-.4.9-.4 1 0A30 30 0 0 0 17 154.4c.2 0 .2.2 0 .2l-.8.3c-7.8 2.8-14 9.3-16.7 17.8h0c-.1.4-.6.4-.8 0-3-8.8-9.4-16-17.7-19a.2.2 0 0 1 0-.3h.4a28.1 28.1 0 0 0 17-17.8Z\"/><path fill=\"#fff\" stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"4.7\" d=\"M8 185.1c.2-.3.6-.2.7 0A19 19 0 0 0 19.9 197v.1l-.6.2c-5 1.8-8.8 6-10.5 11.2v.1c0 .2-.4.2-.5 0a19 19 0 0 0-11.2-12v-.2h.2c5-1.8 9-6 10.8-11.3Z\"/><path fill=\"url(#c)\" d=\"M0 .5h275v275H0z\"/><path fill=\"url(#e)\" d=\"M197.7 162.1a2 2 0 0 1-3.5-1.4v-5.3c-2-72.3-111.4-72.3-113.4 0v5.3a2 2 0 0 1-3.5 1.4l-3.7-3.7c-52.8-49.7-130 27.4-80.2 80l3.7 3.7c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60a156 156 0 0 0 3.7-3.8c49.8-52.5-27.5-129.6-80.1-79.9a115 115 0 0 0-3.8 3.7Z\"/><circle cx=\"6.3\" cy=\"6.3\" r=\"6.3\" fill=\"#fff\" fill-opacity=\".5\" transform=\"matrix(-1 0 0 1 285.5 195.5)\"/><path fill=\"#fff\" fill-opacity=\".5\" d=\"M279.6 182a7.7 7.7 0 0 1-14 6.4l-.2-.3a34.7 34.7 0 0 0-2.2-4 28 28 0 0 0-11.5-11l-2.8-1.5a4.7 4.7 0 0 1-2.1-6.3l.2-.4c1.1-2.3 0-5.1-2.5-5.5-2.9-.4-5.3-.5-7.9-.3a2.8 2.8 0 0 1-.6-5.5 37 37 0 0 1 26.1 7.5 46 46 0 0 1 17.2 20.3l.3.4v.1\"/><path stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6.3\" d=\"M197.7 162.1v0a2 2 0 0 1-3.5-1.4v0-5.3c-2-72.3-111.4-72.3-113.4 0v5.3a2 2 0 0 1-3.5 1.4v0l-3.7-3.7c-52.8-49.7-130 27.4-80.2 80l3.7 3.7c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60a156 156 0 0 0 3.7-3.8c49.8-52.5-27.5-129.6-80.1-79.9a115 115 0 0 0-3.8 3.7Z\"/><path stroke=\"#B96326\" stroke-linecap=\"round\" stroke-width=\"4.7\" d=\"M115.5 247.2s6.8 9.4 22 9.4 22-9.4 22-9.4\"/><path stroke=\"#B96326\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"3.9\" d=\"M112.4 247.2a7.3 7.3 0 0 0 3.1-3.2m47.1 3.2a7.3 7.3 0 0 1-3.1-3.2\"/><path fill=\"#B96326\" fill-rule=\"evenodd\" d=\"M120.4 215.7c1-.5 1.7-1.7 1.3-2.7-2.2-5.8-7-9.8-12.7-9.8-7.7 0-13.9 7.3-13.9 16.3S101.3 236 109 236c5.4 0 10.2-3.7 12.4-9.2.5-1-.1-2.3-1.2-2.7l-5.6-2.4a1.9 1.9 0 0 1 0-3.5l5.8-2.4Zm32.6 3.8c0-9 6.3-16.3 14-16.3 5.7 0 10.7 4.3 12.8 10.3.4 1-.2 2.2-1.3 2.6l-4.7 2a1.9 1.9 0 0 0 0 3.5l4.5 2c1 .4 1.7 1.5 1.3 2.6-2.2 5.7-7 9.7-12.7 9.7-7.6 0-13.9-7.3-13.9-16.4Z\" clip-rule=\"evenodd\"/><path fill=\"#fff\" stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6\" d=\"M24.3 123.8c.1-.5.8-.5.9 0a28.1 28.1 0 0 0 16.6 17.5v.2l-.8.3c-7.4 2.7-13 8.7-15.6 16.6v.1c-.2.4-.6.4-.8 0-2.7-8.3-8.8-15-16.6-17.8a.1.1 0 0 1 0-.3h.4a25.8 25.8 0 0 0 15.9-16.6Z\"/><path fill=\"#fff\" stroke=\"#B96326\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"4\" d=\"M35 174.4c0-.3.5-.3.5 0 1.8 5.2 5.7 9.3 10.5 11v.2l-.5.2a16.3 16.3 0 0 0-9.8 10.5h0c-.1.2-.4.3-.5 0a17.8 17.8 0 0 0-10.5-11.2v-.2h.2c4.7-1.7 8.4-5.5 10-10.5Z\"/>',\n                getTextElement(localName),\n                '</g><defs>',\n                GintoNordFontSVG.getFontStyle(),\n                '<radialGradient id=\"b\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"scale(320 201) rotate(90 0 .5)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFDB76\"/><stop offset=\"1\" stop-color=\"#F8C944\"/></radialGradient><radialGradient id=\"c\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275.5)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFE7A5\"/><stop offset=\"1\" stop-color=\"#FFF2CE\"/></radialGradient><radialGradient id=\"e\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"scale(320 201) rotate(90 0 .5)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFDB76\"/><stop offset=\"1\" stop-color=\"#F8C944\"/></radialGradient></defs></svg>'\n            );\n    }\n\n    function getBlackHandleSVG(string memory localName) internal pure returns (string memory) {\n        return\n            string.concat(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"275\" height=\"275\" fill=\"none\"><style>text {fill: #fff}</style><g><path fill=\"url(#b)\" d=\"M0 0h275v275H0z\"/><path fill=\"url(#d)\" fill-opacity=\".7\" d=\"M197.7 161.5a2 2 0 0 1-3.5-1.5v-5.2c-2-72.4-111.4-72.4-113.4 0v5.2a2 2 0 0 1-3.5 1.5l-3.7-3.7c-52.8-49.8-130 27.4-80.2 79.9l3.7 3.8c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60l3.7-3.8c49.8-52.6-27.4-129.7-80.1-80l-3.8 3.8Z\"/><circle cx=\"6.3\" cy=\"6.3\" r=\"6.3\" fill=\"#fff\" fill-opacity=\".5\" transform=\"matrix(-1 0 0 1 285.5 194.8)\"/><path fill=\"#fff\" fill-opacity=\".5\" d=\"M279.6 181.3a7.7 7.7 0 0 1-14 6.4l-.2-.2a34.7 34.7 0 0 0-2.2-4.1 28 28 0 0 0-11.5-11l-2.8-1.4a4.7 4.7 0 0 1-2.1-6.3l.2-.5c1.1-2.2 0-5-2.5-5.4-2.9-.5-5.3-.6-7.9-.3a2.8 2.8 0 0 1-.6-5.5 37 37 0 0 1 26.1 7.5 46 46 0 0 1 17.2 20.3c.2.1.2.3.3.4v.1\"/><path stroke=\"#1D1D1D\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6.3\" d=\"M197.7 161.5v0a2 2 0 0 1-3.5-1.5v0-5.2c-2-72.4-111.4-72.4-113.4 0v5.2a2 2 0 0 1-3.5 1.5v0l-3.7-3.7c-52.8-49.8-130 27.4-80.2 79.9l3.7 3.8c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60l3.7-3.8c49.8-52.6-27.4-129.7-80.1-80l-3.8 3.8Z\"/><path stroke=\"#1D1D1D\" stroke-linecap=\"round\" stroke-width=\"4.7\" d=\"M115.5 246.5s6.8 9.5 22 9.5 22-9.5 22-9.5\"/><path stroke=\"#1D1D1D\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"3.9\" d=\"M112.4 246.5a7.3 7.3 0 0 0 3.1-3.1m47.1 3.1a7.3 7.3 0 0 1-3.1-3.1\"/><path fill=\"#1D1D1D\" fill-rule=\"evenodd\" d=\"M120.4 215c1-.4 1.7-1.6 1.3-2.7-2.2-5.7-7-9.7-12.7-9.7-7.7 0-13.9 7.3-13.9 16.3s6.2 16.3 13.9 16.3c5.5 0 10.2-3.7 12.4-9.1.5-1.1-.1-2.3-1.2-2.8l-5.6-2.4a1.9 1.9 0 0 1 0-3.4l5.8-2.5Zm32.6 3.9c0-9 6.3-16.3 14-16.3 5.7 0 10.7 4.2 12.8 10.2.4 1.1-.2 2.2-1.3 2.7l-4.7 2a1.9 1.9 0 0 0 0 3.4l4.5 2c1 .4 1.7 1.6 1.3 2.7-2.2 5.7-7 9.6-12.7 9.6-7.6 0-13.9-7.3-13.9-16.3Z\" clip-rule=\"evenodd\"/><path fill=\"#fff\" stroke=\"#1D1D1D\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6\" d=\"M27.7 123.8c.1-.5.7-.5.9 0a28.1 28.1 0 0 0 16.6 17.5v.2l-.8.3c-7.4 2.7-13 8.7-15.6 16.6v.1c-.2.4-.6.4-.8 0-2.7-8.3-8.8-15-16.6-17.8a.1.1 0 0 1 0-.3h.4a25.8 25.8 0 0 0 15.9-16.6Z\"/><path fill=\"#fff\" stroke=\"#1D1D1D\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"4\" d=\"M38.3 174.4c.1-.3.6-.3.6 0 1.8 5.2 5.7 9.3 10.5 11v.2l-.5.2a16.3 16.3 0 0 0-9.8 10.5h0c-.1.2-.4.3-.5 0A17.8 17.8 0 0 0 28 185.1v-.2h.2c4.7-1.7 8.4-5.5 10-10.5Z\"/>',\n                getTextElement(localName),\n                '</g><defs>',\n                GintoNordFontSVG.getFontStyle(),\n                '<radialGradient id=\"b\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275.5)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#1D1D1D\"/><stop offset=\"1\" stop-color=\"#313131\"/></radialGradient><radialGradient id=\"d\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(0 -266 424 0 169.6 372.4)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#fff\" stop-opacity=\"0\"/><stop offset=\"1\" stop-color=\"#fff\"/></radialGradient></defs></svg>'\n            );\n    }\n\n    function getBaseHandleSVG(string memory localName, FaceColors baseColor) internal pure returns (string memory) {\n        return\n            string.concat(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"275\" height=\"275\" fill=\"none\"><g>',\n                getBaseBg(baseColor),\n                getLensBaseFace(baseColor),\n                getTextElement(localName),\n                '</g><defs>',\n                GintoNordFontSVG.getFontStyle(),\n                getBaseGradients(),\n                '</defs></svg>'\n            );\n    }\n\n    function getBaseColor(string memory localName) internal pure returns (FaceColors) {\n        uint256 chars = bytes(localName).length;\n        FaceColors[] memory colors = new FaceColors[](6);\n        colors[0] = FaceColors.GREEN;\n        colors[1] = FaceColors.BLACK;\n        colors[2] = FaceColors.GOLD;\n        colors[3] = FaceColors.BLUE;\n        colors[4] = FaceColors.PURPLE;\n        colors[5] = FaceColors.PEACH;\n        if (chars < 6) {\n            return colors[chars];\n        } else {\n            return FaceColors.GREEN;\n        }\n    }\n\n    function getBaseBg(FaceColors faceColor) internal pure returns (string memory) {\n        string memory bgName;\n        if (faceColor == FaceColors.GREEN) {\n            bgName = 'green';\n        } else if (faceColor == FaceColors.PEACH) {\n            bgName = 'peach';\n        } else if (faceColor == FaceColors.PURPLE) {\n            bgName = 'purple';\n        } else if (faceColor == FaceColors.BLUE) {\n            bgName = 'blue';\n        }\n        return string.concat('<path fill=\"url(#', bgName, ')\" d=\"M0 0h275v275H0z\"/>');\n    }\n\n    function getLensBaseFace(FaceColors faceColor) internal pure returns (string memory) {\n        return\n            string.concat(\n                '<path fill=\"',\n                getBaseFaceColor(faceColor),\n                '\" d=\"M197.7 161.5a2 2 0 0 1-3.5-1.5v-5.2c-2-72.4-111.4-72.4-113.4 0v5.2a2 2 0 0 1-3.5 1.5l-3.7-3.7c-52.8-49.8-130 27.4-80.2 79.9l3.7 3.8c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60l3.7-3.8c49.8-52.6-27.5-129.7-80.1-80a115 115 0 0 0-3.8 3.8Z\"/><circle cx=\"6.3\" cy=\"6.3\" r=\"6.3\" fill=\"#fff\" fill-opacity=\".5\" transform=\"matrix(-1 0 0 1 285.5 194.8)\"/><path fill=\"#fff\" fill-opacity=\".5\" d=\"M279.6 181.3a7.7 7.7 0 0 1-14 6.4 11.3 11.3 0 0 0-.6-1.1c-.5-.8-1-2-1.8-3.2a27.9 27.9 0 0 0-11.5-11l-2.8-1.4a4.7 4.7 0 0 1-2.1-6.3l.2-.5c1.1-2.2 0-5-2.5-5.4-2.9-.5-5.3-.6-7.9-.3a2.8 2.8 0 0 1-.6-5.5 37 37 0 0 1 26.1 7.5 46 46 0 0 1 17.2 20.3l.3.4v.1\"/><path stroke=\"#000\" stroke-linecap=\"square\" stroke-linejoin=\"round\" stroke-width=\"6.3\" d=\"M197.7 161.5v0a2 2 0 0 1-3.5-1.5v0-5.2c-2-72.4-111.4-72.4-113.4 0v5.2a2 2 0 0 1-3.5 1.5v0l-3.7-3.7c-52.8-49.8-130 27.4-80.2 79.9l3.7 3.8c60.2 60 140.4 60 140.4 60s80.2 0 140.4-60l3.7-3.8c49.8-52.6-27.5-129.7-80.1-80a115 115 0 0 0-3.8 3.8Z\"/><path stroke=\"#000\" stroke-linecap=\"round\" stroke-width=\"4.7\" d=\"M115.5 246.5s6.8 9.5 22 9.5 22-9.5 22-9.5\"/><path stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"3.9\" d=\"M112.4 246.5a7.3 7.3 0 0 0 3.1-3.1m47.1 3.1a7.3 7.3 0 0 1-3.1-3.1\"/><path fill=\"#000\" fill-rule=\"evenodd\" d=\"M120.4 215c1-.4 1.7-1.6 1.3-2.7-2.2-5.7-7-9.7-12.7-9.7-7.7 0-13.9 7.3-13.9 16.3s6.2 16.3 13.9 16.3c5.4 0 10.2-3.7 12.4-9.1.5-1.1-.1-2.3-1.2-2.8l-5.6-2.4a1.9 1.9 0 0 1 0-3.4l5.8-2.5Zm32.6 3.9c0-9 6.3-16.3 14-16.3 5.7 0 10.7 4.2 12.8 10.2.4 1.1-.2 2.2-1.3 2.7l-4.7 2a1.9 1.9 0 0 0 0 3.4l4.5 2c1 .4 1.7 1.6 1.3 2.7-2.2 5.7-7 9.6-12.7 9.6-7.6 0-13.9-7.3-13.9-16.3Z\" clip-rule=\"evenodd\"/>'\n            );\n    }\n\n    function getTextElement(string memory localName) internal pure returns (string memory) {\n        uint256 textWidth = getTextWidth(string.concat('@', localName));\n        string memory fontSize = '20';\n\n        if (textWidth > MAX_WIDTH) {\n            uint256 sampleTextWidthAt20 = getWidthFromFontsize(20);\n            uint256 scalingFactor = (textWidth * 1000) / sampleTextWidthAt20;\n            uint256 equivalentSampleTextWidth = (((MAX_WIDTH * 10000) / scalingFactor) + 5) / 10;\n            uint256 fontSize10x = getFontsizeFromWidth10x(equivalentSampleTextWidth);\n            fontSize = string.concat((fontSize10x / 10).toString(), '.', (fontSize10x % 10).toString());\n        }\n        return\n            string.concat(\n                '<text fill=\"black\" xml:space=\"preserve\" style=\"white-space: pre\" x=\"50%\" y=\"60\" text-anchor=\"middle\" font-family=\"Ginto Nord Medium\" font-size=\"',\n                fontSize,\n                '\" font-weight=\"500\" letter-spacing=\"-0.7px\">@',\n                localName,\n                '</text>'\n            );\n    }\n\n    function getBaseFaceColor(FaceColors faceColor) internal pure returns (string memory) {\n        if (faceColor == FaceColors.GREEN) {\n            return '#A0D170';\n        } else if (faceColor == FaceColors.PEACH) {\n            return '#FFD5D2';\n        } else if (faceColor == FaceColors.PURPLE) {\n            return '#EAD7FF';\n        } else if (faceColor == FaceColors.BLUE) {\n            return '#D9E0FF';\n        } else {\n            revert(); // Avoid warnings.\n        }\n    }\n\n    function getBaseGradients() internal pure returns (string memory) {\n        return\n            '<radialGradient id=\"green\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#DFFFBF\"/><stop offset=\"1\" stop-color=\"#EFD\"/></radialGradient><radialGradient id=\"peach\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FFDFDD\"/><stop offset=\"1\" stop-color=\"#FFF0EF\"/></radialGradient><radialGradient id=\"purple\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#F1E4FF\"/><stop offset=\"1\" stop-color=\"#F8F1FF\"/></radialGradient><radialGradient id=\"blue\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(275 -275 362 362 0 275)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#E6EAFF\"/><stop offset=\"1\" stop-color=\"#EFF2FF\"/></radialGradient>';\n    }\n\n    struct CharWidth {\n        bytes1 char;\n        uint256 width;\n    }\n\n    function getCharWidth(bytes1 char) internal pure returns (uint256) {\n        CharWidth[] memory chars = new CharWidth[](39);\n        chars[0] = CharWidth('0', 16);\n        chars[1] = CharWidth('1', 9);\n        chars[2] = CharWidth('2', 16);\n        chars[3] = CharWidth('3', 16);\n        chars[4] = CharWidth('4', 16);\n        chars[5] = CharWidth('5', 16);\n        chars[6] = CharWidth('6', 16);\n        chars[7] = CharWidth('7', 16);\n        chars[8] = CharWidth('8', 16);\n        chars[9] = CharWidth('9', 16);\n        chars[10] = CharWidth('a', 16);\n        chars[11] = CharWidth('b', 16);\n        chars[12] = CharWidth('c', 16);\n        chars[13] = CharWidth('d', 16);\n        chars[14] = CharWidth('e', 16);\n        chars[15] = CharWidth('f', 16);\n        chars[16] = CharWidth('g', 16);\n        chars[17] = CharWidth('h', 16);\n        chars[18] = CharWidth('i', 7);\n        chars[19] = CharWidth('j', 7);\n        chars[20] = CharWidth('k', 16);\n        chars[21] = CharWidth('l', 7);\n        chars[22] = CharWidth('m', 23);\n        chars[23] = CharWidth('n', 16);\n        chars[24] = CharWidth('o', 16);\n        chars[25] = CharWidth('p', 16);\n        chars[26] = CharWidth('q', 16);\n        chars[27] = CharWidth('r', 11);\n        chars[28] = CharWidth('s', 16);\n        chars[29] = CharWidth('t', 11);\n        chars[30] = CharWidth('u', 16);\n        chars[31] = CharWidth('v', 16);\n        chars[32] = CharWidth('w', 23);\n        chars[33] = CharWidth('x', 16);\n        chars[34] = CharWidth('y', 16);\n        chars[35] = CharWidth('z', 16);\n        chars[36] = CharWidth('@', 21);\n        chars[37] = CharWidth('_', 16);\n        chars[38] = CharWidth('-', 11);\n        for (uint i = 0; i < chars.length; i++) {\n            if (chars[i].char == char) {\n                return chars[i].width;\n            }\n        }\n        revert(); // Avoid warnings.\n    }\n\n    function getWidthFromFontsize(uint256 fontSize) internal pure returns (uint256) {\n        return (((fontSize * 1244242 - 1075758 + 50000) / 10000) + 5) / 10;\n    }\n\n    function getFontsizeFromWidth10x(uint256 width) internal pure returns (uint256) {\n        return (((width * 10000000 + 107575800) / 1244242) + 5) / 10;\n    }\n\n    function getTextWidth(string memory text) internal pure returns (uint256) {\n        uint256 length = 0;\n        for (uint i = 0; i < bytes(text).length; i++) {\n            length += getCharWidth(bytes(text)[i]);\n        }\n        return length;\n    }\n\n    function getFittingLength(string memory text, uint256 maxWidth) internal pure returns (uint256) {\n        uint256 length = 0;\n        for (uint i = 0; i < bytes(text).length; i++) {\n            length += getCharWidth(bytes(text)[i]);\n            if (length > maxWidth) {\n                return i;\n            }\n        }\n        return bytes(text).length;\n    }\n\n    function splitTextToFit(string memory text) internal pure returns (string memory, string memory) {\n        uint256 length1 = getFittingLength(text, MAX_WIDTH - 21); // 21px is @ width\n        bytes memory text1Bytes = new bytes(length1);\n        for (uint i = 0; i < length1; i++) {\n            text1Bytes[i] = bytes(text)[i];\n        }\n        string memory text1 = string.concat('@', string(text1Bytes));\n\n        uint256 length2 = bytes(text).length - length1;\n        bytes memory text2Bytes = new bytes(length2);\n        for (uint i = 0; i < length2; i++) {\n            text2Bytes[i] = bytes(text)[length1 + i];\n        }\n        string memory text2 = string(text2Bytes);\n\n        if (getTextWidth(text2) <= MAX_WIDTH) {\n            return (text1, text2);\n        } else {\n            uint256 length3 = getFittingLength(text2, MAX_WIDTH - 18); // 18px is ... width\n            bytes memory text3Bytes = new bytes(length3);\n            for (uint i = 0; i < length3; i++) {\n                text3Bytes[i] = bytes(text2)[i];\n            }\n            string memory text3 = string.concat(string(text3Bytes), '...');\n\n            return (text1, text3);\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/libraries/svgs/Profile/SimpleProfileSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary SimpleProfileSVG {\n    function getProfileSVG(uint256 /* profileId */, bytes32 /* blockSeed */) public pure returns (string memory, string memory) {\n        return ('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M5.52 19c.64-2.2 1.84-3 3.22-3h6.52c1.38 0 2.58.8 3.22 3\"/><circle cx=\"12\" cy=\"10\" r=\"3\"/><circle cx=\"12\" cy=\"12\" r=\"10\"/></svg>', '');\n    }\n}"
    },
    "lens-modules/contracts/libraries/ValidationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from './constants/Types.sol';\nimport {Errors} from './constants/Errors.sol';\nimport {StorageLib} from './StorageLib.sol';\nimport {ProfileLib} from './ProfileLib.sol';\nimport {PublicationLib} from './PublicationLib.sol';\n\n/**\n * @title ValidationLib\n * @author Lens Protocol\n */\nlibrary ValidationLib {\n    function validatePointedPub(uint256 profileId, uint256 pubId) internal view {\n        // If it is pointing to itself it will fail because it will return a non-existent type.\n        Types.PublicationType pointedPubType = PublicationLib.getPublicationType(profileId, pubId);\n        if (pointedPubType == Types.PublicationType.Nonexistent || pointedPubType == Types.PublicationType.Mirror) {\n            revert Errors.InvalidPointedPub();\n        }\n    }\n\n    function validateAddressIsProfileOwner(address expectedProfileOwner, uint256 profileId) internal view {\n        if (expectedProfileOwner != ProfileLib.ownerOf(profileId)) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function validateAddressIsProfileOwnerOrDelegatedExecutor(\n        address expectedOwnerOrDelegatedExecutor,\n        uint256 profileId\n    ) internal view {\n        if (expectedOwnerOrDelegatedExecutor != ProfileLib.ownerOf(profileId)) {\n            validateAddressIsDelegatedExecutor({\n                expectedDelegatedExecutor: expectedOwnerOrDelegatedExecutor,\n                delegatorProfileId: profileId\n            });\n        }\n    }\n\n    function validateAddressIsDelegatedExecutor(\n        address expectedDelegatedExecutor,\n        uint256 delegatorProfileId\n    ) internal view {\n        if (!ProfileLib.isExecutorApproved(delegatorProfileId, expectedDelegatedExecutor)) {\n            revert Errors.ExecutorInvalid();\n        }\n    }\n\n    function validateProfileCreatorWhitelisted(address profileCreator) internal view {\n        if (!StorageLib.profileCreatorWhitelisted()[profileCreator]) {\n            revert Errors.NotWhitelisted();\n        }\n    }\n\n    function validateNotBlocked(uint256 profile, uint256 byProfile) internal view {\n        // By default, block validation is bidirectional, meaning interactions are restricted in both ways.\n        validateNotBlocked({profile: profile, byProfile: byProfile, unidirectionalCheck: false});\n    }\n\n    function validateNotBlocked(uint256 profile, uint256 byProfile, bool unidirectionalCheck) internal view {\n        if (\n            profile != byProfile &&\n            (StorageLib.blockedStatus(byProfile)[profile] ||\n                (!unidirectionalCheck && StorageLib.blockedStatus(profile)[byProfile]))\n        ) {\n            revert Errors.Blocked();\n        }\n    }\n\n    function validateProfileExists(uint256 profileId) internal view {\n        if (!ProfileLib.exists(profileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n    }\n\n    function validateCallerIsGovernance() internal view {\n        if (msg.sender != StorageLib.getGovernance()) {\n            revert Errors.NotGovernance();\n        }\n    }\n\n    function validateReferrersAndGetReferrersPubTypes(\n        uint256[] memory referrerProfileIds,\n        uint256[] memory referrerPubIds,\n        uint256 targetedProfileId,\n        uint256 targetedPubId\n    ) internal view returns (Types.PublicationType[] memory) {\n        if (referrerProfileIds.length != referrerPubIds.length) {\n            revert Errors.ArrayMismatch();\n        }\n        Types.PublicationType[] memory referrerPubTypes = new Types.PublicationType[](referrerProfileIds.length);\n\n        // We decided not to check for duplicate referrals here due to gas cost. If transient storage opcodes (EIP-1153)\n        // get included into the VM, this could be updated to implement an efficient duplicate check mechanism.\n        // For now, if a module strongly needs to avoid duplicate referrals, it can check for them at its own expense.\n\n        uint256 referrerProfileId;\n        uint256 referrerPubId;\n        uint256 i;\n        while (i < referrerProfileIds.length) {\n            referrerProfileId = referrerProfileIds[i];\n            referrerPubId = referrerPubIds[i];\n            referrerPubTypes[i] = _validateReferrerAndGetReferrerPubType(\n                referrerProfileId,\n                referrerPubId,\n                targetedProfileId,\n                targetedPubId\n            );\n            unchecked {\n                i++;\n            }\n        }\n        return referrerPubTypes;\n    }\n\n    function validateLegacyCollectReferrer(\n        uint256 referrerProfileId,\n        uint256 referrerPubId,\n        uint256 publicationCollectedProfileId,\n        uint256 publicationCollectedId\n    ) external view {\n        if (\n            !ProfileLib.exists(referrerProfileId) ||\n            PublicationLib.getPublicationType(referrerProfileId, referrerPubId) != Types.PublicationType.Mirror\n        ) {\n            revert Errors.InvalidReferrer();\n        }\n        Types.Publication storage _referrerMirror = StorageLib.getPublication(referrerProfileId, referrerPubId);\n        // A mirror can only be a referrer of a legacy publication if it is pointing to it.\n        if (\n            _referrerMirror.pointedProfileId != publicationCollectedProfileId ||\n            _referrerMirror.pointedPubId != publicationCollectedId\n        ) {\n            revert Errors.InvalidReferrer();\n        }\n    }\n\n    function _validateReferrerAndGetReferrerPubType(\n        uint256 referrerProfileId,\n        uint256 referrerPubId,\n        uint256 targetedProfileId,\n        uint256 targetedPubId\n    ) private view returns (Types.PublicationType) {\n        if (referrerPubId == 0) {\n            // Unchecked/Unverified referral. Profile referrer, not attached to a publication.\n            if (!ProfileLib.exists(referrerProfileId) || referrerProfileId == targetedProfileId) {\n                revert Errors.InvalidReferrer();\n            }\n            return Types.PublicationType.Nonexistent;\n        } else {\n            // Checked/Verified referral. Publication referrer.\n            if (\n                // Cannot pass the targeted publication as a referrer.\n                referrerProfileId == targetedProfileId && referrerPubId == targetedPubId\n            ) {\n                revert Errors.InvalidReferrer();\n            }\n            Types.PublicationType referrerPubType = PublicationLib.getPublicationType(referrerProfileId, referrerPubId);\n            if (referrerPubType == Types.PublicationType.Nonexistent) {\n                revert Errors.InvalidReferrer();\n            }\n            if (referrerPubType == Types.PublicationType.Post) {\n                _validateReferrerAsPost(referrerProfileId, referrerPubId, targetedProfileId, targetedPubId);\n            } else {\n                _validateReferrerAsMirrorOrCommentOrQuote(\n                    referrerProfileId,\n                    referrerPubId,\n                    targetedProfileId,\n                    targetedPubId\n                );\n            }\n            return referrerPubType;\n        }\n    }\n\n    function _validateReferrerAsPost(\n        uint256 referrerProfileId,\n        uint256 referrerPubId,\n        uint256 targetedProfileId,\n        uint256 targetedPubId\n    ) private view {\n        Types.Publication storage _targetedPub = StorageLib.getPublication(targetedProfileId, targetedPubId);\n        // Publication targeted must have the referrer post as the root. This enables the use case of rewarding the\n        // root publication for an action over any of its descendants.\n        if (_targetedPub.rootProfileId != referrerProfileId || _targetedPub.rootPubId != referrerPubId) {\n            revert Errors.InvalidReferrer();\n        }\n    }\n\n    /**\n     * @dev Validates that the referrer publication and the interacted publication are linked.\n     *\n     * @param referrerProfileId The profile id of the referrer.\n     * @param referrerPubId The publication id of the referrer.\n     * @param targetedProfileId The ID of the profile who authored the publication being acted or referenced.\n     * @param targetedPubId The pub ID being acted or referenced.\n     */\n    function _validateReferrerAsMirrorOrCommentOrQuote(\n        uint256 referrerProfileId,\n        uint256 referrerPubId,\n        uint256 targetedProfileId,\n        uint256 targetedPubId\n    ) private view {\n        Types.Publication storage _referrerPub = StorageLib.getPublication(referrerProfileId, referrerPubId);\n        // A mirror/quote/comment is allowed to be a referrer of a publication if it is pointing to it...\n        if (_referrerPub.pointedProfileId != targetedProfileId || _referrerPub.pointedPubId != targetedPubId) {\n            // ...or if the referrer pub's root is the target pub (i.e. target pub is a Lens V2 post)...\n            if (_referrerPub.rootProfileId != targetedProfileId || _referrerPub.rootPubId != targetedPubId) {\n                Types.Publication storage _targetedPub = StorageLib.getPublication(targetedProfileId, targetedPubId);\n                // ...or if the referrer pub shares the root with the target pub.\n                if (\n                    // Here the target pub must be a \"pure\" Lens V2 comment/quote, which means there is no\n                    // Lens V1 Legacy comment or post on its tree of interactions, and its root pub is filled.\n                    // Otherwise, two Lens V2 \"non-pure\" publications could be passed as a referrer to each other,\n                    // even without having any interaction in common, as they would share the root as zero.\n                    _referrerPub.rootPubId == 0 ||\n                    // The referrer publication and the target publication must share the same root.\n                    _referrerPub.rootProfileId != _targetedPub.rootProfileId ||\n                    _referrerPub.rootPubId != _targetedPub.rootPubId\n                ) {\n                    revert Errors.InvalidReferrer();\n                }\n            }\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/misc/access/LitAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ILensHub} from '../../interfaces/ILensHub.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {CollectPublicationAction} from '../../modules/act/collect/CollectPublicationAction.sol';\n\n/**\n * @title LitAccessControl\n * @author Lens Protocol\n *\n * @notice This contract enables additional access control for encrypted publications on Lens by reporting whether\n *      an address owns or has control over a given profile.\n *\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract LitAccessControl {\n    address internal immutable LENS_HUB;\n    address internal immutable COLLECT_PUB_ACTION;\n\n    constructor(address lensHub, address collectPubAction) {\n        LENS_HUB = lensHub;\n        COLLECT_PUB_ACTION = collectPubAction;\n    }\n\n    /**\n     * @dev Function used to check whether an address is the Owner or Delegated Executor of a profile.\n     *\n     * @param requestorAddress The address to check ownership over a profile.\n     * @param profileId The ID of the profile being checked for ownership.\n     * param data Optional data parameter, which may be used in future upgrades.\n     * @return Boolean indicating whether address owns the profile or not.\n     */\n    function hasAccess(\n        address requestorAddress,\n        uint256 profileId,\n        bytes memory /* data */\n    ) external view returns (bool) {\n        return _isOwnerOrDelegatedExecutor(requestorAddress, profileId);\n    }\n\n    /**\n     * @dev Function used to check whether followerProfileId is following profileId and requestor is Owner/Delegated\n     * Executor of followerProfileId.\n     *\n     * @param requestorAddress The address to check ownership over a profile.\n     * @param profileId The ID of the profile being followed.\n     * @param followerProfileId The ID of the following profile.\n     * param data Optional data parameter, which may be used in future upgrades.\n     */\n    function isFollowing(\n        address requestorAddress,\n        uint256 profileId,\n        uint256 followerProfileId,\n        bytes memory /*data*/\n    ) external view returns (bool) {\n        if (\n            // If profile is following and requestor is Owner/Delegated Executor of the follower profile, allow access\n            ILensHub(LENS_HUB).isFollowing(followerProfileId, profileId) &&\n            _isOwnerOrDelegatedExecutor(requestorAddress, followerProfileId)\n        ) {\n            return true;\n        } else {\n            // If not following, but is the Owner/Delegated Executor of the target profile, then still allow access\n            return _isOwnerOrDelegatedExecutor(requestorAddress, profileId);\n        }\n    }\n\n    /**\n     * @dev Function used to check whether an address owns or has collected the publication.\n     *\n     * @param requestorAddress The address to check if it owns the collect NFT of the publication.\n     * @param publisherId ID of the profile who is the publisher of the publication.\n     * @param pubId ID of the publication.\n     * @param collectorProfileId ID of the collector profile (optional, will check if the profile owner owns the NFT)\n     * param data Optional data parameter, which may be used in future upgrades.\n     * @return Boolean indicating whether address owns the collect NFT of the publication or not.\n     */\n    function hasCollected(\n        address requestorAddress,\n        uint256 publisherId,\n        uint256 pubId,\n        uint256 collectorProfileId,\n        bytes memory /* data */\n    ) external view returns (bool) {\n        // We get the collect NFT as if the publication is a Lens V2 one\n        address collectNFT = CollectPublicationAction(COLLECT_PUB_ACTION).getCollectData(publisherId, pubId).collectNFT;\n\n        if (collectNFT == address(0)) {\n            // If there is no collect NFT, we get the collect NFT of the publication as a Lens V1 one\n            collectNFT = ILensHub(LENS_HUB).getPublication(publisherId, pubId).__DEPRECATED__collectNFT;\n            if (collectNFT == address(0)) {\n                // If no collect NFT found in V1 nor V2, that means the publication was not collected\n                return false;\n            }\n        }\n\n        // We check if the requestor address has the collect NFT\n        if (IERC721(collectNFT).balanceOf(requestorAddress) > 0) {\n            return true;\n        }\n\n        // If the requestor address doesn't have the collect NFT,\n        // we check if the requestor address is the Owner/Delegated Executor of the collector profile,\n        // and then we check if the collector profile's owner holds the NFT\n        if (!_isOwnerOrDelegatedExecutor(requestorAddress, collectorProfileId)) {\n            return false;\n        }\n        return IERC721(collectNFT).balanceOf(IERC721(LENS_HUB).ownerOf(collectorProfileId)) > 0;\n    }\n\n    /**\n     * @dev Internal function used to check whether an address is the Owner or DelegatedExecutor of a profile.\n     *\n     * @param requestorAddress The address to check ownership over a profile.\n     * @param profileId The ID of the profile being checked for ownership.\n     * @return Boolean indicating whether address owns the profile or is DelegatedExecutor of it.\n     */\n    function _isOwnerOrDelegatedExecutor(address requestorAddress, uint256 profileId) internal view returns (bool) {\n        return\n            requestorAddress == IERC721(LENS_HUB).ownerOf(profileId) ||\n            ILensHub(LENS_HUB).isDelegatedExecutorApproved(profileId, requestorAddress);\n    }\n}\n"
    },
    "lens-modules/contracts/misc/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ncontract ImmutableOwnable {\n    address public immutable OWNER;\n    address public immutable LENS_HUB;\n\n    error OnlyOwner();\n    error OnlyOwnerOrHub();\n\n    modifier onlyOwner() {\n        if (msg.sender != OWNER) {\n            revert OnlyOwner();\n        }\n        _;\n    }\n\n    modifier onlyOwnerOrHub() {\n        if (msg.sender != OWNER && msg.sender != LENS_HUB) {\n            revert OnlyOwnerOrHub();\n        }\n        _;\n    }\n\n    constructor(address owner, address lensHub) {\n        OWNER = owner;\n        LENS_HUB = lensHub;\n    }\n}\n"
    },
    "lens-modules/contracts/misc/LegacyCollectNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ERC2981CollectionRoyalties} from '../base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {LensBaseERC721} from '../base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\n/**\n * @title CollectNFT\n * @author Lens Protocol\n *\n * @dev This is the Legacy CollectNFT that is used for Legacy Lens V1 publications. The new CollectNFT was introduced in\n * Lens V2 with the only difference that it is restricted by the Action Module instead of the LensHub.\n *\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\n */\ncontract LegacyCollectNFT is LensBaseERC721, ERC2981CollectionRoyalties, ICollectNFT {\n    using Strings for uint256;\n\n    address public immutable HUB;\n\n    uint256 internal _profileId;\n    uint256 internal _pubId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    uint256 internal _royaltiesInBasisPoints;\n\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\n    // to initialize the hub proxy at construction.\n    constructor(address hub) {\n        if (hub == address(0)) revert Errors.InitParamsInvalid();\n        HUB = hub;\n        _initialized = true;\n    }\n\n    /// @inheritdoc ICollectNFT\n    function initialize(uint256 profileId, uint256 pubId) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _setRoyalty(1000); // 10% of royalties\n        _profileId = profileId;\n        _pubId = pubId;\n        // _name and _symbol remain uninitialized because we override the getters below\n    }\n\n    /// @inheritdoc ICollectNFT\n    function mint(address to) external override returns (uint256) {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        unchecked {\n            uint256 tokenId = ++_tokenIdCounter;\n            _mint(to, tokenId);\n            return tokenId;\n        }\n    }\n\n    /// @inheritdoc ICollectNFT\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\n        return (_profileId, _pubId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return string.concat('Lens Collect | Profile #', _profileId.toString(), ' - Publication #', _pubId.toString());\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public pure override returns (string memory) {\n        return 'LENS-COLLECT';\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC2981CollectionRoyalties, LensBaseERC721)\n        returns (bool)\n    {\n        return\n            ERC2981CollectionRoyalties.supportsInterface(interfaceId) || LensBaseERC721.supportsInterface(interfaceId);\n    }\n\n    function _getReceiver(\n        uint256 /* tokenId */\n    ) internal view override returns (address) {\n        if (!ILensHub(HUB).exists(_profileId)) {\n            return address(0);\n        }\n        return IERC721(HUB).ownerOf(_profileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_profileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n}\n"
    },
    "lens-modules/contracts/misc/LensHubInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {LensHub} from '../LensHub.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {GovernanceLib} from '../libraries/GovernanceLib.sol';\nimport {ILensHubInitializable} from '../interfaces/ILensHubInitializable.sol';\nimport {VersionedInitializable} from '../base/upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHubInitializable\n * @author Lens Protocol\n *\n * @notice Extension of LensHub contract that includes initialization for fresh deployments.\n *\n * @custom:upgradeable Transparent upgradeable proxy.\n * See `../LensHub.sol` for the version without initalizer.\n */\ncontract LensHubInitializable is LensHub, VersionedInitializable, ILensHubInitializable {\n    // Constant for upgradeability purposes, see VersionedInitializable.\n    // Do not confuse it with the EIP-712 version number.\n    uint256 internal constant REVISION = 1;\n\n    constructor(\n        address followNFTImpl,\n        address collectNFTImpl,\n        address moduleRegistry,\n        uint256 tokenGuardianCooldown\n    ) LensHub(followNFTImpl, collectNFTImpl, moduleRegistry, tokenGuardianCooldown) {}\n\n    /**\n     * @inheritdoc ILensHubInitializable\n     * @custom:permissions Callable once. This is expected to be atomically called during the deployment by the Proxy.\n     */\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        GovernanceLib.initState(Types.ProtocolState.Paused);\n        GovernanceLib.setGovernance(newGovernance);\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n"
    },
    "lens-modules/contracts/misc/ModuleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IModuleRegistry} from '../interfaces/IModuleRegistry.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {ILensModule} from '../modules/interfaces/ILensModule.sol';\n\nimport {IPublicationActionModule} from '../interfaces/IPublicationActionModule.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n\n/**\n * @title ModuleRegistry\n * @author Lens Protocol\n * @notice A registry for modules and currencies\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract ModuleRegistry is IModuleRegistry {\n    bytes4 private constant LENS_MODULE_INTERFACE_ID = bytes4(keccak256(abi.encodePacked('LENS_MODULE')));\n\n    event ModuleRegistered(\n        address indexed moduleAddress,\n        uint256 indexed moduleType,\n        string metadata,\n        uint256 timestamp\n    );\n\n    event erc20CurrencyRegistered(\n        address indexed erc20CurrencyAddress,\n        string name,\n        string symbol,\n        uint8 decimals,\n        uint256 timestamp\n    );\n\n    event ModuleMetadataRefreshed(address indexed moduleAddress, string metadata, uint256 timestamp);\n\n    error NotLensModule();\n    error ModuleDoesNotSupportType(uint256 moduleType);\n    error ModuleNotRegistered();\n\n    mapping(address moduleAddress => uint256 moduleTypesBitmap) internal _registeredModules;\n\n    mapping(address erc20CurrencyAddress => bool) internal _registeredErc20Currencies;\n\n    // Modules\n\n    function verifyModule(address moduleAddress, uint256 moduleType) external returns (bool) {\n        registerModule(moduleAddress, moduleType);\n        return true;\n    }\n\n    function registerModule(address moduleAddress, uint256 moduleType) public returns (bool registrationWasPerformed) {\n        // This will fail if moduleType is out of range for `IModuleRegistry.ModuleType`\n        require(\n            moduleType > 0 && moduleType <= uint256(type(IModuleRegistry.ModuleType).max),\n            'Module Type out of bounds'\n        );\n\n        bool isAlreadyRegisteredAsThatType = _registeredModules[moduleAddress] & (1 << moduleType) != 0;\n        if (isAlreadyRegisteredAsThatType) {\n            return false;\n        } else {\n            if (!ILensModule(moduleAddress).supportsInterface(LENS_MODULE_INTERFACE_ID)) {\n                revert NotLensModule();\n            }\n\n            validateModuleSupportsType(moduleAddress, moduleType);\n\n            string memory metadata = ILensModule(moduleAddress).getModuleMetadataURI();\n            emit ModuleRegistered(moduleAddress, moduleType, metadata, block.timestamp);\n            _registeredModules[moduleAddress] |= (1 << moduleType);\n            return true;\n        }\n    }\n\n    function validateModuleSupportsType(address moduleAddress, uint256 moduleType) internal view {\n        bool supportsInterface;\n        if (moduleType == uint256(IModuleRegistry.ModuleType.PUBLICATION_ACTION_MODULE)) {\n            supportsInterface = ILensModule(moduleAddress).supportsInterface(\n                type(IPublicationActionModule).interfaceId\n            );\n        } else if (moduleType == uint256(IModuleRegistry.ModuleType.FOLLOW_MODULE)) {\n            supportsInterface = ILensModule(moduleAddress).supportsInterface(type(IFollowModule).interfaceId);\n        } else if (moduleType == uint256(IModuleRegistry.ModuleType.REFERENCE_MODULE)) {\n            supportsInterface = ILensModule(moduleAddress).supportsInterface(type(IReferenceModule).interfaceId);\n        }\n\n        if (!supportsInterface) {\n            revert ModuleDoesNotSupportType(moduleType);\n        }\n    }\n\n    function getModuleTypes(address moduleAddress) public view returns (uint256) {\n        return _registeredModules[moduleAddress];\n    }\n\n    function isModuleRegistered(address moduleAddress) external view returns (bool) {\n        return _registeredModules[moduleAddress] != 0;\n    }\n\n    function isModuleRegisteredAs(address moduleAddress, uint256 moduleType) public view returns (bool) {\n        require(moduleType <= type(uint8).max);\n        return _registeredModules[moduleAddress] & (1 << moduleType) != 0;\n    }\n\n    // Currencies\n\n    function verifyErc20Currency(address currencyAddress) external returns (bool) {\n        registerErc20Currency(currencyAddress);\n        return true;\n    }\n\n    function registerErc20Currency(address currencyAddress) public returns (bool registrationWasPerformed) {\n        bool isAlreadyRegistered = _registeredErc20Currencies[currencyAddress];\n        if (isAlreadyRegistered) {\n            return false;\n        } else {\n            uint8 decimals = IERC20Metadata(currencyAddress).decimals();\n            string memory name = IERC20Metadata(currencyAddress).name();\n            string memory symbol = IERC20Metadata(currencyAddress).symbol();\n\n            emit erc20CurrencyRegistered(currencyAddress, name, symbol, decimals, block.timestamp);\n            _registeredErc20Currencies[currencyAddress] = true;\n            return true;\n        }\n    }\n\n    function isErc20CurrencyRegistered(address currencyAddress) external view returns (bool) {\n        return _registeredErc20Currencies[currencyAddress];\n    }\n\n    function emitModuleMetadataRefresh(address moduleAddress) external {\n        if (_registeredModules[moduleAddress] == 0) {\n            revert ModuleNotRegistered();\n        }\n        emit ModuleMetadataRefreshed(moduleAddress, ILensModule(moduleAddress).getModuleMetadataURI(), block.timestamp);\n    }\n}\n"
    },
    "lens-modules/contracts/misc/PermissionlessCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Types} from '../libraries/constants/Types.sol';\n\nimport {ILensHandles} from '../interfaces/ILensHandles.sol';\nimport {ITokenHandleRegistry} from '../interfaces/ITokenHandleRegistry.sol';\nimport {ImmutableOwnable} from '../misc/ImmutableOwnable.sol';\n\n/**\n * @title PermissonlessCreator\n * @author Lens Protocol\n * @notice This is an ownable public proxy contract which is open for all.\n */\ncontract PermissionlessCreator is ImmutableOwnable {\n    ILensHandles public immutable LENS_HANDLES;\n    ITokenHandleRegistry public immutable TOKEN_HANDLE_REGISTRY;\n\n    // These should be configured through setters before being whitelisted in the LensHub.\n    uint128 private _profileCreationCost;\n    uint128 private _handleCreationCost;\n    uint8 private _handleLengthMin;\n\n    mapping(address => uint256) internal _credits;\n    mapping(address => bool) internal _isCreditProvider; // Credit providers can increase/decrease credits of users\n    mapping(address => bool) internal _isUntrusted;\n    mapping(uint256 => address) internal _profileCreatorUsingCredits; // The address that created the profile spending credits\n\n    modifier onlyCreditProviders() {\n        if (!_isCreditProvider[msg.sender]) {\n            revert OnlyCreditProviders();\n        }\n        _;\n    }\n\n    error OnlyCreditProviders();\n    error HandleAlreadyExists();\n    error InvalidFunds();\n    error InsufficientCredits();\n    error ProfileAlreadyLinked();\n    error HandleLengthNotAllowed();\n    error NotAllowed();\n\n    event HandleCreationPriceChanged(uint256 newPrice, uint256 timestamp);\n    event ProfileCreationPriceChanged(uint256 newPrice, uint256 timestamp);\n    event HandleLengthMinChanged(uint8 newMinLength, uint256 timestamp);\n    event CreditBalanceChanged(address indexed creditAddress, uint256 remainingCredits, uint256 timestamp);\n    event TrustStatusChanged(address indexed targetAddress, bool isUntrusted, uint256 timestamp);\n    event CreditProviderStatusChanged(address indexed creditProvider, bool isCreditProvider, uint256 timestamp);\n\n    event ProfileCreatedUsingCredits(uint256 indexed profileId, address indexed creator, uint256 timestamp);\n    event HandleCreatedUsingCredits(\n        uint256 indexed handleId,\n        string handle,\n        address indexed creator,\n        uint256 timestamp\n    );\n\n    constructor(\n        address owner,\n        address lensHub,\n        address lensHandles,\n        address tokenHandleRegistry\n    ) ImmutableOwnable(owner, lensHub) {\n        LENS_HANDLES = ILensHandles(lensHandles);\n        TOKEN_HANDLE_REGISTRY = ITokenHandleRegistry(tokenHandleRegistry);\n    }\n\n    /////////////////////////// Permissionless payable creation functions //////////////////////////////////////////////\n\n    function createProfile(\n        Types.CreateProfileParams calldata createProfileParams,\n        address[] calldata delegatedExecutors\n    ) external payable returns (uint256) {\n        _validatePayment(_profileCreationCost);\n        // delegatedExecutors are only allowed if to == msg.sender\n        if (delegatedExecutors.length > 0 && createProfileParams.to != msg.sender) {\n            revert NotAllowed();\n        }\n        return _createProfile(createProfileParams, delegatedExecutors);\n    }\n\n    function createHandle(address to, string calldata handle) external payable returns (uint256) {\n        _validatePayment(_handleCreationCost);\n        _validateHandleLength(handle);\n        return LENS_HANDLES.mintHandle(to, handle);\n    }\n\n    function createProfileWithHandle(\n        Types.CreateProfileParams calldata createProfileParams,\n        string calldata handle,\n        address[] calldata delegatedExecutors\n    ) external payable returns (uint256, uint256) {\n        _validatePayment(_profileCreationCost + _handleCreationCost);\n        _validateHandleLength(handle);\n        // delegatedExecutors are only allowed if to == msg.sender\n        if (delegatedExecutors.length > 0 && createProfileParams.to != msg.sender) {\n            revert NotAllowed();\n        }\n        return _createProfileWithHandle(createProfileParams, handle, delegatedExecutors);\n    }\n\n    ////////////////////////////// Credit based creation functions /////////////////////////////////////////////////////\n\n    function createProfileUsingCredits(\n        Types.CreateProfileParams calldata createProfileParams,\n        address[] calldata delegatedExecutors\n    ) external returns (uint256) {\n        _spendCredit(msg.sender);\n        uint256 profileId = _createProfile(createProfileParams, delegatedExecutors);\n        _profileCreatorUsingCredits[profileId] = msg.sender;\n        emit ProfileCreatedUsingCredits(profileId, msg.sender, block.timestamp);\n        return profileId;\n    }\n\n    function createProfileWithHandleUsingCredits(\n        Types.CreateProfileParams calldata createProfileParams,\n        string calldata handle,\n        address[] calldata delegatedExecutors\n    ) external returns (uint256, uint256) {\n        _spendCredit(msg.sender);\n        _validateHandleLength(handle);\n        (uint256 profileId, uint256 handleId) = _createProfileWithHandle(\n            createProfileParams,\n            handle,\n            delegatedExecutors\n        );\n        _profileCreatorUsingCredits[profileId] = msg.sender;\n        emit ProfileCreatedUsingCredits(profileId, msg.sender, block.timestamp);\n        emit HandleCreatedUsingCredits(handleId, handle, msg.sender, block.timestamp);\n        return (profileId, handleId);\n    }\n\n    function createHandleUsingCredits(address to, string calldata handle) external returns (uint256) {\n        _spendCredit(msg.sender);\n        _validateHandleLength(handle);\n        uint256 handleId = LENS_HANDLES.mintHandle(to, handle);\n        emit HandleCreatedUsingCredits(handleId, handle, msg.sender, block.timestamp);\n        return handleId;\n    }\n\n    ////////////////////////////////////////// Base functions //////////////////////////////////////////////////////////\n\n    function _createProfile(\n        Types.CreateProfileParams calldata createProfileParams,\n        address[] memory delegatedExecutors\n    ) internal returns (uint256) {\n        uint256 profileId;\n        if (delegatedExecutors.length == 0) {\n            profileId = ILensHub(LENS_HUB).createProfile(createProfileParams);\n        } else {\n            // We mint the profile to this contract first, then apply delegates if defined\n            // This will not allow to initialize follow modules that require funds from the msg.sender,\n            // but we assume only simple follow modules should be set during profile creation.\n            // Complex ones can be set after the profile is created.\n            address destination = createProfileParams.to;\n\n            // Copy the struct from calldata to memory to make it mutable\n            Types.CreateProfileParams memory createProfileParamsMemory = createProfileParams;\n            createProfileParamsMemory.to = address(this);\n\n            profileId = ILensHub(LENS_HUB).createProfile(createProfileParamsMemory);\n\n            _addDelegatesToProfile(profileId, delegatedExecutors);\n\n            // keep the config if its been set\n            ILensHub(LENS_HUB).transferFromKeepingDelegates(address(this), destination, profileId);\n        }\n        return profileId;\n    }\n\n    function _createProfileWithHandle(\n        Types.CreateProfileParams calldata createProfileParams,\n        string calldata handle,\n        address[] memory delegatedExecutors\n    ) private returns (uint256, uint256) {\n        // Copy the struct from calldata to memory to make it mutable\n        Types.CreateProfileParams memory createProfileParamsMemory = createProfileParams;\n\n        // We mint the handle & profile to this contract first, then link it to the profile and delegates if defined\n        // This will not allow to initialize follow modules that require funds from the msg.sender,\n        // but we assume only simple follow modules should be set during profile creation.\n        // Complex ones can be set after the profile is created.\n        address destination = createProfileParamsMemory.to;\n\n        createProfileParamsMemory.to = address(this);\n\n        uint256 profileId = ILensHub(LENS_HUB).createProfile(createProfileParamsMemory);\n        uint256 handleId = LENS_HANDLES.mintHandle(address(this), handle);\n\n        TOKEN_HANDLE_REGISTRY.link(handleId, profileId);\n\n        _addDelegatesToProfile(profileId, delegatedExecutors);\n\n        // Transfer the handle & profile to the destination\n        LENS_HANDLES.transferFrom(address(this), destination, handleId);\n        // keep the config if its been set\n        ILensHub(LENS_HUB).transferFromKeepingDelegates(address(this), destination, profileId);\n\n        return (profileId, handleId);\n    }\n\n    function _addDelegatesToProfile(uint256 profileId, address[] memory delegatedExecutors) private {\n        // set delegates if any\n        if (delegatedExecutors.length > 0) {\n            // Initialize an array of bools with the same length as delegatedExecutors\n            bool[] memory executorEnabled = new bool[](delegatedExecutors.length);\n\n            // Fill the array with `true`\n            for (uint256 i = 0; i < delegatedExecutors.length; i++) {\n                executorEnabled[i] = true;\n            }\n\n            ILensHub(LENS_HUB).changeDelegatedExecutorsConfig(profileId, delegatedExecutors, executorEnabled);\n        }\n    }\n\n    function _validateHandleLength(string calldata handle) private view {\n        if (!_isCreditProvider[msg.sender] && bytes(handle).length < _handleLengthMin) {\n            revert HandleLengthNotAllowed();\n        }\n    }\n\n    function _validatePayment(uint256 amount) private view {\n        if (msg.value < amount) {\n            revert InvalidFunds();\n        }\n    }\n\n    function _spendCredit(address account) private {\n        if (_isCreditProvider[msg.sender]) {\n            // Credit providers do not need credits.\n            return;\n        }\n        _credits[account] -= 1;\n        emit CreditBalanceChanged(account, _credits[account], block.timestamp);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Special function allowing to transfer a profile from one address to another, keeping the delegates.\n    /// @dev Requires the sender, a trusted credit-based creator, to approve the profile with this contract as spender.\n    function transferFromKeepingDelegates(address from, address to, uint256 tokenId) external {\n        if (_isUntrusted[msg.sender] || _profileCreatorUsingCredits[tokenId] != msg.sender) {\n            // If msg.sender trust was revoked or is not the original creator of the profile through credits, then fail.\n            revert NotAllowed();\n        }\n\n        ILensHub(LENS_HUB).transferFromKeepingDelegates(from, to, tokenId);\n    }\n\n    // Credit Provider functions\n\n    function increaseCredits(address account, uint256 amount) external onlyCreditProviders {\n        if (_isUntrusted[account]) {\n            // Cannot increase credits for an account with revoked trust.\n            revert NotAllowed();\n        }\n        _credits[account] += amount;\n        emit CreditBalanceChanged(account, _credits[account], block.timestamp);\n    }\n\n    function decreaseCredits(address account, uint256 amount) external onlyCreditProviders {\n        _credits[account] -= amount;\n        emit CreditBalanceChanged(account, _credits[account], block.timestamp);\n    }\n\n    // Owner functions\n\n    function withdrawFunds() external onlyOwner {\n        // Use call instead of transfer to provide more gas (otherwise it doesn't work with SAFE):\n        // https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\n        (bool success, ) = OWNER.call{value: address(this).balance}('');\n        if (!success) {\n            revert();\n        }\n    }\n\n    function addCreditProvider(address creditProvider) external onlyOwner {\n        _isCreditProvider[creditProvider] = true;\n        emit CreditProviderStatusChanged(creditProvider, true, block.timestamp);\n    }\n\n    function removeCreditProvider(address creditProvider) external onlyOwner {\n        _isCreditProvider[creditProvider] = false;\n        emit CreditProviderStatusChanged(creditProvider, false, block.timestamp);\n    }\n\n    function setProfileCreationPrice(uint128 newPrice) external onlyOwner {\n        _profileCreationCost = newPrice;\n        emit ProfileCreationPriceChanged(newPrice, block.timestamp);\n    }\n\n    function setHandleCreationPrice(uint128 newPrice) external onlyOwner {\n        _handleCreationCost = newPrice;\n        emit HandleCreationPriceChanged(newPrice, block.timestamp);\n    }\n\n    function setHandleLengthMin(uint8 newMinLength) external onlyOwner {\n        _handleLengthMin = newMinLength;\n        emit HandleLengthMinChanged(newMinLength, block.timestamp);\n    }\n\n    function setTrustStatus(address targetAddress, bool setAsUntrusted) external onlyOwner {\n        if (setAsUntrusted == _isUntrusted[targetAddress]) {\n            // No change in trust status.\n            return;\n        }\n        if (setAsUntrusted && _credits[targetAddress] > 0) {\n            // If it is becoming unstrusted, current credits should be removed.\n            _credits[targetAddress] = 0;\n            emit CreditBalanceChanged(targetAddress, 0, block.timestamp);\n        }\n        _isUntrusted[targetAddress] = setAsUntrusted;\n        emit TrustStatusChanged(targetAddress, setAsUntrusted, block.timestamp);\n    }\n\n    // View functions\n\n    function getProfileWithHandleCreationPrice() external view returns (uint256) {\n        return _profileCreationCost + _handleCreationCost;\n    }\n\n    function getProfileCreationPrice() external view returns (uint256) {\n        return _profileCreationCost;\n    }\n\n    function getHandleCreationPrice() external view returns (uint256) {\n        return _handleCreationCost;\n    }\n\n    function getHandleLengthMin() external view returns (uint8) {\n        return _handleLengthMin;\n    }\n\n    function isUntrusted(address targetAddress) external view returns (bool) {\n        return _isUntrusted[targetAddress];\n    }\n\n    function isCreditProvider(address targetAddress) external view returns (bool) {\n        return _isCreditProvider[targetAddress];\n    }\n\n    function getCreditBalance(address targetAddress) external view returns (uint256) {\n        return _credits[targetAddress];\n    }\n\n    function getProfileCreatorUsingCredits(uint256 profileId) external view returns (address) {\n        return _profileCreatorUsingCredits[profileId];\n    }\n}\n"
    },
    "lens-modules/contracts/misc/ProfileCreationProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {ImmutableOwnable} from '../misc/ImmutableOwnable.sol';\n\nimport {ILensHandles} from '../interfaces/ILensHandles.sol';\nimport {ITokenHandleRegistry} from '../interfaces/ITokenHandleRegistry.sol';\n\n/**\n * @title ProfileCreationProxy\n * @author Lens Protocol\n *\n * @notice This is an ownable proxy contract that enforces \".lens\" handle suffixes at profile creation.\n * Only the owner can create profiles.\n */\ncontract ProfileCreationProxy is ImmutableOwnable {\n    ILensHandles immutable LENS_HANDLES;\n    ITokenHandleRegistry immutable TOKEN_HANDLE_REGISTRY;\n\n    error ProfileAlreadyExists();\n\n    constructor(\n        address owner,\n        address hub,\n        address lensHandles,\n        address tokenHandleRegistry\n    ) ImmutableOwnable(owner, hub) {\n        LENS_HANDLES = ILensHandles(lensHandles);\n        TOKEN_HANDLE_REGISTRY = ITokenHandleRegistry(tokenHandleRegistry);\n    }\n\n    function proxyCreateProfile(\n        Types.CreateProfileParams calldata createProfileParams\n    ) external onlyOwner returns (uint256) {\n        return ILensHub(LENS_HUB).createProfile(createProfileParams);\n    }\n\n    function proxyCreateProfileWithHandle(\n        Types.CreateProfileParams memory createProfileParams,\n        string calldata handle\n    ) external onlyOwner returns (uint256, uint256) {\n        // We mint the handle & profile to this contract first, then link it to the profile\n        // This will not allow to initialize follow modules that require funds from the msg.sender,\n        // but we assume only simple follow modules should be set during profile creation.\n        // Complex ones can be set after the profile is created.\n        address destination = createProfileParams.to;\n        createProfileParams.to = address(this);\n        uint256 profileId = ILensHub(LENS_HUB).createProfile(createProfileParams);\n        uint256 handleId = LENS_HANDLES.mintHandle(address(this), handle);\n\n        TOKEN_HANDLE_REGISTRY.link({handleId: handleId, profileId: profileId});\n\n        // Transfer the handle & profile to the destination\n        LENS_HANDLES.transferFrom(address(this), destination, handleId);\n        ILensHub(LENS_HUB).transferFrom(address(this), destination, profileId);\n\n        return (profileId, handleId);\n    }\n\n    function proxyCreateHandle(address to, string calldata handle) external onlyOwner returns (uint256) {\n        return LENS_HANDLES.mintHandle(to, handle);\n    }\n}\n"
    },
    "lens-modules/contracts/misc/PublicActProxy_MetaTx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {Types} from '../libraries/constants/Types.sol';\nimport {Typehash} from '../libraries/constants/Typehash.sol';\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {Events} from '../libraries/constants/Events.sol';\nimport {Errors} from '../libraries/constants/Errors.sol';\n\ncontract PublicActProxy_MetaTx {\n    string constant EIP712_DOMAIN_VERSION = '2';\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\n    bytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    mapping(address => uint256) private _nonces;\n\n    struct PaymentParams {\n        address currency;\n        uint256 amount;\n        address approveTo;\n    }\n\n    function _validatePaidActSignature(\n        Types.EIP712Signature calldata signature,\n        Types.PublicationActionParams calldata publicationActionParams,\n        PaymentParams memory paymentParams\n    ) internal {\n        bytes memory encodedAbi = abi.encode(\n            Typehash.PUBLIC_PAID_ACT,\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId,\n            publicationActionParams.actorProfileId,\n            _encodeUsingEip712Rules(publicationActionParams.referrerProfileIds),\n            _encodeUsingEip712Rules(publicationActionParams.referrerPubIds),\n            publicationActionParams.actionModuleAddress,\n            _encodeUsingEip712Rules(publicationActionParams.actionModuleData),\n            paymentParams.currency,\n            paymentParams.amount,\n            paymentParams.approveTo,\n            _getNonceIncrementAndEmitEvent(signature.signer),\n            signature.deadline\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function _validateActSignature(\n        Types.EIP712Signature calldata signature,\n        Types.PublicationActionParams calldata publicationActionParams\n    ) internal {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.ACT,\n                        publicationActionParams.publicationActedProfileId,\n                        publicationActionParams.publicationActedId,\n                        publicationActionParams.actorProfileId,\n                        _encodeUsingEip712Rules(publicationActionParams.referrerProfileIds),\n                        _encodeUsingEip712Rules(publicationActionParams.referrerPubIds),\n                        publicationActionParams.actionModuleAddress,\n                        _encodeUsingEip712Rules(publicationActionParams.actionModuleData),\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\n        if (block.timestamp > signature.deadline) revert Errors.SignatureExpired();\n        // If the expected address is a contract, check the signature there.\n        if (signature.signer.code.length != 0) {\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\n                revert Errors.SignatureInvalid();\n            }\n        } else {\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\n                revert Errors.SignatureInvalid();\n            }\n        }\n    }\n\n    function _encodeUsingEip712Rules(bytes memory bytesValue) private pure returns (bytes32) {\n        return keccak256(bytesValue);\n    }\n\n    function _encodeUsingEip712Rules(uint256[] memory uint256Array) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint256Array));\n    }\n\n    /**\n     * @dev This fetches a signer's current nonce and increments it so it's ready for the next meta-tx. Also emits\n     * the `NonceUpdated` event.\n     *\n     * @param signer The address to get and increment the nonce for.\n     *\n     * @return uint256 The current nonce for the given signer prior to being incremented.\n     */\n    function _getNonceIncrementAndEmitEvent(address signer) private returns (uint256) {\n        uint256 currentNonce;\n        unchecked {\n            currentNonce = _nonces[signer]++;\n        }\n        emit Events.NonceUpdated(signer, currentNonce + 1, block.timestamp);\n        return currentNonce;\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\n        return keccak256(abi.encodePacked('\\x19\\x01', _calculateDomainSeparator(), hashedMessage));\n    }\n\n    function _calculateDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    Typehash.EIP712_DOMAIN,\n                    keccak256(bytes(name())),\n                    EIP712_DOMAIN_VERSION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    // View functions\n\n    function nonces(address signer) public view returns (uint256) {\n        return _nonces[signer];\n    }\n\n    /// @dev This function is used to invalidate signatures by incrementing the nonce\n    function incrementNonce(uint8 increment) external {\n        uint256 currentNonce = _nonces[msg.sender];\n        _nonces[msg.sender] = currentNonce + increment;\n        emit Events.NonceUpdated(msg.sender, currentNonce + increment, block.timestamp);\n    }\n\n    function name() public pure returns (string memory) {\n        return 'PublicActProxy';\n    }\n}\n"
    },
    "lens-modules/contracts/misc/PublicActProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {CollectPublicationAction} from '../modules/act/collect/CollectPublicationAction.sol';\nimport {PublicActProxy_MetaTx} from '../misc/PublicActProxy_MetaTx.sol';\n\n// This contract should be the owner/DE of the publicationActionParams.actorProfileId\n// This contract should be set as publicationActionParams.transactionExecutor\n// Correct collectNftRecipient should be passed in the publicationActionParams.actionModuleData\n\n/*\n    Here is an example of PublicationActionParams to pass:\n\n    struct PublicationActionParams {\n        publicationActedProfileId: ---\n        publicationActedId: ---\n        actorProfileId: this contract's profile\n        referrerProfileIds: ---\n        referrerPubIds: ---\n        actionModuleAddress: ---\n        actionModuleData: {\n            collectNftRecipient: who shall receive the NFT\n            collectData: {\n                expectedCurrency: should match what's stored in CollectModule\n                expectedAmount: should match what's stored in CollectModule\n            }\n        }\n    }\n*/\n\n/// @title PublicActProxy\n/// @author LensProtocol\n/// @notice This contract allows anyone to Act on a publication without holding a profile\n/// @dev This contract holds a profile (or is a DE of that profile) and acts on behalf of the caller\ncontract PublicActProxy is PublicActProxy_MetaTx {\n    using SafeERC20 for IERC20;\n\n    ILensHub public immutable HUB;\n\n    constructor(address lensHub) {\n        HUB = ILensHub(lensHub);\n    }\n\n    // The free act is pretty simple, but should follow the rules above:\n    /// @notice For actions not involving any ERC20 transfers or approvals from the actor\n    /// @dev This is used in the same way as the general .act() function, while following the rules above.\n    function publicFreeAct(Types.PublicationActionParams calldata publicationActionParams) external {\n        HUB.act(publicationActionParams);\n    }\n\n    /// @notice For actions involving ERC20 transfers or approvals from the actor\n    /// @dev You need to provide the currency that will be taken from the actor, the amount, and the address to approve\n    /// to (usually it's the address of the CollectModule, or any other contract that performs the .transferFrom).\n    /// You need to set an approval to publicActProxy, cause the amount will be taken from you by this proxy first.\n    function publicPaidAct(\n        Types.PublicationActionParams calldata publicationActionParams,\n        address currency,\n        uint256 amount,\n        address approveTo\n    ) external {\n        _publicAct(publicationActionParams, currency, amount, approveTo, msg.sender);\n    }\n\n    /// @notice For actions involving ERC20 transfers or approvals from the actor (with signature)\n    /// @dev See publicPaidAct() - same, but with a signature. The signer has to give their approval in this case.\n    function publicPaidActWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        address currency,\n        uint256 amount,\n        address approveTo,\n        Types.EIP712Signature calldata signature\n    ) external {\n        _validatePaidActSignature(signature, publicationActionParams, PaymentParams(currency, amount, approveTo));\n        _publicAct(publicationActionParams, currency, amount, approveTo, signature.signer);\n    }\n\n    // Internal functions\n\n    function _publicAct(\n        Types.PublicationActionParams calldata publicationActionParams,\n        address currency,\n        uint256 amount,\n        address approveTo,\n        address transactionExecutor\n    ) internal {\n        if (amount > 0) {\n            IERC20(currency).safeTransferFrom(transactionExecutor, address(this), amount);\n            IERC20(currency).safeIncreaseAllowance(approveTo, amount);\n        }\n        HUB.act(publicationActionParams);\n    }\n}\n"
    },
    "lens-modules/contracts/misc/token-uris/FollowTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {FollowSVG} from '../../libraries/svgs/Follow/FollowSVG.sol';\nimport {IFollowTokenURI} from '../../interfaces/IFollowTokenURI.sol';\n\ncontract FollowTokenURI is IFollowTokenURI {\n    using Strings for uint96;\n    using Strings for uint256;\n\n    function getTokenURI(\n        uint256 followTokenId,\n        uint256 followedProfileId,\n        uint256 originalFollowTimestamp\n    ) external pure override returns (string memory) {\n        string memory followTokenIdAsString = followTokenId.toString();\n        string memory followedProfileIdAsString = followedProfileId.toString();\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        abi.encodePacked(\n                            '{\"name\":\"Follower #',\n                            followTokenIdAsString,\n                            '\",\"description\":\"Lens Protocol - Follower #',\n                            followTokenIdAsString,\n                            ' of Profile #',\n                            followedProfileIdAsString,\n                            '\",\"image\":\"data:image/svg+xml;base64,',\n                            Base64.encode(bytes(FollowSVG.getFollowSVG(followTokenId))),\n                            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"ID\",\"value\":\"',\n                            followTokenIdAsString,\n                            '\"},{\"trait_type\":\"DIGITS\",\"value\":\"',\n                            bytes(followTokenIdAsString).length.toString(),\n                            '\"},{\"display_type\":\"date\",\"trait_type\":\"MINTED AT\",\"value\":\"',\n                            originalFollowTimestamp.toString(),\n                            '\"}]}'\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "lens-modules/contracts/misc/token-uris/HandleTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {HandleSVG} from '../../libraries/svgs/Handle/HandleSVG.sol';\nimport {IHandleTokenURI} from '../../interfaces/IHandleTokenURI.sol';\n\ncontract HandleTokenURI is IHandleTokenURI {\n    using Strings for uint256;\n\n    function getTokenURI(\n        uint256 tokenId,\n        string memory localName,\n        string memory namespace\n    ) external pure override returns (string memory) {\n        return\n            string.concat(\n                'data:application/json;base64,',\n                Base64.encode(\n                    bytes(\n                        string.concat(\n                            '{\"name\":\"@',\n                            localName,\n                            '\",\"description\":\"Lens Protocol - Handle @',\n                            localName,\n                            '\",\"image\":\"data:image/svg+xml;base64,',\n                            Base64.encode(bytes(HandleSVG.getHandleSVG(localName))),\n                            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"ID\",\"value\":\"',\n                            tokenId.toString(),\n                            '\"},{\"trait_type\":\"NAMESPACE\",\"value\":\"',\n                            namespace,\n                            '\"},{\"trait_type\":\"LENGTH\",\"value\":\"',\n                            bytes(localName).length.toString(),\n                            '\"}]}'\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "lens-modules/contracts/misc/token-uris/SimpleProfileTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {SimpleProfileSVG} from '../../libraries/svgs/Profile/SimpleProfileSVG.sol';\nimport {IProfileTokenURI} from '../../interfaces/IProfileTokenURI.sol';\n\ncontract SimpleProfileTokenURI is IProfileTokenURI {\n    using Strings for uint96;\n    using Strings for uint256;\n\n    bytes32 public immutable blockSeed;\n\n    constructor() {\n        blockSeed = blockhash(block.number - 1);\n    }\n\n    function getTokenURI(uint256 profileId, uint256 mintTimestamp) public view override returns (string memory) {\n        string memory profileIdAsString = profileId.toString();\n        (string memory profileSvg, string memory traits) = SimpleProfileSVG.getProfileSVG(profileId, blockSeed);\n        string memory json;\n        {\n            json = string.concat(\n                '{\"name\":\"Profile #',\n                profileIdAsString,\n                '\",\"description\":\"Lens Protocol - Profile #',\n                profileIdAsString,\n                '\",\"image\":\"data:image/svg+xml;base64,',\n                Base64.encode(bytes(profileSvg))\n            );\n        }\n        return\n            string.concat(\n                'data:application/json;base64,',\n                Base64.encode(\n                    bytes(\n                        string.concat(\n                            json,\n                            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"ID\",\"value\":\"',\n                            profileIdAsString,\n                            '\"},{\"trait_type\":\"HEX ID\",\"value\":\"',\n                            profileId.toHexString(),\n                            '\"},{\"trait_type\":\"DIGITS\",\"value\":\"',\n                            bytes(profileIdAsString).length.toString(),\n                            '\"},{\"display_type\":\"date\",\"trait_type\":\"MINTED AT\",\"value\":\"',\n                            mintTimestamp.toString(),\n                            '\"},',\n                            traits,\n                            ']}'\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "lens-modules/contracts/modules/act/collect/base/BaseFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Errors} from '../../../constants/Errors.sol';\nimport {FeeModuleBase} from '../../../FeeModuleBase.sol';\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {ActionRestricted} from '../../../ActionRestricted.sol';\n\nimport {ModuleTypes} from '../../../libraries/constants/ModuleTypes.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {FollowValidationLib} from '../../../libraries/FollowValidationLib.sol';\n\nimport {BaseFeeCollectModuleInitData, BaseProfilePublicationData, IBaseFeeCollectModule} from '../../../interfaces/IBaseFeeCollectModule.sol';\n\n/**\n * @title BaseFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is base Lens CollectModule implementation, allowing customization of time to collect, number of collects\n * and Followers-only restriction. Charges a fee for collect and distributing it among Receiver/Referrals/Treasury.\n * @dev Here we use \"Base\" terminology to anything that represents this base functionality (base structs,\n * base functions, base storage). Other collect modules can be built on top of the \"Base\" by inheriting from this\n * contract and overriding functions.\n * This contract is marked \"abstract\" as it requires you to implement initializePublicationCollectModule and\n * getPublicationData functions when you inherit from it. See SimpleFeeCollectModule as an example implementation.\n */\nabstract contract BaseFeeCollectModule is FeeModuleBase, ActionRestricted, IBaseFeeCollectModule {\n    using SafeERC20 for IERC20;\n\n    address immutable HUB;\n\n    mapping(uint256 => mapping(uint256 => BaseProfilePublicationData)) internal _dataByPublicationByProfile;\n\n    constructor(\n        address hub,\n        address actionModule,\n        address moduleRegistry\n    ) ActionRestricted(actionModule) FeeModuleBase(hub, moduleRegistry) {\n        HUB = hub;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure virtual returns (bool) {\n        return interfaceID == type(ICollectModule).interfaceId;\n    }\n\n    /**\n     * @inheritdoc ICollectModule\n     * @notice Processes a collect by:\n     *  1. Validating that collect action meets all needed criteria\n     *  2. Processing the collect action either with or without referral\n     *\n     * @param processCollectParams Collect action parameters (see ModuleTypes.ProcessCollectParams struct)\n     */\n    function processCollect(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) external virtual onlyActionModule returns (bytes memory) {\n        _validateAndStoreCollect(processCollectParams);\n\n        if (processCollectParams.referrerProfileIds.length == 0) {\n            _processCollect(processCollectParams);\n        } else {\n            _processCollectWithReferral(processCollectParams);\n        }\n        return '';\n    }\n\n    /// @inheritdoc IBaseFeeCollectModule\n    function getBasePublicationData(\n        uint256 profileId,\n        uint256 pubId\n    ) public view virtual returns (BaseProfilePublicationData memory) {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc IBaseFeeCollectModule\n    function calculateFee(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) public view virtual returns (uint160) {\n        return\n            _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n                processCollectParams.publicationCollectedId\n            ].amount;\n    }\n\n    /**\n     * @dev Validates the Base parameters like:\n     * 1) Is the currency whitelisted\n     * 2) Is the referralFee in valid range\n     * 3) Is the end of collects timestamp in valid range\n     *\n     * This should be called during initializePublicationCollectModule()\n     *\n     * @param baseInitData Module initialization data (see BaseFeeCollectModuleInitData struct)\n     */\n    function _validateBaseInitData(BaseFeeCollectModuleInitData memory baseInitData) internal virtual {\n        if (\n            (baseInitData.amount == 0 && baseInitData.currency != address(0)) ||\n            (baseInitData.amount != 0 && baseInitData.currency == address(0)) ||\n            baseInitData.referralFee > BPS_MAX ||\n            (baseInitData.endTimestamp != 0 && baseInitData.endTimestamp < block.timestamp)\n        ) {\n            revert Errors.InitParamsInvalid();\n        }\n        _verifyErc20Currency(baseInitData.currency);\n    }\n\n    /**\n     * @dev Stores the initial module parameters\n     *\n     * This should be called during initializePublicationCollectModule()\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The publication ID.\n     * @param baseInitData Module initialization data (see BaseFeeCollectModuleInitData struct)\n     */\n    function _storeBasePublicationCollectParameters(\n        uint256 profileId,\n        uint256 pubId,\n        BaseFeeCollectModuleInitData memory baseInitData\n    ) internal virtual {\n        _dataByPublicationByProfile[profileId][pubId].amount = baseInitData.amount;\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = baseInitData.collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].currency = baseInitData.currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = baseInitData.recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = baseInitData.referralFee;\n        _dataByPublicationByProfile[profileId][pubId].followerOnly = baseInitData.followerOnly;\n        _dataByPublicationByProfile[profileId][pubId].endTimestamp = baseInitData.endTimestamp;\n    }\n\n    /**\n     * @dev Validates the collect action by checking that:\n     * 1) the collector is a follower (if enabled)\n     * 2) the number of collects after the action doesn't surpass the collect limit (if enabled)\n     * 3) the current block timestamp doesn't surpass the end timestamp (if enabled)\n     *\n     * This should be called during processCollect()\n     */\n    function _validateAndStoreCollect(ModuleTypes.ProcessCollectParams calldata processCollectParams) internal virtual {\n        uint96 collectsAfter = ++_dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].currentCollects;\n\n        if (\n            _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n                processCollectParams.publicationCollectedId\n            ].followerOnly\n        ) {\n            FollowValidationLib.validateIsFollowingOrSelf({\n                hub: HUB,\n                followerProfileId: processCollectParams.collectorProfileId,\n                followedProfileId: processCollectParams.publicationCollectedProfileId\n            });\n        }\n\n        uint256 endTimestamp = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].endTimestamp;\n        uint256 collectLimit = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].collectLimit;\n\n        if (collectLimit != 0 && collectsAfter > collectLimit) {\n            revert Errors.MintLimitExceeded();\n        }\n        if (endTimestamp != 0 && block.timestamp > endTimestamp) {\n            revert Errors.CollectExpired();\n        }\n    }\n\n    /**\n     * @dev Internal processing of a collect:\n     *  1. Calculation of fees\n     *  2. Validation that fees are what collector expected\n     *  3. Transfer of fees to recipient(-s) and treasury\n     *\n     * @param processCollectParams Parameters of the collect\n     */\n    function _processCollect(ModuleTypes.ProcessCollectParams calldata processCollectParams) internal virtual {\n        uint256 amount = calculateFee(processCollectParams);\n        address currency = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].currency;\n        _validateDataIsExpected(processCollectParams.data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n\n        if (treasuryAmount > 0) {\n            IERC20(currency).safeTransferFrom(processCollectParams.transactionExecutor, treasury, treasuryAmount);\n        }\n\n        // Send amount after treasury cut, to all recipients\n        _transferToRecipients(processCollectParams, currency, amount - treasuryAmount);\n    }\n\n    /**\n     * @dev Internal processing of a collect with a referrals (if any).\n     *\n     * Same as _processCollect, but also includes transfer to referrals (if any):\n     *  1. Calculation of fees\n     *  2. Validation that fees are what collector expected\n     *  3. Transfer of fees to treasury, referrals (if any) and recipients\n     *\n     * @param processCollectParams Parameters of the collect\n     */\n    function _processCollectWithReferral(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) internal virtual {\n        uint256 amount = calculateFee(processCollectParams);\n        address currency = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].currency;\n\n        _validateDataIsExpected(processCollectParams.data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n\n        if (treasuryAmount > 0) {\n            IERC20(currency).safeTransferFrom(processCollectParams.transactionExecutor, treasury, treasuryAmount);\n        }\n\n        uint256 amountAfterReferrals = _transferToReferrals(processCollectParams, currency, amount - treasuryAmount);\n\n        _transferToRecipients(processCollectParams, currency, amountAfterReferrals);\n    }\n\n    /**\n     * @dev Tranfers the fee to recipient(-s)\n     *\n     * Override this to add additional functionality (e.g. multiple recipients)\n     *\n     * @param processCollectParams Parameters of the collect\n     * @param currency Currency of the transaction\n     * @param amount Amount to transfer to recipient(-s)\n     */\n    function _transferToRecipients(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams,\n        address currency,\n        uint256 amount\n    ) internal virtual {\n        address recipient = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].recipient;\n\n        if (amount > 0) {\n            IERC20(currency).safeTransferFrom(processCollectParams.transactionExecutor, recipient, amount);\n        }\n    }\n\n    /**\n     * @dev Tranfers the part of fee to referral(-s)\n     *\n     * Override this to add additional functionality (e.g. different amounts to different referrals, etc)\n     *\n     * @param processCollectParams Parameters of the collect\n     * @param currency Currency of the transaction\n     * @param amount Amount of the fee after subtracting the Treasury part.\n     */\n    function _transferToReferrals(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams,\n        address currency,\n        uint256 amount\n    ) internal virtual returns (uint256) {\n        uint256 referralFee = _dataByPublicationByProfile[processCollectParams.publicationCollectedProfileId][\n            processCollectParams.publicationCollectedId\n        ].referralFee;\n        uint256 totalReferralsAmount;\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            totalReferralsAmount = (amount * referralFee) / BPS_MAX;\n            uint256 numberOfReferrals = processCollectParams.referrerProfileIds.length;\n            uint256 amountPerReferral = totalReferralsAmount / numberOfReferrals;\n            if (amountPerReferral > 0) {\n                uint256 i;\n                while (i < numberOfReferrals) {\n                    address referralRecipient = IERC721(HUB).ownerOf(processCollectParams.referrerProfileIds[i]);\n\n                    // Send referral fee in ERC20 tokens\n                    IERC20(currency).safeTransferFrom(\n                        processCollectParams.transactionExecutor,\n                        referralRecipient,\n                        amountPerReferral\n                    );\n                    unchecked {\n                        ++i;\n                    }\n                }\n            }\n        }\n        return amount - totalReferralsAmount;\n    }\n}\n"
    },
    "lens-modules/contracts/modules/act/collect/CollectNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ERC2981CollectionRoyalties} from '../../../base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from '../../../libraries/constants/Errors.sol';\nimport {ICollectNFT} from '../../../interfaces/ICollectNFT.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {LensBaseERC721} from '../../../base/LensBaseERC721.sol';\nimport {ActionRestricted} from '../../ActionRestricted.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\n/**\n * @title CollectNFT\n * @author Lens Protocol\n *\n * @dev This is the CollectNFT for Lens V2, it differs from LegacyCollectNFT that it's restricted to be called by an\n * action module instead of LensHub.\n *\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\n */\ncontract CollectNFT is LensBaseERC721, ERC2981CollectionRoyalties, ActionRestricted, ICollectNFT {\n    using Strings for uint256;\n\n    address public immutable HUB;\n\n    uint256 internal _profileId;\n    uint256 internal _pubId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    uint256 internal _royaltiesInBasisPoints;\n\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\n    // to initialize the hub proxy at construction.\n    constructor(address hub, address actionModule) ActionRestricted(actionModule) {\n        HUB = hub;\n        _initialized = true;\n    }\n\n    /// @inheritdoc ICollectNFT\n    function initialize(uint256 profileId, uint256 pubId) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _setRoyalty(1000); // 10% of royalties\n        _profileId = profileId;\n        _pubId = pubId;\n        // _name and _symbol remain uninitialized because we override the getters below\n    }\n\n    /// @inheritdoc ICollectNFT\n    function mint(address to) external override onlyActionModule returns (uint256) {\n        unchecked {\n            uint256 tokenId = ++_tokenIdCounter;\n            _mint(to, tokenId);\n            return tokenId;\n        }\n    }\n\n    /// @inheritdoc ICollectNFT\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\n        return (_profileId, _pubId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return string.concat('Lens Collect | Profile #', _profileId.toString(), ' - Publication #', _pubId.toString());\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public pure override returns (string memory) {\n        return 'LENS-COLLECT';\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC2981CollectionRoyalties, LensBaseERC721)\n        returns (bool)\n    {\n        return\n            ERC2981CollectionRoyalties.supportsInterface(interfaceId) || LensBaseERC721.supportsInterface(interfaceId);\n    }\n\n    function _getReceiver(\n        uint256 /* tokenId */\n    ) internal view override returns (address) {\n        if (!ILensHub(HUB).exists(_profileId)) {\n            return address(0);\n        }\n        return IERC721(HUB).ownerOf(_profileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_profileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n}\n"
    },
    "lens-modules/contracts/modules/act/collect/CollectPublicationAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {IPublicationActionModule} from '../../../interfaces/IPublicationActionModule.sol';\nimport {ICollectModule} from '../../interfaces/ICollectModule.sol';\nimport {ICollectNFT} from '../../../interfaces/ICollectNFT.sol';\nimport {Types} from '../../../libraries/constants/Types.sol';\nimport {ModuleTypes} from '../../libraries/constants/ModuleTypes.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {Errors} from '../../constants/Errors.sol';\nimport {HubRestricted} from '../../../base/HubRestricted.sol';\nimport {ILensModule} from '../../interfaces/ILensModule.sol';\n\nimport {LensModuleMetadataInitializable} from '../../LensModuleMetadataInitializable.sol';\n\n/**\n * @title CollectPublicationAction\n * @author LensProtocol\n * @notice An Publication Action module that allows users to collect publications.\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract CollectPublicationAction is LensModuleMetadataInitializable, HubRestricted, IPublicationActionModule {\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return interfaceID == type(IPublicationActionModule).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    struct CollectData {\n        address collectModule;\n        address collectNFT;\n    }\n\n    event CollectModuleRegistered(address collectModule, string metadata, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a collectNFT clone is deployed using a lazy deployment pattern.\n     *\n     * @param profileId The publisher's profile token ID.\n     * @param pubId The publication associated with the newly deployed collectNFT clone's ID.\n     * @param collectNFT The address of the newly deployed collectNFT clone.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectNFTDeployed(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        address indexed collectNFT,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful collect action.\n     *\n     * @param collectedProfileId The token ID of the profile that published the collected publication.\n     * @param collectedPubId The ID of the collected publication.\n     * @param collectorProfileId The token ID of the profile that collected the publication.\n     * @param nftRecipient The address that received the collect NFT.\n     * @param collectActionData The custom data passed to the collect module, if any.\n     * @param collectActionResult The data returned from the collect module's collect action. This is ABI-encoded\n     * and depends on the collect module chosen.\n     * @param collectNFT The address of the NFT collection where the minted collect NFT belongs to.\n     * @param tokenId The token ID of the collect NFT that was minted as a collect of the publication.\n     * @param transactionExecutor The address of the account that executed this operation.\n     * @param timestamp The current block timestamp.\n     */\n    event Collected(\n        uint256 indexed collectedProfileId,\n        uint256 indexed collectedPubId,\n        uint256 indexed collectorProfileId,\n        address nftRecipient,\n        bytes collectActionData,\n        bytes collectActionResult,\n        address collectNFT,\n        uint256 tokenId,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    error NotCollectModule();\n\n    address public immutable COLLECT_NFT_IMPL;\n\n    mapping(address collectModule => bool isWhitelisted) internal _collectModuleRegistered;\n    mapping(uint256 profileId => mapping(uint256 pubId => CollectData collectData)) internal _collectDataByPub;\n\n    constructor(\n        address hub,\n        address collectNFTImpl,\n        address moduleOwner\n    ) HubRestricted(hub) LensModuleMetadataInitializable(moduleOwner) {\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    function verifyCollectModule(address collectModule) public returns (bool) {\n        registerCollectModule(collectModule);\n        return true;\n    }\n\n    function registerCollectModule(address collectModule) public returns (bool) {\n        if (_collectModuleRegistered[collectModule]) {\n            return false;\n        } else {\n            if (!ILensModule(collectModule).supportsInterface(type(ICollectModule).interfaceId)) {\n                revert NotCollectModule();\n            }\n\n            string memory metadata = ILensModule(collectModule).getModuleMetadataURI();\n            emit CollectModuleRegistered(collectModule, metadata, block.timestamp);\n            _collectModuleRegistered[collectModule] = true;\n            return true;\n        }\n    }\n\n    function initializePublicationAction(\n        uint256 profileId,\n        uint256 pubId,\n        address transactionExecutor,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (address collectModule, bytes memory collectModuleInitData) = abi.decode(data, (address, bytes));\n        if (_collectDataByPub[profileId][pubId].collectModule != address(0)) {\n            revert Errors.AlreadyInitialized();\n        }\n        verifyCollectModule(collectModule);\n        _collectDataByPub[profileId][pubId].collectModule = collectModule;\n        ICollectModule(collectModule).initializePublicationCollectModule(\n            profileId,\n            pubId,\n            transactionExecutor,\n            collectModuleInitData\n        );\n        return '';\n    }\n\n    function processPublicationAction(\n        Types.ProcessActionParams calldata processActionParams\n    ) external override onlyHub returns (bytes memory) {\n        address collectModule = _collectDataByPub[processActionParams.publicationActedProfileId][\n            processActionParams.publicationActedId\n        ].collectModule;\n        if (collectModule == address(0)) {\n            revert Errors.CollectNotAllowed();\n        }\n        address collectNFT = _getOrDeployCollectNFT({\n            publicationCollectedProfileId: processActionParams.publicationActedProfileId,\n            publicationCollectedId: processActionParams.publicationActedId,\n            collectNFTImpl: COLLECT_NFT_IMPL\n        });\n        (address collectNftRecipient, bytes memory collectData) = abi.decode(\n            processActionParams.actionModuleData,\n            (address, bytes)\n        );\n        uint256 tokenId = ICollectNFT(collectNFT).mint(collectNftRecipient);\n        bytes memory collectActionResult = _processCollect(collectModule, collectData, processActionParams);\n        _emitCollectedEvent(\n            processActionParams,\n            collectNftRecipient,\n            collectData,\n            collectActionResult,\n            collectNFT,\n            tokenId\n        );\n        return abi.encode(collectNFT, tokenId, collectModule, collectActionResult);\n    }\n\n    function _emitCollectedEvent(\n        Types.ProcessActionParams calldata processActionParams,\n        address collectNftRecipient,\n        bytes memory collectData,\n        bytes memory collectActionResult,\n        address collectNFT,\n        uint256 tokenId\n    ) private {\n        emit Collected({\n            collectedProfileId: processActionParams.publicationActedProfileId,\n            collectedPubId: processActionParams.publicationActedId,\n            collectorProfileId: processActionParams.actorProfileId,\n            nftRecipient: collectNftRecipient,\n            collectActionData: collectData,\n            collectActionResult: collectActionResult,\n            collectNFT: collectNFT,\n            tokenId: tokenId,\n            transactionExecutor: processActionParams.transactionExecutor,\n            timestamp: block.timestamp\n        });\n    }\n\n    function getCollectData(uint256 profileId, uint256 pubId) external view returns (CollectData memory) {\n        return _collectDataByPub[profileId][pubId];\n    }\n\n    function _getOrDeployCollectNFT(\n        uint256 publicationCollectedProfileId,\n        uint256 publicationCollectedId,\n        address collectNFTImpl\n    ) private returns (address) {\n        address collectNFT = _collectDataByPub[publicationCollectedProfileId][publicationCollectedId].collectNFT;\n        if (collectNFT == address(0)) {\n            collectNFT = _deployCollectNFT(publicationCollectedProfileId, publicationCollectedId, collectNFTImpl);\n            _collectDataByPub[publicationCollectedProfileId][publicationCollectedId].collectNFT = collectNFT;\n        }\n        return collectNFT;\n    }\n\n    function _processCollect(\n        address collectModule,\n        bytes memory collectData,\n        Types.ProcessActionParams calldata processActionParams\n    ) private returns (bytes memory) {\n        return\n            ICollectModule(collectModule).processCollect(\n                ModuleTypes.ProcessCollectParams({\n                    publicationCollectedProfileId: processActionParams.publicationActedProfileId,\n                    publicationCollectedId: processActionParams.publicationActedId,\n                    collectorProfileId: processActionParams.actorProfileId,\n                    collectorProfileOwner: processActionParams.actorProfileOwner,\n                    transactionExecutor: processActionParams.transactionExecutor,\n                    referrerProfileIds: processActionParams.referrerProfileIds,\n                    referrerPubIds: processActionParams.referrerPubIds,\n                    referrerPubTypes: processActionParams.referrerPubTypes,\n                    data: collectData\n                })\n            );\n    }\n\n    function _deployCollectNFT(uint256 profileId, uint256 pubId, address collectNFTImpl) private returns (address) {\n        address collectNFT = Clones.clone(collectNFTImpl);\n\n        ICollectNFT(collectNFT).initialize(profileId, pubId);\n        emit CollectNFTDeployed(profileId, pubId, collectNFT, block.timestamp);\n\n        return collectNFT;\n    }\n\n    function isCollectModuleRegistered(address collectModule) external view returns (bool) {\n        return _collectModuleRegistered[collectModule];\n    }\n}\n"
    },
    "lens-modules/contracts/modules/act/collect/MultirecipientFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Errors} from '../../constants/Errors.sol';\nimport {BaseFeeCollectModule} from '../../act/collect/base/BaseFeeCollectModule.sol';\nimport {BaseProfilePublicationData, BaseFeeCollectModuleInitData} from '../../interfaces/IBaseFeeCollectModule.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ICollectModule} from '../../interfaces/ICollectModule.sol';\nimport {ModuleTypes} from '../../libraries/constants/ModuleTypes.sol';\nimport {LensModuleMetadata} from '../../LensModuleMetadata.sol';\nimport {LensModule} from '../../LensModule.sol';\n\nstruct RecipientData {\n    address recipient;\n    uint16 split; // fraction of BPS_MAX (10 000)\n}\n\n/**\n * @notice A struct containing the necessary data to initialize MultirecipientFeeCollectModule.\n *\n * @param amount The collecting cost associated with this publication. Cannot be 0.\n * @param collectLimit The maximum number of collects for this publication. 0 for no limit.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly True if only followers of publisher may collect the post.\n * @param endTimestamp The end timestamp after which collecting is impossible. 0 for no expiry.\n * @param recipients Array of RecipientData items to split collect fees across multiple recipients.\n */\nstruct MultirecipientFeeCollectModuleInitData {\n    uint160 amount;\n    uint96 collectLimit;\n    address currency;\n    uint16 referralFee;\n    bool followerOnly;\n    uint72 endTimestamp;\n    RecipientData[] recipients;\n}\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication. Cannot be 0.\n * @param collectLimit The maximum number of collects for this publication. 0 for no limit.\n * @param currency The currency associated with this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly True if only followers of publisher may collect the post.\n * @param endTimestamp The end timestamp after which collecting is impossible. 0 for no expiry.\n * @param recipients Array of RecipientData items to split collect fees across multiple recipients.\n */\nstruct MultirecipientFeeCollectProfilePublicationData {\n    uint160 amount;\n    uint96 collectLimit;\n    address currency;\n    uint96 currentCollects;\n    uint16 referralFee;\n    bool followerOnly;\n    uint72 endTimestamp;\n    RecipientData[] recipients;\n}\n\nerror TooManyRecipients();\nerror InvalidRecipientSplits();\nerror RecipientSplitCannotBeZero();\n\n/**\n * @title MultirecipientCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, allowing customization of time to collect, number of collects,\n * splitting collect fee across multiple recipients, and whether only followers can collect.\n * It is charging a fee for collect and distributing it among (one or up to five) Receivers, Referral, Treasury.\n */\ncontract MultirecipientFeeCollectModule is BaseFeeCollectModule, LensModuleMetadata {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => RecipientData[])) internal _recipientsByPublicationByProfile;\n\n    constructor(\n        address hub,\n        address actionModule,\n        address moduleRegistry,\n        address moduleOwner\n    ) BaseFeeCollectModule(hub, actionModule, moduleRegistry) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    /**\n     * @inheritdoc ICollectModule\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address /* transactionExecutor */,\n        bytes calldata data\n    ) external override onlyActionModule returns (bytes memory) {\n        MultirecipientFeeCollectModuleInitData memory initData = abi.decode(\n            data,\n            (MultirecipientFeeCollectModuleInitData)\n        );\n\n        BaseFeeCollectModuleInitData memory baseInitData = BaseFeeCollectModuleInitData({\n            amount: initData.amount,\n            collectLimit: initData.collectLimit,\n            currency: initData.currency,\n            referralFee: initData.referralFee,\n            followerOnly: initData.followerOnly,\n            endTimestamp: initData.endTimestamp,\n            recipient: address(0)\n        });\n\n        // Zero amount for collect doesn't make sense here (in a module with 5 recipients)\n        // Better use SimpleFeeCollect module instead which allows 0 amount\n        if (baseInitData.amount == 0 || initData.currency == address(0)) {\n            revert Errors.InitParamsInvalid();\n        }\n        _validateBaseInitData(baseInitData);\n        _validateAndStoreRecipients(initData.recipients, profileId, pubId);\n        _storeBasePublicationCollectParameters(profileId, pubId, baseInitData);\n        return data;\n    }\n\n    /**\n     * @dev Validates the recipients array and stores them to (a separate from Base) storage.\n     *\n     * @param recipients An array of recipients\n     * @param profileId The profile ID who is publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     */\n    function _validateAndStoreRecipients(RecipientData[] memory recipients, uint256 profileId, uint256 pubId) internal {\n        uint256 len = recipients.length;\n\n        // Check number of recipients is supported\n        if (len < 2) {\n            revert Errors.InitParamsInvalid();\n        }\n\n        // Check recipient splits sum to 10 000 BPS (100%)\n        uint256 totalSplits;\n        uint256 i;\n        while (i < len) {\n            if (recipients[i].split == 0) revert RecipientSplitCannotBeZero();\n            totalSplits += recipients[i].split;\n\n            // Store each recipient while looping - avoids extra gas costs in successful cases\n            _recipientsByPublicationByProfile[profileId][pubId].push(recipients[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (totalSplits != BPS_MAX) {\n            revert InvalidRecipientSplits();\n        }\n    }\n\n    /**\n     * @dev Transfers the fee to multiple recipients.\n     *\n     * @inheritdoc BaseFeeCollectModule\n     */\n    function _transferToRecipients(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams,\n        address currency,\n        uint256 amount\n    ) internal override {\n        RecipientData[] memory recipients = _recipientsByPublicationByProfile[\n            processCollectParams.publicationCollectedProfileId\n        ][processCollectParams.publicationCollectedId];\n        uint256 len = recipients.length;\n\n        uint256 i;\n        while (i < len) {\n            uint256 amountForRecipient = (amount * recipients[i].split) / BPS_MAX;\n            if (amountForRecipient != 0)\n                IERC20(currency).safeTransferFrom(\n                    processCollectParams.transactionExecutor,\n                    recipients[i].recipient,\n                    amountForRecipient\n                );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The BaseProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(\n        uint256 profileId,\n        uint256 pubId\n    ) external view returns (MultirecipientFeeCollectProfilePublicationData memory) {\n        BaseProfilePublicationData memory baseData = getBasePublicationData(profileId, pubId);\n        RecipientData[] memory recipients = _recipientsByPublicationByProfile[profileId][pubId];\n        return\n            MultirecipientFeeCollectProfilePublicationData({\n                amount: baseData.amount,\n                collectLimit: baseData.collectLimit,\n                currency: baseData.currency,\n                currentCollects: baseData.currentCollects,\n                referralFee: baseData.referralFee,\n                followerOnly: baseData.followerOnly,\n                endTimestamp: baseData.endTimestamp,\n                recipients: recipients\n            });\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public pure override(BaseFeeCollectModule, LensModule) returns (bool) {\n        return BaseFeeCollectModule.supportsInterface(interfaceID) || LensModule.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "lens-modules/contracts/modules/act/collect/SimpleFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {BaseFeeCollectModule} from '../../act/collect/base/BaseFeeCollectModule.sol';\nimport {BaseFeeCollectModuleInitData, BaseProfilePublicationData} from '../../interfaces/IBaseFeeCollectModule.sol';\nimport {ICollectModule} from '../../interfaces/ICollectModule.sol';\nimport {LensModuleMetadata} from '../../LensModuleMetadata.sol';\nimport {LensModule} from '../../LensModule.sol';\n\n/**\n * @title SimpleFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, allowing customization of time to collect,\n * number of collects and whether only followers can collect.\n *\n * You can build your own collect modules by inheriting from BaseFeeCollectModule and adding your\n * functionality along with getPublicationData function.\n */\ncontract SimpleFeeCollectModule is BaseFeeCollectModule, LensModuleMetadata {\n    constructor(\n        address hub,\n        address actionModule,\n        address moduleRegistry,\n        address moduleOwner\n    ) BaseFeeCollectModule(hub, actionModule, moduleRegistry) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    /**\n     * @inheritdoc ICollectModule\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     * @param data The arbitrary data parameter, decoded into BaseFeeCollectModuleInitData struct:\n     *        amount: The collecting cost associated with this publication. 0 for free collect.\n     *        collectLimit: The maximum number of collects for this publication. 0 for no limit.\n     *        currency: The currency associated with this publication.\n     *        referralFee: The referral fee associated with this publication.\n     *        followerOnly: True if only followers of publisher may collect the post.\n     *        endTimestamp: The end timestamp after which collecting is impossible. 0 for no expiry.\n     *        recipient: Recipient of collect fees.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address /* transactionExecutor */,\n        bytes calldata data\n    ) external override onlyActionModule returns (bytes memory) {\n        BaseFeeCollectModuleInitData memory baseInitData = abi.decode(data, (BaseFeeCollectModuleInitData));\n        _validateBaseInitData(baseInitData);\n        _storeBasePublicationCollectParameters(profileId, pubId, baseInitData);\n        return '';\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The BaseProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(\n        uint256 profileId,\n        uint256 pubId\n    ) external view virtual returns (BaseProfilePublicationData memory) {\n        return getBasePublicationData(profileId, pubId);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public pure override(BaseFeeCollectModule, LensModule) returns (bool) {\n        return BaseFeeCollectModule.supportsInterface(interfaceID) || LensModule.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "lens-modules/contracts/modules/ActionRestricted.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Errors} from './constants/Errors.sol';\n\n/**\n * @title ActionRestricted\n * @author Lens Protocol\n *\n * @notice This abstract contract adds a public `ACTION_MODULE` immutable field, and `onlyActionModule` modifier,\n * to inherit from contracts that have functions restricted to be only called by the Action Modules.\n */\nabstract contract ActionRestricted {\n    address public immutable ACTION_MODULE;\n\n    modifier onlyActionModule() {\n        if (msg.sender != ACTION_MODULE) {\n            revert Errors.NotActionModule();\n        }\n        _;\n    }\n\n    constructor(address actionModule) {\n        ACTION_MODULE = actionModule;\n    }\n}\n"
    },
    "lens-modules/contracts/modules/constants/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary Errors {\n    error FollowInvalid();\n    error ModuleDataMismatch();\n    error NotHub();\n    error InitParamsInvalid();\n    error InvalidParams();\n    error MintLimitExceeded();\n    error CollectExpired();\n    error NotActionModule();\n    error CollectNotAllowed();\n    error AlreadyInitialized();\n}\n"
    },
    "lens-modules/contracts/modules/FeeModuleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Errors} from './constants/Errors.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {IModuleRegistry} from '../interfaces/IModuleRegistry.sol';\n\n/**\n * @title FeeModuleBase\n * @author Lens Protocol\n *\n * @notice This is an abstract contract to be inherited from by modules that require basic fee functionality.\n * It contains getters for module globals parameters as well as a validation function to check expected data.\n */\nabstract contract FeeModuleBase {\n    uint16 internal constant BPS_MAX = 10000;\n\n    ILensHub private immutable HUB;\n    IModuleRegistry public immutable MODULE_REGISTRY;\n\n    constructor(address hub, address moduleRegistry) {\n        HUB = ILensHub(hub);\n        MODULE_REGISTRY = IModuleRegistry(moduleRegistry);\n    }\n\n    function _verifyErc20Currency(address currency) internal {\n        if (currency != address(0)) {\n            MODULE_REGISTRY.verifyErc20Currency(currency);\n        }\n    }\n\n    function _treasuryData() internal view returns (address, uint16) {\n        return HUB.getTreasuryData();\n    }\n\n    function _validateDataIsExpected(bytes calldata data, address currency, uint256 amount) internal pure virtual {\n        (address decodedCurrency, uint256 decodedAmount) = abi.decode(data, (address, uint256));\n        if (decodedAmount != amount || decodedCurrency != currency) {\n            revert Errors.ModuleDataMismatch();\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/modules/follow/FeeFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IFollowModule} from '../../interfaces/IFollowModule.sol';\nimport {Errors} from '../constants/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {HubRestricted} from '../../base/HubRestricted.sol';\n\nimport {LensModuleMetadata} from '../LensModuleMetadata.sol';\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct FeeConfig {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module charges a fee for every follow.\n */\ncontract FeeFollowModule is Ownable, LensModuleMetadata, FeeModuleBase, HubRestricted, IFollowModule {\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return interfaceID == type(IFollowModule).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 profileId => FeeConfig config) internal _feeConfig;\n\n    constructor(\n        address hub,\n        address moduleRegistry,\n        address moduleOwner\n    ) FeeModuleBase(hub, moduleRegistry) HubRestricted(hub) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    /**\n     * @inheritdoc IFollowModule\n     * @param data The arbitrary data parameter, decoded into:\n     *  - address currency: The currency address, must be internally whitelisted.\n     *  - uint256 amount: The currency total amount to charge.\n     *  - address recipient: The custom recipient address to direct earnings to.\n     */\n    function initializeFollowModule(\n        uint256 profileId,\n        address /* transactionExecutor */,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        FeeConfig memory feeConfig = abi.decode(data, (FeeConfig));\n        // We allow address(0) to allow burning the currency. But the token has to support transfers to address(0).\n        //\n        // We don't introduce the upper limit to the amount, even though it might overflow if the amount * treasuryFee\n        // during processFollow. But this is a safe behavior, and a case that should never happen, because amounts close\n        // to type(uint256).max don't make any sense from the economic standpoint.\n        if (feeConfig.amount == 0) {\n            if (feeConfig.currency != address(0)) {\n                revert Errors.InitParamsInvalid();\n            }\n        } else {\n            _verifyErc20Currency(feeConfig.currency);\n        }\n        _feeConfig[profileId] = feeConfig;\n        return '';\n    }\n\n    /**\n     * @inheritdoc IFollowModule\n     * @notice Processes a follow by charging a fee.\n     */\n    function processFollow(\n        uint256 /* followerProfileId */,\n        uint256 followTokenId,\n        address transactionExecutor,\n        uint256 targetProfileId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        // We charge only when performing a fresh follow.\n        if (followTokenId == 0) {\n            uint256 amount = _feeConfig[targetProfileId].amount;\n            address currency = _feeConfig[targetProfileId].currency;\n\n            _validateDataIsExpected(data, currency, amount);\n\n            if (amount == 0 || currency == address(0)) {\n                // If the amount is zero, we don't charge anything.\n                return '';\n            }\n\n            (address treasury, uint16 treasuryFee) = _treasuryData();\n            address recipient = _feeConfig[targetProfileId].recipient;\n            uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n            uint256 adjustedAmount = amount - treasuryAmount;\n\n            IERC20(currency).safeTransferFrom(transactionExecutor, recipient, adjustedAmount);\n            if (treasuryAmount > 0) {\n                IERC20(currency).safeTransferFrom(transactionExecutor, treasury, treasuryAmount);\n            }\n        } else {\n            // If following with a follow token, we validate the amount is zero.\n            (, uint256 decodedAmount) = abi.decode(data, (address, uint256));\n            if (decodedAmount != 0) {\n                revert Errors.InvalidParams();\n            }\n        }\n        return '';\n    }\n\n    /**\n     * @notice Returns fee configuration for a given profile.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return FeeConfig The FeeConfig struct mapped to that profile.\n     */\n    function getFeeConfig(uint256 profileId) external view returns (FeeConfig memory) {\n        return _feeConfig[profileId];\n    }\n}\n"
    },
    "lens-modules/contracts/modules/follow/RevertFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Errors} from '../constants/Errors.sol';\nimport {IFollowModule} from '../../interfaces/IFollowModule.sol';\n\nimport {LensModuleMetadata} from '../LensModuleMetadata.sol';\n\n/**\n * @title RevertFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module rejects all follow attempts.\n */\ncontract RevertFollowModule is Ownable, LensModuleMetadata, IFollowModule {\n    constructor(address moduleOwner) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return interfaceID == type(IFollowModule).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /// @inheritdoc IFollowModule\n    function initializeFollowModule(\n        uint256 /* profileId */,\n        address /* transactionExecutor */,\n        bytes calldata /* data */\n    ) external pure override returns (bytes memory) {\n        return '';\n    }\n\n    /**\n     * @inheritdoc IFollowModule\n     * @notice Processes a follow by rejecting it, reverting the transaction. Parameters are ignored.\n     */\n    function processFollow(\n        uint256 /* followerProfileId */,\n        uint256 /* followTokenId */,\n        address /* transactionExecutor */,\n        uint256 /* profileId */,\n        bytes calldata /* data */\n    ) external pure override returns (bytes memory) {\n        revert Errors.FollowInvalid();\n    }\n}\n"
    },
    "lens-modules/contracts/modules/interfaces/IBaseFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {ICollectModule} from './ICollectModule.sol';\nimport {ModuleTypes} from '../libraries/constants/ModuleTypes.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication. 0 for free collect.\n * @param collectLimit The maximum number of collects for this publication. 0 for no limit.\n * @param currency The currency associated with this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly True if only followers of publisher may collect the post.\n * @param endTimestamp The end timestamp after which collecting is impossible. 0 for no expiry.\n * @param recipient Recipient of collect fees.\n */\nstruct BaseProfilePublicationData {\n    uint160 amount;\n    uint96 collectLimit;\n    address currency;\n    uint96 currentCollects;\n    address recipient;\n    uint16 referralFee;\n    bool followerOnly;\n    uint72 endTimestamp;\n}\n\n/**\n * @notice A struct containing the necessary data to initialize this Base Collect Module.\n *\n * @param amount The collecting cost associated with this publication. 0 for free collect.\n * @param collectLimit The maximum number of collects for this publication. 0 for no limit.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly True if only followers of publisher may collect the post.\n * @param endTimestamp The end timestamp after which collecting is impossible. 0 for no expiry.\n * @param recipient Recipient of collect fees.\n */\nstruct BaseFeeCollectModuleInitData {\n    uint160 amount;\n    uint96 collectLimit;\n    address currency;\n    uint16 referralFee;\n    bool followerOnly;\n    uint72 endTimestamp;\n    address recipient;\n}\n\ninterface IBaseFeeCollectModule is ICollectModule {\n    /**\n     * @notice Returns the Base publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The BaseProfilePublicationData struct mapped to that publication.\n     */\n    function getBasePublicationData(\n        uint256 profileId,\n        uint256 pubId\n    ) external view returns (BaseProfilePublicationData memory);\n\n    /**\n     * @notice Calculates and returns the collect fee of a publication.\n     * @dev Override this function to use a different formula for the fee.\n     *\n     * @return The collect fee of the specified publication.\n     */\n    function calculateFee(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) external view returns (uint160);\n}\n"
    },
    "lens-modules/contracts/modules/interfaces/ICollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {ModuleTypes} from '../libraries/constants/ModuleTypes.sol';\n\n/**\n * @title ICollectModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible CollectModules.\n * Collect modules allow users to execute custom logic upon a collect action over a publication, like:\n *  - Only allow the collect if the collector is following the publication author.\n *  - Only allow the collect if the collector has made a payment to\n *  - Allow any collect but only during the first 24 hours.\n *  - Etc.\n */\ninterface ICollectModule {\n    /**\n     * @notice Initializes data for a given publication being published.\n     * @custom:permissions LensHub.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param transactionExecutor The owner or an approved delegated executor.\n     * @param data Arbitrary data __passed from the user!__ to be decoded.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address transactionExecutor,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a collect action for a given publication.\n     * @custom:permissions LensHub.\n     *\n     * @param processCollectParams The parameters for the collect action.\n     *\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\n     * indexers or UIs.\n     */\n    function processCollect(\n        ModuleTypes.ProcessCollectParams calldata processCollectParams\n    ) external returns (bytes memory);\n}\n"
    },
    "lens-modules/contracts/modules/interfaces/ILensModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\ninterface ILensModule is IERC165 {\n    /// @dev for now we check for keccak('LENS_MODULE');\n    /// Override this and add the type(IModuleInterface).interfaceId for corresponding module type\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    /// @notice Human-readable description of the module\n    // Can be JSON\n    // Can be contract source code\n    // Can be github link\n    // Can be ipfs with documentation\n    // etc\n    function getModuleMetadataURI() external view returns (string memory);\n}\n"
    },
    "lens-modules/contracts/modules/LensModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ILensModule} from './interfaces/ILensModule.sol';\n\nabstract contract LensModule is ILensModule {\n    /// @inheritdoc ILensModule\n    function supportsInterface(bytes4 interfaceID) public pure virtual override returns (bool) {\n        return interfaceID == bytes4(keccak256(abi.encodePacked('LENS_MODULE')));\n    }\n}\n"
    },
    "lens-modules/contracts/modules/LensModuleMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {LensModule} from './LensModule.sol';\n\nabstract contract LensModuleMetadata is LensModule, Ownable {\n    string private metadataURI;\n\n    function setModuleMetadataURI(string memory _metadataURI) external onlyOwner {\n        metadataURI = _metadataURI;\n    }\n\n    function getModuleMetadataURI() external view returns (string memory) {\n        return metadataURI;\n    }\n}\n"
    },
    "lens-modules/contracts/modules/LensModuleMetadataInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {LensModuleMetadata} from './LensModuleMetadata.sol';\n\ncontract LensModuleMetadataInitializable is Ownable, LensModuleMetadata {\n    constructor(address owner_) Ownable() LensModuleMetadata() {\n        _transferOwnership(owner_);\n    }\n\n    function initialize(address moduleOwner) external virtual {\n        if (owner() != address(0) || moduleOwner == address(0)) {\n            revert();\n        }\n        _transferOwnership(moduleOwner);\n    }\n}\n"
    },
    "lens-modules/contracts/modules/libraries/constants/ModuleTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Types} from '../../../libraries/constants/Types.sol';\n\n/**\n * @title Types\n * @author Lens Protocol\n *\n * @notice A standard library of data types used throughout the Lens Protocol modules.\n */\nlibrary ModuleTypes {\n    struct ProcessCollectParams {\n        uint256 publicationCollectedProfileId;\n        uint256 publicationCollectedId;\n        uint256 collectorProfileId;\n        address collectorProfileOwner;\n        address transactionExecutor;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        Types.PublicationType[] referrerPubTypes;\n        bytes data;\n    }\n}\n"
    },
    "lens-modules/contracts/modules/libraries/FollowValidationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {ILensHub} from '../../interfaces/ILensHub.sol';\nimport {Errors} from '../../libraries/constants/Errors.sol';\n\n/**\n * @title FollowValidationLib\n * @author Lens Protocol\n *\n * @notice A library contract that verifies that a user is following another user and reverts if not.\n */\nlibrary FollowValidationLib {\n    function validateIsFollowing(address hub, uint256 followerProfileId, uint256 followedProfileId) internal view {\n        if (!ILensHub(hub).isFollowing(followerProfileId, followedProfileId)) {\n            revert Errors.NotFollowing();\n        }\n    }\n\n    function validateIsFollowingOrSelf(\n        address hub,\n        uint256 followerProfileId,\n        uint256 followedProfileId\n    ) internal view {\n        // We treat following yourself is always true\n        if (followerProfileId == followedProfileId) {\n            return;\n        }\n        validateIsFollowing(hub, followerProfileId, followedProfileId);\n    }\n}\n"
    },
    "lens-modules/contracts/modules/reference/DegreesOfSeparationReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {Types} from '../../libraries/constants/Types.sol';\nimport {Errors} from '../../libraries/constants/Errors.sol';\nimport {ILensHub} from '../../interfaces/ILensHub.sol';\nimport {IERC721Timestamped} from '../../interfaces/IERC721Timestamped.sol';\nimport {IReferenceModule} from '../../interfaces/IReferenceModule.sol';\nimport {HubRestricted} from '../../base/HubRestricted.sol';\nimport {FollowValidationLib} from '../../modules/libraries/FollowValidationLib.sol';\n\nimport {LensModuleMetadata} from '../../modules/LensModuleMetadata.sol';\n\n/**\n * @notice Struct representing the module configuration for certain publication.\n *\n * @param setUp Indicates if the publication was set up to use this module, to then allow updating params.\n * @param commentsRestricted Indicates if the comment operation is restricted or open to everyone.\n * @param quotesRestricted Indicates if the quote operation is restricted or open to everyone.\n * @param mirrorsRestricted Indicates if the mirror operation is restricted or open to everyone.\n * @param degreesOfSeparation The max degrees of separation allowed for restricted operations.\n * @param sourceProfile The ID of the profile from where the follower path should be started. Usually it will match the\n * `originalAuthorProfile`.\n * @param originalAuthorProfile Original author of the Post or Quote when the degrees restriction was first applied.\n */\nstruct ModuleConfig {\n    bool setUp;\n    bool commentsRestricted;\n    bool quotesRestricted;\n    bool mirrorsRestricted;\n    uint8 degreesOfSeparation;\n    uint96 sourceProfile;\n    uint96 originalAuthorProfile;\n}\n\n/**\n * @title DegreesOfSeparationReferenceModule\n * @author Lens Protocol\n *\n * @notice This reference module allows to set a degree of separation `n`, and then allows to quote/comment/mirror\n * only to profiles that are at most at `n` degrees of separation from the source profile, which is expected to be set\n * as the author of the root publication.\n */\ncontract DegreesOfSeparationReferenceModule is LensModuleMetadata, HubRestricted, IReferenceModule {\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return interfaceID == type(IReferenceModule).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    error InvalidDegreesOfSeparation();\n    error OperationDisabled();\n    error ProfilePathExceedsDegreesOfSeparation();\n    error NotInheritingPointedPubConfig();\n\n    /**\n     * @dev Because of the \"Six degrees of separation\" theory, in the long term, setting up 5, 6 or more degrees of\n     * separation will be almost equivalent to turning off the restriction.\n     * If we also take into account the gas cost of performing the validations on-chain, and the cost of off-chain\n     * computation of the path, makes sense to only support up to 2 degrees of separation.\n     */\n    uint8 public constant MAX_DEGREES_OF_SEPARATION = 2;\n\n    mapping(uint256 profileId => mapping(uint256 pubId => ModuleConfig config)) internal _moduleConfig;\n\n    constructor(address hub, address moduleOwner) HubRestricted(hub) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev The `data` param should have ABI-encoded the following information:\n     *  - bool commentsRestricted: Indicates if the comment operation is restricted or open to everyone.\n     *  - bool quotesRestricted: Indicates if the quote operation is restricted or open to everyone.\n     *  - bool mirrorsRestricted: Indicates if the mirror operation is restricted or open to everyone.\n     *  - uint8 degreesOfSeparation: The max degrees of separation allowed for restricted operations.\n     *  - uint96 sourceProfile: The ID of the profile from where the follower path should be started. Expected to be set\n     *    as the author of the root publication.\n     */\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        address /* transactionExecutor */,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (\n            bool commentsRestricted,\n            bool quotesRestricted,\n            bool mirrorsRestricted,\n            uint8 degreesOfSeparation,\n            uint96 sourceProfile\n        ) = abi.decode(data, (bool, bool, bool, uint8, uint96));\n        if (degreesOfSeparation > MAX_DEGREES_OF_SEPARATION) {\n            revert InvalidDegreesOfSeparation();\n        }\n        if (!IERC721Timestamped(HUB).exists(sourceProfile)) {\n            revert Errors.TokenDoesNotExist();\n        }\n\n        uint96 originalAuthorProfile;\n        Types.PublicationMemory memory pub = ILensHub(HUB).getPublication(profileId, pubId);\n        if (pub.pubType == Types.PublicationType.Comment) {\n            ModuleConfig memory parentConfig = _moduleConfig[pub.pointedProfileId][pub.pointedPubId];\n            if (!parentConfig.setUp) {\n                // Comments cannot restrict degrees of separation, unless the pointed publication has it enabled too.\n                revert OperationDisabled();\n            }\n            originalAuthorProfile = parentConfig.originalAuthorProfile;\n        } else {\n            originalAuthorProfile = uint96(profileId);\n        }\n\n        _moduleConfig[profileId][pubId] = ModuleConfig(\n            true,\n            commentsRestricted,\n            quotesRestricted,\n            mirrorsRestricted,\n            degreesOfSeparation,\n            sourceProfile,\n            originalAuthorProfile\n        );\n        return data;\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev It will apply the degrees of separation restriction if the publication has `commentsRestricted` enabled.\n     * The param `processCommentParams.data` has ABI-encoded the array of profile IDs representing the follower path\n     * between the source profile and the profile authoring the comment.\n     * In addition, if comments were restricted, inheritance of commenting restrictions will be enforced.\n     */\n    function processComment(\n        Types.ProcessCommentParams calldata processCommentParams\n    ) external view override onlyHub returns (bytes memory) {\n        ModuleConfig memory config = _moduleConfig[processCommentParams.pointedProfileId][\n            processCommentParams.pointedPubId\n        ];\n        if (config.commentsRestricted) {\n            _validateDegreesOfSeparationRestriction({\n                sourceProfile: config.sourceProfile,\n                originalAuthorProfile: config.originalAuthorProfile,\n                profileId: processCommentParams.profileId,\n                degreesOfSeparation: config.degreesOfSeparation,\n                profilePath: abi.decode(processCommentParams.data, (uint256[]))\n            });\n            _validateCommentInheritedConfigFromPointedPub({\n                pointedPubConfig: config,\n                newCommentPubConfig: _moduleConfig[processCommentParams.profileId][processCommentParams.pubId]\n            });\n        }\n        return '';\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev It will apply the degrees of separation restriction if the publication has `quotesRestricted` enabled.\n     * The param `processQuoteParams.data` has ABI-encoded the array of profile IDs representing the follower path\n     * between the source profile and the profile authoring the quote.\n     */\n    function processQuote(\n        Types.ProcessQuoteParams calldata processQuoteParams\n    ) external view override onlyHub returns (bytes memory) {\n        ModuleConfig memory config = _moduleConfig[processQuoteParams.pointedProfileId][\n            processQuoteParams.pointedPubId\n        ];\n        if (config.quotesRestricted) {\n            _validateDegreesOfSeparationRestriction({\n                sourceProfile: config.sourceProfile,\n                originalAuthorProfile: config.originalAuthorProfile,\n                profileId: processQuoteParams.profileId,\n                degreesOfSeparation: config.degreesOfSeparation,\n                profilePath: abi.decode(processQuoteParams.data, (uint256[]))\n            });\n        }\n        return '';\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev It will apply the degrees of separation restriction if the publication has `mirrorsRestricted` enabled.\n     * The param `processMirrorParams.data` has ABI-encoded the array of profile IDs representing the follower path\n     * between the source profile and the profile authoring the mirror.\n     */\n    function processMirror(\n        Types.ProcessMirrorParams calldata processMirrorParams\n    ) external view override onlyHub returns (bytes memory) {\n        ModuleConfig memory config = _moduleConfig[processMirrorParams.pointedProfileId][\n            processMirrorParams.pointedPubId\n        ];\n        if (config.mirrorsRestricted) {\n            _validateDegreesOfSeparationRestriction({\n                sourceProfile: config.sourceProfile,\n                originalAuthorProfile: config.originalAuthorProfile,\n                profileId: processMirrorParams.profileId,\n                degreesOfSeparation: config.degreesOfSeparation,\n                profilePath: abi.decode(processMirrorParams.data, (uint256[]))\n            });\n        }\n        return '';\n    }\n\n    /**\n     * @notice Gets the module configuration for the given publication.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     *\n     * @return ModuleConfig The module configuration set for the given publication.\n     */\n    function getModuleConfig(uint256 profileId, uint256 pubId) external view returns (ModuleConfig memory) {\n        return _moduleConfig[profileId][pubId];\n    }\n\n    /**\n     * @dev The data has encoded an array of integers, each integer is a profile ID, the whole array represents a path\n     * of `n` profiles.\n     *\n     * Let's define `X --> Y` as `The owner of X is following Y`. Then, being `path[i]` the i-th profile in the path,\n     * the following condition must be met for a given path of `n` profiles:\n     *\n     *    sourceProfile --> path[0] --> path[1] --> path[2] --> ... --> path[n-2] --> path[n-1] --> profileId\n     *\n     * @param sourceProfile The ID of the profile from where the follower path should be started. Most likely to be the\n     * root publication's author.\n     * @param profileId The ID of the publication being published's author.\n     * @param degreesOfSeparation The degrees of separations configured for the given publication.\n     * @param profilePath The array of profile IDs representing the follower path between the source profile and the\n     * profile authoring the new publication (it could be a comment, a quote or a mirror of the pointed one).\n     */\n    function _validateDegreesOfSeparationRestriction(\n        uint256 sourceProfile,\n        uint256 originalAuthorProfile,\n        uint256 profileId,\n        uint8 degreesOfSeparation,\n        uint256[] memory profilePath\n    ) internal view {\n        // Unrestricted if the profile authoring the publication is the source or the original author profile.\n        if (profileId == sourceProfile || profileId == originalAuthorProfile) {\n            return;\n        }\n\n        // Here we only have cases where the source profile is not the same as the profile authoring the new publication.\n        if (degreesOfSeparation == 0) {\n            // If `degreesOfSeparation` was set to zero, only `sourceProfile` is allowed to interact.\n            revert OperationDisabled();\n        } else if (profilePath.length > degreesOfSeparation - 1) {\n            revert ProfilePathExceedsDegreesOfSeparation();\n        }\n\n        if (profilePath.length > 0) {\n            // Checks that the source profile follows the first profile in the path.\n            // In the previous notation: sourceProfile --> path[0]\n            FollowValidationLib.validateIsFollowing({\n                hub: HUB,\n                followerProfileId: sourceProfile,\n                followedProfileId: profilePath[0]\n            });\n            // Checks each profile owner in the path is following the profile coming next, according the order.\n            // In the previous notaiton: path[0] --> path[1] --> path[2] --> ... --> path[n-2] --> path[n-1]\n            uint256 i;\n            while (i < profilePath.length - 1) {\n                FollowValidationLib.validateIsFollowing({\n                    hub: HUB,\n                    followerProfileId: profilePath[i],\n                    followedProfileId: profilePath[i + 1]\n                });\n                unchecked {\n                    ++i;\n                }\n            }\n            // Checks that the last profile in the path follows the profile authoring the new publication.\n            // In the previous notation: path[n-1] --> profileId\n            FollowValidationLib.validateIsFollowing({\n                hub: HUB,\n                followerProfileId: profilePath[i],\n                followedProfileId: profileId\n            });\n        } else {\n            // Checks that the source profile follows the profile authoring the new publication.\n            // In the previous notation: sourceProfile --> profileId\n            FollowValidationLib.validateIsFollowing({\n                hub: HUB,\n                followerProfileId: sourceProfile,\n                followedProfileId: profileId\n            });\n        }\n    }\n\n    /**\n     * @notice Validates that the comment configuration is inherited from pointed publication.\n     *\n     * @param pointedPubConfig The pointed publication's degrees of separation module configuration.\n     * @param newCommentPubConfig The comment being processed's degrees of separation module configuration.\n     */\n    function _validateCommentInheritedConfigFromPointedPub(\n        ModuleConfig memory pointedPubConfig,\n        ModuleConfig memory newCommentPubConfig\n    ) internal pure {\n        // We only care about inheritance of the comment restrictions.\n        if (\n            !newCommentPubConfig.setUp ||\n            !newCommentPubConfig.commentsRestricted ||\n            newCommentPubConfig.sourceProfile != pointedPubConfig.sourceProfile ||\n            newCommentPubConfig.degreesOfSeparation != pointedPubConfig.degreesOfSeparation\n        ) {\n            revert NotInheritingPointedPubConfig();\n        }\n    }\n}\n"
    },
    "lens-modules/contracts/modules/reference/FollowerOnlyReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {IReferenceModule} from '../../interfaces/IReferenceModule.sol';\nimport {HubRestricted} from '../../base/HubRestricted.sol';\nimport {Types} from '../../libraries/constants/Types.sol';\nimport {FollowValidationLib} from '../../modules/libraries/FollowValidationLib.sol';\n\nimport {LensModuleMetadata} from '../../modules/LensModuleMetadata.sol';\n\n/**\n * @title FollowerOnlyReferenceModule\n * @author Lens Protocol\n *\n * @notice A simple reference module that validates that comments, quotes or mirrors originate from a profile that\n * follows the profile of the original publication.\n */\ncontract FollowerOnlyReferenceModule is LensModuleMetadata, HubRestricted, IReferenceModule {\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return interfaceID == type(IReferenceModule).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    constructor(address hub, address moduleOwner) HubRestricted(hub) LensModuleMetadata() Ownable() {\n        _transferOwnership(moduleOwner);\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev There is nothing needed at initialization.\n     */\n    function initializeReferenceModule(\n        uint256 /* profileId */,\n        uint256 /* pubId */,\n        address /* transactionExecutor */,\n        bytes calldata /* data */\n    ) external pure returns (bytes memory) {\n        return '';\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev Validates that the commenting profile is the original author or a follower of it.\n     */\n    function processComment(\n        Types.ProcessCommentParams calldata processCommentParams\n    ) external view override returns (bytes memory) {\n        return\n            _performFollowerOnlyCheck({\n                followerProfileId: processCommentParams.profileId,\n                followedProfileId: processCommentParams.pointedProfileId\n            });\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev Validates that the quoting profile is the original author or a follower of it.\n     */\n    function processQuote(\n        Types.ProcessQuoteParams calldata processQuoteParams\n    ) external view override returns (bytes memory) {\n        return\n            _performFollowerOnlyCheck({\n                followerProfileId: processQuoteParams.profileId,\n                followedProfileId: processQuoteParams.pointedProfileId\n            });\n    }\n\n    /**\n     * @inheritdoc IReferenceModule\n     *\n     * @dev Validates that the mirroring profile is the original author or a follower of it.\n     */\n    function processMirror(\n        Types.ProcessMirrorParams calldata processMirrorParams\n    ) external view override returns (bytes memory) {\n        return\n            _performFollowerOnlyCheck({\n                followerProfileId: processMirrorParams.profileId,\n                followedProfileId: processMirrorParams.pointedProfileId\n            });\n    }\n\n    function _performFollowerOnlyCheck(\n        uint256 followerProfileId,\n        uint256 followedProfileId\n    ) internal view returns (bytes memory) {\n        FollowValidationLib.validateIsFollowingOrSelf(HUB, followerProfileId, followedProfileId);\n        return '';\n    }\n}\n"
    },
    "lens-modules/contracts/namespaces/constants/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary RegistryErrors {\n    error NotHandleNorTokenOwner();\n    error OnlyLensHub();\n    error NotLinked();\n    error DoesNotExist();\n    error DoesNotHavePermissions();\n    error HandleAndTokenNotInSameWallet();\n    error SignatureInvalid();\n}\n\nlibrary HandlesErrors {\n    error HandleLengthInvalid();\n    error HandleContainsInvalidCharacters();\n    error HandleFirstCharInvalid();\n    error NotOwnerNorWhitelisted();\n    error NotOwner();\n    error NotHub();\n    error DoesNotExist();\n    error NotEOA();\n    error DisablingAlreadyTriggered();\n    error GuardianEnabled();\n    error AlreadyEnabled();\n}\n"
    },
    "lens-modules/contracts/namespaces/constants/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {RegistryTypes} from './Types.sol';\n\nlibrary HandlesEvents {\n    event HandleMinted(string handle, string namespace, uint256 handleId, address to, uint256 timestamp);\n\n    /**\n     * @dev Emitted when an address' Token Guardian state change is triggered.\n     *\n     * @param wallet The address whose Token Guardian state change is being triggered.\n     * @param enabled True if the Token Guardian is being enabled, false if it is being disabled.\n     * @param tokenGuardianDisablingTimestamp The UNIX timestamp when disabling the Token Guardian will take effect,\n     * if disabling it. Zero if the protection is being enabled.\n     * @param timestamp The UNIX timestamp of the change being triggered.\n     */\n    event TokenGuardianStateChanged(\n        address indexed wallet,\n        bool indexed enabled,\n        uint256 tokenGuardianDisablingTimestamp,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a collection's token URI is updated.\n     * @param fromTokenId The ID of the smallest token that requires its token URI to be refreshed.\n     * @param toTokenId The ID of the biggest token that requires its token URI to be refreshed. Max uint256 to refresh\n     * all of them.\n     */\n    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\n}\n\nlibrary RegistryEvents {\n    event HandleLinked(\n        RegistryTypes.Handle handle,\n        RegistryTypes.Token token,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * WARNING: If a linked handle or token is burnt, this event will not be emitted.\n     * Indexers should also take into account token burns through ERC-721 Transfer events to track all unlink actions.\n     * The `resolveHandle` and `resolveToken` functions will properly reflect the unlink in any case.\n     */\n    event HandleUnlinked(\n        RegistryTypes.Handle handle,\n        RegistryTypes.Token token,\n        address transactionExecutor,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a signer's nonce is used and, as a consequence, the next available nonce is updated.\n     *\n     * @param signer The signer whose next available nonce was updated.\n     * @param nonce The next available nonce that can be used to execute a meta-tx successfully.\n     * @param timestamp The UNIX timestamp of the nonce being used.\n     */\n    event NonceUpdated(address indexed signer, uint256 nonce, uint256 timestamp);\n}\n"
    },
    "lens-modules/contracts/namespaces/constants/Typehash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary Typehash {\n\n    bytes32 constant EIP712_DOMAIN = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n\n    bytes32 constant LINK = keccak256('Link(uint256 handleId,uint256 profileId,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant UNLINK = keccak256('Unlink(uint256 handleId,uint256 profileId,uint256 nonce,uint256 deadline)');\n}\n"
    },
    "lens-modules/contracts/namespaces/constants/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @title Namespaces Types\n * @author Lens Protocol\n */\nlibrary RegistryTypes {\n    struct Token {\n        uint256 id; // SLOT 0\n        address collection; // SLOT 1 - end\n        // uint96 _gap; // SLOT 1 - start\n    }\n\n    struct Handle {\n        uint256 id; // SLOT 0\n        address collection; // SLOT 1 - end\n        // uint96 _gap; // SLOT 1 - start\n    }\n}\n"
    },
    "lens-modules/contracts/namespaces/LensHandles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from '../misc/ImmutableOwnable.sol';\nimport {ILensHandles} from '../interfaces/ILensHandles.sol';\nimport {HandlesEvents} from './constants/Events.sol';\nimport {HandlesErrors} from './constants/Errors.sol';\nimport {IHandleTokenURI} from '../interfaces/IHandleTokenURI.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {ERC2981CollectionRoyalties} from '../base/ERC2981CollectionRoyalties.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a prefix, using the slash symbol as separator.\n *\n *      handle = namespace /@ localName\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n *\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract LensHandles is ERC721, ERC2981CollectionRoyalties, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    // We used 31 to fit the handle in a single slot, with `.lens` that restricted localName to use 26 characters.\n    // Can be extended later if needed.\n    uint256 internal constant MAX_LOCAL_NAME_LENGTH = 26;\n    string public constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    bytes32 public constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 public immutable TOKEN_GUARDIAN_COOLDOWN;\n    uint256 internal constant GUARDIAN_ENABLED = type(uint256).max;\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    uint256 internal _profileRoyaltiesBps; // Slot 7\n    uint256 private _totalSupply;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    address internal _handleTokenURIContract;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return 'Lens Handles';\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return 'LH';\n    }\n\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function setHandleTokenURIContract(address handleTokenURIContract) external override onlyOwner {\n        _handleTokenURIContract = handleTokenURIContract;\n        emit HandlesEvents.BatchMetadataUpdate({fromTokenId: 0, toTokenId: type(uint256).max});\n    }\n\n    function getHandleTokenURIContract() external view override returns (address) {\n        return _handleTokenURIContract;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return IHandleTokenURI(_handleTokenURIContract).getTokenURI(tokenId, _localNames[tokenId], NAMESPACE);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(\n        address to,\n        string calldata localName\n    ) external onlyOwnerOrWhitelistedProfileCreator returns (uint256) {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        --_totalSupply;\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external override onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != GUARDIAN_ENABLED) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external override onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == GUARDIAN_ENABLED) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = GUARDIAN_ENABLED;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: GUARDIAN_ENABLED,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(ownerOf(tokenId))) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view override returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(NAMESPACE, '/@', localName);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view override returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721, ERC2981CollectionRoyalties, IERC165) returns (bool) {\n        return (ERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId));\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        ++_totalSupply;\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    /// @dev This function is used to validate the local name when migrating from V1 to V2.\n    ///      As in V1 we also allowed the Hyphen '-' character, we need to allow it here as well and use a separate\n    ///      validation function for migration VS newly created handles.\n    function _validateLocalNameMigration(string memory localName) internal pure {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength > MAX_LOCAL_NAME_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev In V2 we only accept the following characters: [a-z0-9_] to be used in newly created handles.\n    ///      We also disallow the first character to be an underscore '_'.\n    function _validateLocalName(string memory localName) internal pure {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength > MAX_LOCAL_NAME_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev We only accept lowercase characters to avoid confusion.\n    /// @param char The character to check.\n    /// @return True if the character is alphanumeric, false otherwise.\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n        (_tokenGuardianDisablingTimestamp[wallet] == GUARDIAN_ENABLED ||\n            block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256 slot) {\n        assembly {\n            slot := _profileRoyaltiesBps.slot\n        }\n    }\n\n    function _getReceiver(uint256 /* tokenId */) internal view override returns (address) {\n        return ILensHub(LENS_HUB).getTreasury();\n    }\n\n    function _beforeRoyaltiesSet(uint256 /* royaltiesInBasisPoints */) internal view override {\n        if (msg.sender != OWNER) {\n            revert OnlyOwner();\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}\n"
    },
    "lens-modules/contracts/namespaces/TokenHandleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {ITokenHandleRegistry} from '../interfaces/ITokenHandleRegistry.sol';\nimport {RegistryTypes} from './constants/Types.sol';\nimport {Types} from '../libraries/constants/Types.sol';\nimport {Errors} from '../libraries/constants/Errors.sol';\nimport {RegistryErrors} from './constants/Errors.sol';\nimport {RegistryEvents} from './constants/Events.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {ILensHandles} from '../interfaces/ILensHandles.sol';\nimport {Typehash} from './constants/Typehash.sol';\n\n/**\n * @title TokenHandleRegistry\n * @author Lens Protocol\n * @notice This contract is used to link a token with a handle.\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract TokenHandleRegistry is ITokenHandleRegistry {\n    string constant EIP712_DOMAIN_VERSION = '1';\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    // First version of TokenHandleRegistry only works with Lens Profiles and .lens namespace.\n    address immutable LENS_HUB;\n    address immutable LENS_HANDLES;\n\n    // Using _handleHash(Handle) and _tokenHash(Token) as keys given that structs cannot be used as them.\n    mapping(bytes32 handle => RegistryTypes.Token token) handleToToken;\n    mapping(bytes32 token => RegistryTypes.Handle handle) tokenToHandle;\n\n    mapping(address signer => uint256 nonce) public nonces;\n\n    constructor(address lensHub, address lensHandles) {\n        LENS_HUB = lensHub;\n        LENS_HANDLES = lensHandles;\n    }\n\n    // Lens V1 to Lens V2 migration function\n    // WARNING: It is able to link the Token and Handle even if they're not in the same wallet.\n    //          But it is designed to be only called from LensHub migration function, which assures that they are.\n    function migrationLink(uint256 handleId, uint256 profileId) external {\n        if (msg.sender != LENS_HUB) {\n            revert RegistryErrors.OnlyLensHub();\n        }\n        _executeLinkage(\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\n            RegistryTypes.Token({collection: LENS_HUB, id: profileId}),\n            address(0)\n        );\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function link(uint256 handleId, uint256 profileId) external {\n        _link(handleId, profileId, msg.sender);\n    }\n\n    function linkWithSig(uint256 handleId, uint256 profileId, Types.EIP712Signature calldata signature) external {\n        _validateLinkSignature(signature, handleId, profileId);\n        _link(handleId, profileId, signature.signer);\n    }\n\n    function _link(uint256 handleId, uint256 profileId, address transactionExecutor) private {\n        // Handle and profile must be owned by the same address.\n        // Caller should be the owner of the profile or one of its approved delegated executors.\n        address profileOwner = ILensHub(LENS_HUB).ownerOf(profileId);\n        if (profileOwner != ILensHandles(LENS_HANDLES).ownerOf(handleId)) {\n            revert RegistryErrors.HandleAndTokenNotInSameWallet();\n        }\n        if (\n            transactionExecutor != profileOwner &&\n            !ILensHub(LENS_HUB).isDelegatedExecutorApproved(profileId, transactionExecutor)\n        ) {\n            revert RegistryErrors.DoesNotHavePermissions();\n        }\n        _executeLinkage(\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\n            RegistryTypes.Token({collection: LENS_HUB, id: profileId}),\n            transactionExecutor\n        );\n    }\n\n    /// @notice This function is used to invalidate signatures by incrementing the nonce\n    /// @param increment The amount to increment the nonce by\n    function incrementNonce(uint8 increment) external {\n        uint256 currentNonce = nonces[msg.sender];\n        nonces[msg.sender] = currentNonce + increment;\n        emit RegistryEvents.NonceUpdated(msg.sender, currentNonce + increment, block.timestamp);\n    }\n\n    function _validateLinkSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 handleId,\n        uint256 profileId\n    ) internal {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.LINK,\n                        handleId,\n                        profileId,\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function _validateUnlinkSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 handleId,\n        uint256 profileId\n    ) internal {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.UNLINK,\n                        handleId,\n                        profileId,\n                        _getNonceIncrementAndEmitEvent(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\n        if (block.timestamp > signature.deadline) revert Errors.SignatureExpired();\n        // If the expected address is a contract, check the signature there.\n        if (signature.signer.code.length != 0) {\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\n                revert Errors.SignatureInvalid();\n            }\n        } else {\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\n                revert Errors.SignatureInvalid();\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\n        return keccak256(abi.encodePacked('\\x19\\x01', calculateDomainSeparator(), hashedMessage));\n    }\n\n    function calculateDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    Typehash.EIP712_DOMAIN,\n                    keccak256('TokenHandleRegistry'),\n                    EIP712_DOMAIN_VERSION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function unlink(uint256 handleId, uint256 profileId) external {\n        _unlink(handleId, profileId, msg.sender);\n    }\n\n    function unlinkWithSig(uint256 handleId, uint256 profileId, Types.EIP712Signature calldata signature) external {\n        _validateUnlinkSignature(signature, handleId, profileId);\n        _unlink(handleId, profileId, signature.signer);\n    }\n\n    function _unlink(uint256 handleId, uint256 profileId, address transactionExecutor) private {\n        if (handleId == 0 || profileId == 0) {\n            revert RegistryErrors.DoesNotExist();\n        }\n        if (\n            ILensHandles(LENS_HANDLES).exists(handleId) &&\n            ILensHandles(LENS_HANDLES).ownerOf(handleId) != transactionExecutor &&\n            ILensHub(LENS_HUB).exists(profileId) &&\n            (ILensHub(LENS_HUB).ownerOf(profileId) != transactionExecutor &&\n                !ILensHub(LENS_HUB).isDelegatedExecutorApproved(profileId, transactionExecutor))\n        ) {\n            revert RegistryErrors.NotHandleNorTokenOwner();\n        }\n        RegistryTypes.Handle memory handle = RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId});\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\n        // We check if the tokens are (were) linked for the case if some of them doesn't exist\n        if (tokenPointedByHandle.id != profileId) {\n            revert RegistryErrors.NotLinked();\n        }\n        _executeUnlinkage(handle, tokenPointedByHandle, transactionExecutor);\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function resolve(uint256 handleId) external view returns (uint256) {\n        if (!ILensHandles(LENS_HANDLES).exists(handleId)) {\n            revert RegistryErrors.DoesNotExist();\n        }\n        uint256 resolvedTokenId = _resolveHandleToToken(RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}))\n            .id;\n        if (resolvedTokenId == 0 || !ILensHub(LENS_HUB).exists(resolvedTokenId)) {\n            return 0;\n        }\n        return resolvedTokenId;\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function getDefaultHandle(uint256 profileId) external view returns (uint256) {\n        if (!ILensHub(LENS_HUB).exists(profileId)) {\n            revert RegistryErrors.DoesNotExist();\n        }\n        uint256 defaultHandleId = _resolveTokenToHandle(RegistryTypes.Token({collection: LENS_HUB, id: profileId})).id;\n        if (defaultHandleId == 0 || !ILensHandles(LENS_HANDLES).exists(defaultHandleId)) {\n            return 0;\n        }\n        return defaultHandleId;\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _resolveHandleToToken(\n        RegistryTypes.Handle memory handle\n    ) internal view returns (RegistryTypes.Token storage) {\n        return handleToToken[_handleHash(handle)];\n    }\n\n    function _resolveTokenToHandle(\n        RegistryTypes.Token memory token\n    ) internal view returns (RegistryTypes.Handle storage) {\n        return tokenToHandle[_tokenHash(token)];\n    }\n\n    function _executeLinkage(\n        RegistryTypes.Handle memory handle,\n        RegistryTypes.Token memory token,\n        address transactionExecutor\n    ) internal {\n        _deleteTokenToHandleLinkageIfAny(handle, transactionExecutor);\n        handleToToken[_handleHash(handle)] = token;\n\n        _deleteHandleToTokenLinkageIfAny(token, transactionExecutor);\n        tokenToHandle[_tokenHash(token)] = handle;\n\n        emit RegistryEvents.HandleLinked(handle, token, transactionExecutor, block.timestamp);\n    }\n\n    function _deleteTokenToHandleLinkageIfAny(\n        RegistryTypes.Handle memory handle,\n        address transactionExecutor\n    ) internal {\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\n        if (tokenPointedByHandle.collection != address(0) || tokenPointedByHandle.id != 0) {\n            delete tokenToHandle[_tokenHash(tokenPointedByHandle)];\n            emit RegistryEvents.HandleUnlinked(handle, tokenPointedByHandle, transactionExecutor, block.timestamp);\n        }\n    }\n\n    function _deleteHandleToTokenLinkageIfAny(RegistryTypes.Token memory token, address transactionExecutor) internal {\n        RegistryTypes.Handle memory handlePointedByToken = tokenToHandle[_tokenHash(token)];\n        if (handlePointedByToken.collection != address(0) || handlePointedByToken.id != 0) {\n            delete handleToToken[_handleHash(handlePointedByToken)];\n            emit RegistryEvents.HandleUnlinked(handlePointedByToken, token, transactionExecutor, block.timestamp);\n        }\n    }\n\n    function _executeUnlinkage(\n        RegistryTypes.Handle memory handle,\n        RegistryTypes.Token memory token,\n        address transactionExecutor\n    ) internal {\n        delete handleToToken[_handleHash(handle)];\n        // tokenToHandle is removed too, as the first version linkage is one-to-one.\n        delete tokenToHandle[_tokenHash(token)];\n        emit RegistryEvents.HandleUnlinked(handle, token, transactionExecutor, block.timestamp);\n    }\n\n    function _handleHash(RegistryTypes.Handle memory handle) internal pure returns (bytes32) {\n        return keccak256(abi.encode(handle.collection, handle.id));\n    }\n\n    function _tokenHash(RegistryTypes.Token memory token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(token.collection, token.id));\n    }\n\n    /**\n     * @dev This fetches a signer's current nonce and increments it so it's ready for the next meta-tx. Also emits\n     * the `NonceUpdated` event.\n     *\n     * @param signer The address to get and increment the nonce for.\n     *\n     * @return uint256 The current nonce for the given signer prior to being incremented.\n     */\n    function _getNonceIncrementAndEmitEvent(address signer) private returns (uint256) {\n        uint256 currentNonce;\n        unchecked {\n            currentNonce = nonces[signer]++;\n        }\n        emit RegistryEvents.NonceUpdated(signer, currentNonce + 1, block.timestamp);\n        return currentNonce;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}